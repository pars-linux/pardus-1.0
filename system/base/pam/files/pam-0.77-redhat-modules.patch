diff -Nur Linux-PAM-0.77.orig/modules/pam_chroot/chroot.conf Linux-PAM-0.77/modules/pam_chroot/chroot.conf
--- Linux-PAM-0.77.orig/modules/pam_chroot/chroot.conf	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_chroot/chroot.conf	2001-11-21 21:42:31.000000000 +0200
@@ -0,0 +1,4 @@
+# /etc/security/chroot.conf
+# format:
+# username_regex	chroot_dir
+#matthew		/home
diff -Nur Linux-PAM-0.77.orig/modules/pam_chroot/Makefile Linux-PAM-0.77/modules/pam_chroot/Makefile
--- Linux-PAM-0.77.orig/modules/pam_chroot/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_chroot/Makefile	2001-01-05 00:51:30.000000000 +0200
@@ -0,0 +1,14 @@
+# $Id: Makefile,v 1.4 2001/01/04 22:51:30 nalin Exp $
+
+include ../../Make.Rules
+
+TITLE=pam_chroot
+
+LOCAL_CONFILE=./chroot.conf
+INSTALLED_CONFILE=$(SCONFIGD)/chroot.conf
+
+MODULE_SIMPLE_INSTALL=bash -f ../install_conf "$(FAKEROOT)" "$(SCONFIGD)" "$(INSTALLED_CONFILE)" "$(TITLE)" "$(LOCAL_CONFILE)"
+MODULE_SIMPLE_REMOVE=rm -f $(FAKEROOT)$(INSTALLED_CONFILE)
+MODULE_SIMPLE_CLEAN=rm -f ./.ignore_age
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_chroot/pam_chroot.c Linux-PAM-0.77/modules/pam_chroot/pam_chroot.c
--- Linux-PAM-0.77.orig/modules/pam_chroot/pam_chroot.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_chroot/pam_chroot.c	2001-11-21 21:42:31.000000000 +0200
@@ -0,0 +1,167 @@
+/*
+ * Linux-PAM session chroot()er
+ *
+ * $Id: pam_chroot.c,v 1.8 2001/11/21 19:42:31 nalin Exp $
+ */
+
+#include "../../_pam_aconf.h"
+
+#define	PAM_SM_SESSION
+#include "../../libpam/include/security/pam_modules.h"
+
+#include <syslog.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <regex.h>
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <limits.h>
+#include <sys/stat.h>
+
+#define	CONFIG	"/etc/security/chroot.conf"
+
+PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
+				   int argc, const char **argv)
+{
+	int ret = PAM_SESSION_ERR;
+	int debug = 0;
+	int onerr = PAM_SUCCESS;
+	char conf_line[LINE_MAX];
+	int lineno, err, i;
+	char *name, *dir;
+	char const *user;
+	FILE *conf;
+
+	openlog("pam_chroot", LOG_PID, LOG_AUTHPRIV);
+
+	/* parse command-line arguments */
+	for(i = 0; i < argc; i++) {
+		if(strcmp(argv[i], "debug") == 0)
+			debug = 1;
+		if(strncmp(argv[i], "onerr=", 6) == 0)
+			if(strncmp(argv[i] + 6, "fail", 4) == 0)
+				onerr = PAM_SESSION_ERR;
+	}
+
+	if((ret = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {
+		syslog(LOG_ERR, "can't get username: %s",
+				pam_strerror(pamh, ret));
+		return ret;
+	}
+
+	conf = fopen(CONFIG, "r");
+	if(conf == NULL) {
+		syslog(LOG_ERR, "can't open config file \"" CONFIG "\": %s",
+				strerror(errno));
+		return ret;
+	}
+
+	lineno = 0;
+	while(fgets(conf_line, sizeof(conf_line), conf)) {
+		regex_t name_regex;
+		char *p;
+
+		++lineno;
+
+		/* lose comments */
+		if((dir = strchr(conf_line, '#')))
+			*dir = 0;
+
+		/* ignore blank lines */
+		if((name = strtok_r(conf_line, " \t\r\n", &p)) == NULL)
+			continue;
+
+		if((dir = strtok_r(NULL, " \t\r\n", &p)) == NULL) {
+			syslog(LOG_ERR, CONFIG ":%d: no directory", lineno);
+			ret = onerr;
+			break;
+		}
+
+		if((err = regcomp(&name_regex, name, REG_ICASE))) {
+			char *errbuf; size_t len;
+
+			/* how foul, surely there's a nicer way? */
+			len = regerror(err, &name_regex, NULL, 0);
+			errbuf = malloc(len + 1);
+			memset(errbuf, 0, len + 1);
+			regerror(err, &name_regex, errbuf, len);
+
+			syslog(LOG_ERR, CONFIG ":%d: illegal regex \"%s\": %s",
+					lineno, name, errbuf);
+
+			free(errbuf);
+			regfree(&name_regex);
+
+			ret = onerr;
+			break;
+		}
+
+		err = regexec(&name_regex, user, 0, NULL, 0);
+		regfree(&name_regex);
+
+		if(!err) {
+			struct stat st;
+
+			if (stat(dir, &st) == -1) {
+				syslog(LOG_ERR, "stat(%s) failed: %s",
+						dir, strerror(errno));
+				ret = onerr;
+			} else
+			/* Catch the most common misuse */
+			if (st.st_uid != 0 ||
+			    (st.st_mode & (S_IWGRP | S_IWOTH))) {
+				syslog(LOG_ERR, "%s is writable by non-root",
+						dir);
+				ret = onerr;
+			} else
+			if(chdir(dir) == -1) {
+				syslog(LOG_ERR, "chdir(%s) failed: %s",
+						dir, strerror(errno));
+				ret = onerr;
+			} else {
+				if(debug) {
+					syslog(LOG_ERR, "chdir(%s) succeeded",
+							dir);
+				}
+				if(chroot(dir) == -1) {
+					syslog(LOG_ERR, "chroot(%s) failed: %s",
+							dir, strerror(errno));
+					ret = onerr;
+				} else {
+					syslog(LOG_ERR, "chroot(%s) succeeded",
+							dir);
+					ret = PAM_SUCCESS;
+				}
+			}
+			break;
+		}
+	}
+
+	fclose(conf);
+	closelog();
+	return ret;
+}
+
+PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags,
+				    int argc, const char **argv)
+{
+	return PAM_SUCCESS;
+}
+
+#ifdef PAM_STATIC
+
+/* static module data */
+
+struct pam_module _pam_chroot_modstruct = {
+	"pam_chroot",
+	NULL,
+	NULL,
+	pam_sm_acct_mgmt,
+	NULL,
+	NULL,
+	NULL
+};
+#endif
+
diff -Nur Linux-PAM-0.77.orig/modules/pam_chroot/README Linux-PAM-0.77/modules/pam_chroot/README
--- Linux-PAM-0.77.orig/modules/pam_chroot/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_chroot/README	2001-11-21 21:42:31.000000000 +0200
@@ -0,0 +1,30 @@
+This pam_chroot module provides session support only.  It is based
+almost entirely on Matthew Kirkwood's original version obtained from
+ftp://ferret.lmh.ox.ac.uk/users/weejock/pam_chroot/.
+
+Operation:
+When the calling application attempts to open a session, pam_chroot
+opens /etc/security/chroot.conf and searches for a line of the form:
+user directory
+where the "user" listed is actually a regular expression.  If the
+PAM_USER for whom the session is being opened matches the regular
+expression, the module will attempt to chroot() to the given directory.
+
+Optional arguments:
+"debug"		Log debug messages to syslog.
+"onerr="	Values can be "succeed" or "fail".  The action to take if
+		the configuration file can not be opened, the chroot()
+		fails, or the user does not match any of the expressions
+		listed in the configuration file.  Default is "succeed".
+
+Other Notes:
+The calling application must be executing with root privileges in order to
+be able to chroot() at all.  If the application needs to exec() other programs
+(such as a server process or spawning a shell), you will need to duplicate
+some portions of an actual root environment under the chroot()ed directory
+in order for it to work at all.  (This includes configuration and logging
+files.)  If configured incorrectly, this module may potentially render the
+service unusable and, under some circumstances, pose a security risk.
+
+In particular, the new root directory and all of its parent directories must
+not be writable by anyone but root.
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/chmod.c Linux-PAM-0.77/modules/pam_console/chmod.c
--- Linux-PAM-0.77.orig/modules/pam_console/chmod.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/chmod.c	2001-10-12 01:02:55.000000000 +0300
@@ -0,0 +1,227 @@
+/* This file is derived from chmod.c and stpcpy.c, included
+   in the GNU fileutils distribution.  It has been changed to be a
+   library specifically for use within the Red Hat pam_console module.
+   Changes Copyright 1999,2001 Red Hat, Inc.
+ */
+
+/* chmod -- change permission modes of files
+   Copyright (C) 89, 90, 91, 95, 1996 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "../../_pam_aconf.h"
+#include <errno.h>
+#include <glob.h>
+#include <fnmatch.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <mntent.h>
+#define NAMLEN(dirent) strlen((dirent)->d_name)
+
+#include <glib.h>
+
+#include "chmod.h"
+#include "modechange.h"
+
+#define CLOSEDIR(d) closedir (d)
+
+#ifdef _D_NEED_STPCPY
+/* stpcpy.c -- copy a string and return pointer to end of new string
+    Copyright (C) 1989, 1990 Free Software Foundation.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2, or (at your option)
+    any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software Foundation,
+    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
+
+static char *
+stpcpy (char *dest, const char *src)
+{
+  while ((*dest++ = *src++) != '\0')
+    /* Do nothing. */ ;
+  return dest - 1;
+}
+#endif /* _D_NEED_STPCPY */
+
+/* end included files */
+
+static const char *fstab_filename = "/etc/fstab";
+
+static int change_via_fstab __P ((const char *dir,
+				  const struct mode_change *changes,
+				  uid_t user, gid_t group));
+
+/* Change the mode of FILE according to the list of operations CHANGES.
+   If DEREF_SYMLINK is nonzero and FILE is a symbolic link, change the
+   mode of the referenced file.  If DEREF_SYMLINK is zero, ignore symbolic
+   links.  Return 0 if successful, 1 if errors occurred. */
+
+static int
+change_file (const char *file, const struct mode_change *changes,
+	     const int deref_symlink, uid_t user, gid_t group)
+{
+  struct stat file_stats;
+  unsigned short newmode;
+  int errors = 0;
+
+  if (lstat (file, &file_stats) == -1)
+    {
+      if (errno == ENOENT)
+        {
+          /* doesn't exist, check fstab */
+          errors |= change_via_fstab (file, changes, user, group);
+          return errors;
+	}
+      else
+        {
+          return 1;
+        }
+    }
+
+  if (S_ISLNK (file_stats.st_mode))
+    {
+      /* don't bother with dangling symlinks */
+      if (stat (file, &file_stats))
+	{
+	  return 1;
+	}
+    }
+
+  newmode = mode_adjust (file_stats.st_mode, changes);
+
+  if (S_ISDIR (file_stats.st_mode))
+    errors |= change_via_fstab (file, changes, user, group);
+  else
+    {
+      if (newmode != (file_stats.st_mode & 07777))
+        {
+          if (chmod (file, (int) newmode) == -1)
+	    {
+	      errors = 1;
+	    }
+        }
+      errors |= chown (file, user, group);
+    }
+
+  return errors;
+}
+
+static void
+chmod_set_fstab(const char *fstab)
+{
+  fstab_filename = strdup(fstab);
+}
+
+
+/* If the directory spec given matches a filesystem listed in /etc/fstab,
+ * modify the device special associated with that filesystem. */
+static int
+change_via_fstab (const char *dir, const struct mode_change *changes,
+		  uid_t user, gid_t group)
+{
+  int errors = 0;
+  FILE *fstab;
+  struct mntent *mntent;
+
+  fstab = setmntent(fstab_filename, "r");
+
+  if (fstab == NULL)
+    {
+      return 1;
+    }
+
+  for(mntent = getmntent(fstab); mntent != NULL; mntent = getmntent(fstab))
+    {
+      if(mntent->mnt_dir &&
+         mntent->mnt_fsname &&
+	 (fnmatch(dir, mntent->mnt_dir, 0) == 0))
+        {
+          errors |= change_file(mntent->mnt_fsname, changes, TRUE, user, group);
+        }
+    }
+
+  endmntent(fstab);
+
+  return errors;
+}
+
+/* Parse the ASCII mode into a linked list
+   of `struct mode_change' and apply that to each file argument. */
+
+
+static int
+glob_errfn(const char *pathname, int theerr) {
+  /* silently ignore inaccessible files */
+  return 0;
+}
+
+#define DIE(n) {fprintf(stderr, "chmod failure\n"); return (n);}
+
+STATIC int
+chmod_files (const char *mode, uid_t user, gid_t group,
+	     char *single_file, GSList *filelist)
+{
+  struct mode_change *changes;
+  int errors = 0;
+  glob_t result;
+  char *filename = NULL;
+  int flags = GLOB_NOCHECK;
+  int i, rc;
+
+  changes = mode_compile (mode,
+			  MODE_MASK_EQUALS | MODE_MASK_PLUS | MODE_MASK_MINUS);
+  if (changes == MODE_INVALID) DIE(1)
+  else if (changes == MODE_MEMORY_EXHAUSTED) DIE(1)
+
+  for (; filelist; filelist = filelist->next)
+  {
+    filename = filelist->data;
+    rc = glob(filename, flags, glob_errfn, &result);
+    if (rc == GLOB_NOSPACE) DIE(1)
+    flags |= GLOB_APPEND;
+  }
+  if(single_file) {
+    rc = glob(single_file, flags, glob_errfn, &result);
+    if (rc == GLOB_NOSPACE) DIE(1)
+  }
+
+  for (i = 0; i < result.gl_pathc; i++) {
+    errors |= change_file (result.gl_pathv[i], changes, 1, user, group);
+#if 0
+    _pam_log(LOG_DEBUG, TRUE,
+	     "file %s (%d): mode %s\n", result.gl_pathv[i], user, mode);
+#endif
+  }
+
+  globfree(&result);
+
+  return (errors);
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/chmod.h Linux-PAM-0.77/modules/pam_console/chmod.h
--- Linux-PAM-0.77.orig/modules/pam_console/chmod.h	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/chmod.h	2001-03-07 18:52:47.000000000 +0200
@@ -0,0 +1,14 @@
+#include <glib.h>
+#include <unistd.h>
+
+#ifndef _CHMOD_H
+#define _CHMOD_H
+
+#ifndef STATIC
+#define STATIC
+#endif
+
+STATIC int chmod_files (const char *mode, uid_t user, gid_t group, char *filename, GSList *filelist);
+STATIC void chmod_set_fstab(const char *fstab);
+
+#endif /* _CHMOD_H */
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/config.l Linux-PAM-0.77/modules/pam_console/config.l
--- Linux-PAM-0.77.orig/modules/pam_console/config.l	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/config.l	2000-07-26 13:40:34.000000000 +0300
@@ -0,0 +1,60 @@
+%option noyywrap
+%{
+/* Copyright 1999,2000 Red Hat, Inc.
+ * This software may be used under the terms of the GNU General Public
+ * License, available in the file COPYING accompanying this file
+ */
+/* get around an apparant bug in bison; YYSTYPE not copied into config.tab.h */
+#define YYSTYPE void *
+#include "config.tab.h"
+#include <stdio.h>
+#include <string.h>
+#include <glib.h>
+
+static int lineno;
+static char *filename;
+
+STATIC char *
+strip_slash(char *);
+%}
+%%
+\n			{ lineno++; return EOL; }
+\\\n			{ lineno++; }
+			/* do not return EOL, eat up escaped newline */
+[ \t]+			/* ignore whitespace */
+\<			{ return OBRACKET; }
+\>=			{ return CBEQUALS; }
+\>			{ return CBRACKET; }
+([^\t\n #\<\>]|(\\#\\\<\\\>))+	{ _pc_yylval=strip_slash(yytext); return STRING; }
+#.*\n			{ lineno++; return EOL; } /* ignore comments */
+%%
+
+static void
+lex_file (FILE *in) {
+  /* yy_flex_debug = 1; */
+  yyin = in;
+  lineno = 1;
+}
+
+static void
+lex_set_filename(char *name) {
+  filename = name;
+}
+
+static int
+_pc_yyerror (char *s) {
+  _pam_log(LOG_ERR, 0, "%s line %d: %s: at `%s'\n",
+	   filename, lineno, s, (char *)_pc_yylval);
+  return 0;
+}
+
+STATIC char *
+strip_slash(char *s) {
+  char *r, *t;
+
+  r = g_strdup(s);
+  while ((t = strstr(s, "\\#")), t) {
+    memmove(t, t+1, strlen(t));
+  }
+  return r;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/config.y Linux-PAM-0.77/modules/pam_console/config.y
--- Linux-PAM-0.77.orig/modules/pam_console/config.y	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/config.y	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,356 @@
+%{
+/* Copyright 1999,2000 Red Hat, Inc.
+ * This software may be used under the terms of the GNU General Public
+ * License, available in the file COPYING accompanying this file
+ */
+#define YYSTYPE void *
+
+#include <errno.h>
+#include <glib.h>
+#include <grp.h>
+#include <limits.h>
+#include <regex.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <security/pam_modules.h>
+#include <security/_pam_modutil.h>
+
+static GHashTable *namespace = NULL;
+static GSList *configList = NULL;
+static GSList *configListEnd = NULL;
+static GSList *consoleClassList = NULL;
+static GSList *consoleClassListEnd = NULL;
+static const char *consoleNameCache = NULL;
+static GHashTable *consoleHash = NULL;
+
+static void
+do_yyerror(const char *format, ...);
+
+static void
+free_class(class *c);
+
+%}
+
+%token EOL
+%token OBRACKET
+%token CBEQUALS
+%token CBRACKET
+%token STRING
+
+%%
+lines:		lines line
+	|	/* empty */
+	;
+
+line:		config
+	|	classdef
+	|	EOL
+	|	error
+	;
+
+classdef:
+		OBRACKET string CBEQUALS stringlist EOL {
+		  void *old;
+		  class *c;
+
+		  old = g_hash_table_lookup(namespace, $2);
+		  if (old) free_class(old);
+
+		  c = g_malloc(sizeof(class));
+		  c->name = $2;
+		  c->list = $4;
+		  g_hash_table_insert(namespace, $2, c);
+		}
+	;
+
+config:		classlist STRING classlist optstring optstring EOL {
+		  config *conf = g_malloc(sizeof(config));
+		  conf->console_class = $1;
+		  conf->mode = $2;
+		  conf->device_class = $3;
+		  conf->revert_mode = $4;
+		  conf->revert_owner = $5;
+                  if (conf->revert_owner != NULL) {
+                      conf->revert_group = strchr (conf->revert_owner, ':');
+                      if (conf->revert_group == NULL)
+                          conf->revert_group = strchr (conf->revert_owner, '.');
+                      if (conf->revert_group != NULL) {
+                          *(conf->revert_group) = '\0';
+                          conf->revert_group++;
+                          if (*(conf->revert_group) == '\0')
+                              conf->revert_group = NULL;
+                          if (*(conf->revert_owner) == '\0')
+                              conf->revert_owner = NULL;
+                      }
+                  }
+		  configListEnd = g_slist_append(configListEnd, conf);
+		  if (configListEnd->next) configListEnd = configListEnd->next;
+		  if (!configList) configList = configListEnd;
+		  consoleClassListEnd =
+		    g_slist_append(consoleClassListEnd, conf->console_class);
+		  if (consoleClassListEnd->next)
+		    consoleClassListEnd = consoleClassListEnd->next;
+		  if (!consoleClassList) consoleClassList = consoleClassListEnd;
+		}
+	;
+
+classlist:	OBRACKET string CBRACKET {
+		  class *c = g_hash_table_lookup(namespace, $2);
+		  if(!c) {
+		    g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+			  "unknown class \"%s\" at line %d in %s\n",
+			  $2, lineno, filename);
+		    _exit(1);
+		  }
+		  $$ = c;
+		}
+	|	string {
+		  class *c = g_malloc(sizeof(class));
+		  c->name = $1;
+		  c->list = NULL;
+		  $$ = c;
+		}
+	;
+
+
+stringlist:	string	{$$ = g_slist_append(NULL, $1);}
+	|	stringlist string {$$ = g_slist_append($1, $2);}
+	;
+
+optstring:	string	{$$=$1;}
+	|	/* empty */ {$$=NULL;}
+	;
+
+string:		STRING {$$=$1;} ;
+
+%%
+
+/* exported functions */
+
+/* parse a file given by a file descriptor open for reading, then
+   close the file it applies to */
+STATIC void
+parse_file(char *name) {
+  FILE *infile;
+
+  _pam_log(LOG_DEBUG, TRUE, "parsing config file %s", name);
+  infile = fopen(name, "r");
+  if (!infile) {
+    _pam_log(LOG_ERR, FALSE, "could not parse required file %s", name);
+    return;
+  }
+
+  if (!namespace) namespace = g_hash_table_new(g_str_hash, g_str_equal);
+
+  lex_set_filename(name);
+  lex_file(infile);
+
+  yyparse();
+  fclose(infile);
+}
+
+static int
+check_one_console_name (const char *name, char *classComponent) {
+    regex_t p;
+    int r_err;
+    char *class_exp;
+
+    class_exp = _do_malloc(strlen(classComponent) + 3);
+    sprintf(class_exp, "^%s$", classComponent);
+    r_err = regcomp(&p, class_exp, REG_EXTENDED|REG_NOSUB);
+    if (r_err) do_regerror(r_err, &p);
+    r_err = regexec(&p, name, 0, NULL, 0);
+    regfree(&p);
+    free (class_exp);
+    return !r_err;
+}
+
+STATIC int
+check_console_name (const char *consolename, int nonroot_ok) {
+    GSList *this_class;
+    GSList *this_list;
+    class *c;
+    int found = 0;
+    int statted = 0;
+    struct stat st;
+    char full_path[PATH_MAX];
+
+    _pam_log(LOG_DEBUG, TRUE, "check console %s", consolename);
+    if (consoleNameCache != consolename) {
+	consoleNameCache = consolename;
+	if (consoleHash) g_hash_table_destroy(consoleHash);
+	consoleHash = g_hash_table_new(NULL, NULL);
+    }
+    for (this_class = consoleClassList; this_class;
+	 this_class = this_class->next) {
+	c = this_class->data;
+        if (c->list) {
+	    for (this_list = c->list; this_list; this_list = this_list->next) {
+		if (check_one_console_name(consolename, this_list->data)) {
+		    g_hash_table_insert(consoleHash, c, c);
+		    found = 1;
+		}
+	    }
+	} else {
+	    if (check_one_console_name(consolename, c->name)) {
+		g_hash_table_insert(consoleHash, c, c);
+		found = 1;
+	    }
+	}
+    }
+
+    /* add some policy here -- not really the PAM way of doing things, but
+       it gives us an extra measure of security in case of misconfiguration */
+    memset(&st, 0, sizeof(st));
+    statted = 0;
+
+    _pam_log(LOG_DEBUG, TRUE, "checking possible console \"%s\"", consolename);
+    if (lstat(consolename, &st) != -1) {
+        statted = 1;
+    }
+    if (!statted) {
+        strcpy(full_path, "/dev/");
+        strncat(full_path, consolename,
+                sizeof(full_path) - 1 - strlen(full_path));
+	full_path[sizeof(full_path) - 1] = '\0';
+        _pam_log(LOG_DEBUG, TRUE, "checking possible console \"%s\"",
+		 full_path);
+        if (lstat(full_path, &st) != -1) {
+           statted = 1;
+        }
+    }
+    if (!statted && (consolename[0] == ':')) {
+        size_t l;
+        char *dot = NULL;
+        strcpy(full_path, "/tmp/.X11-unix/X");
+        l = sizeof(full_path) - 1 - strlen(full_path);
+        dot = strchr(consolename + 1, '.');
+        if (dot != NULL) {
+            l = (l < dot - consolename - 1) ? l : dot - consolename - 1;
+        }
+        strncat(full_path, consolename + 1, l);
+	full_path[sizeof(full_path) - 1] = '\0';
+        _pam_log(LOG_DEBUG, TRUE, "checking possible console \"%s\"",
+		 full_path);
+        if (lstat(full_path, &st) != -1) {
+           statted = 1;
+        }
+    }
+
+    if (statted) {
+        int ok = 0;
+        if (st.st_uid == 0) {
+            _pam_log(LOG_DEBUG, TRUE, "console %s is owned by UID 0", consolename);
+            ok = 1;
+        }
+        if (S_ISCHR(st.st_mode)) {
+            _pam_log(LOG_DEBUG, TRUE, "console %s is a character device", consolename);
+            ok = 1;
+        }
+        if (!ok && !nonroot_ok) {
+            _pam_log(LOG_INFO, TRUE, "%s is not a valid console device because it is owned by UID %d and the allow_nonroot flag was not set", consolename, st.st_uid);
+            found = 0;
+        }
+    } else {
+        _pam_log(LOG_INFO, TRUE, "can't find device or X11 socket to examine for %s", consolename);
+        found = 0;
+    }
+
+    if (found)
+	return 1;
+
+    /* not found */
+    _pam_log(LOG_INFO, TRUE, "did not find console %s", consolename);
+    if (consoleHash) {
+	g_hash_table_destroy(consoleHash);
+	consoleHash = NULL;
+    }
+    return 0;
+}
+
+STATIC int
+set_permissions(pam_handle_t *pamh, const char *consolename, const char *username, int nonroot_ok) {
+    struct passwd *pwd;
+    config *c;
+    GSList *cl;
+
+    if (!consoleNameCache || strcmp(consolename, consoleNameCache)) {
+	if (!check_console_name(consolename, nonroot_ok)) return -1;
+    }
+
+    pwd = _pammodutil_getpwnam(pamh, username);
+    if (pwd == NULL) {
+	_pam_log(LOG_ERR, FALSE, "getpwnam failed for \"%s\"", username);
+	return -1;
+    }
+
+    for (cl = configList; cl; cl = cl->next) {
+	c = cl->data;
+	if (g_hash_table_lookup(consoleHash, c->console_class)) {
+	    if (c->device_class->list)
+		chmod_files(c->mode, pwd->pw_uid, -1, NULL, c->device_class->list);
+	    else
+		chmod_files(c->mode, pwd->pw_uid, -1, c->device_class->name, NULL);
+	}
+    }
+    return 0;
+}
+
+STATIC int
+reset_permissions(pam_handle_t *pamh, const char *consolename, int nonroot_ok) {
+    struct passwd *pwd;
+    struct group *grp;
+    config *c;
+    GSList *cl;
+
+    if (!consoleNameCache || strcmp(consolename, consoleNameCache)) {
+	if (!check_console_name(consolename, nonroot_ok)) return -1;
+    }
+
+    for (cl = configList; cl; cl = cl->next) {
+	c = cl->data;
+	if (g_hash_table_lookup(consoleHash, c->console_class)) {
+	    pwd = _pammodutil_getpwnam(pamh, c->revert_owner ? c->revert_owner : "root");
+	    if (pwd == NULL) {
+		_pam_log(LOG_ERR, FALSE, "getpwnam failed for %s",
+			 c->revert_owner ? c->revert_owner : "root");
+		return -1;
+	    }
+	    grp = _pammodutil_getgrnam(pamh, c->revert_group ? c->revert_group : "root");
+	    if (grp == NULL) {
+                _pam_log(LOG_ERR, FALSE, "getgrnam failed for %s",
+                         c->revert_group ? c->revert_group : "root");
+                return -1;
+            }
+	    if (c->device_class->list)
+		chmod_files(c->revert_mode ? c->revert_mode : "0600",
+			    pwd->pw_uid, grp->gr_gid, NULL, c->device_class->list);
+	    else
+		chmod_files(c->revert_mode ? c->revert_mode : "0600",
+			    pwd->pw_uid, grp->gr_gid, c->device_class->name, NULL);
+	}
+    }
+    return 0;
+}
+
+
+
+
+/* local, static functions */
+
+static void
+do_yyerror(const char *format, ...) {
+  va_list ap;
+
+  va_start(ap, format);
+  openlog("pam_console", LOG_CONS|LOG_PID, LOG_AUTHPRIV);
+  vsyslog(LOG_PID|LOG_AUTHPRIV|LOG_ERR, format, ap);
+  va_end(ap);
+}
+
+static void
+free_class(class *c) {
+  if (c->name) free (c->name);
+  if (c) free (c);
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/console.apps.5 Linux-PAM-0.77/modules/pam_console/console.apps.5
--- Linux-PAM-0.77.orig/modules/pam_console/console.apps.5	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/console.apps.5	2001-03-20 22:50:14.000000000 +0200
@@ -0,0 +1,18 @@
+.\" Copyright 1999 Red Hat Software, Inc.
+.\" Written by Michael K. Johnson <johnsonm@redhat.com>
+.TH console.apps 5 1999/2/4 "Red Hat Software" "System Administrator's Manual"
+.SH NAME
+console.apps \- specify console-accessible privileged applications
+.SH DESCRIPTION
+The /etc/security/console.apps/ directory should contain one file
+per application that wishes to allow access to console users.
+The filename should be the same as the servicename, and the
+contents are irrelevant; the file may be a zero-length file.
+The application that the file is used by is free to specify the
+contents in any way that is useful for it.
+.SH "SEE ALSO"
+.BR pam_console (8)
+.br
+.BR console.perms (5)
+.SH AUTHOR
+Michael K. Johnson <johnsonm@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/console.perms Linux-PAM-0.77/modules/pam_console/console.perms
--- Linux-PAM-0.77.orig/modules/pam_console/console.perms	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/console.perms	2001-08-31 03:54:50.000000000 +0300
@@ -0,0 +1,72 @@
+# /etc/security/console.perms
+#
+# This file determines the permissions that will be given to priviledged
+# users of the console at login time, and the permissions to which to
+# revert when the users log out.
+
+# format is:
+#   <class>=list of regexps specifying consoles or globs specifying files
+#   file-glob|<class> perm dev-regex|<dev-class> \
+#     revert-mode revert-owner[.revert-group]
+# the revert-mode, revert-owner, and revert-group are optional, and default
+# to 0600, root, and root, respectively.
+#
+# For more information:
+# man 5 console.perms
+
+# file classes -- these are regular expressions
+<console>=tty[0-9][0-9]* vc/[0-9][0-9]* :[0-9]\.[0-9] :[0-9]
+<xconsole>=:[0-9]\.[0-9] :[0-9]
+
+# device classes -- these are shell-style globs
+<floppy>=/dev/fd[0-1]* \
+	 /dev/floppy/* /mnt/floppy*
+<sound>=/dev/dsp* /dev/audio* /dev/midi* \
+	/dev/mixer* /dev/sequencer \
+	/dev/sound/* /dev/beep
+<cdrom>=/dev/cdrom* /dev/cdroms/* /dev/cdwriter* /mnt/cdrom*
+<pilot>=/dev/pilot
+<jaz>=/mnt/jaz*
+<zip>=/mnt/pocketzip* /mnt/zip*
+<ls120>=/dev/ls120 /mnt/ls120*
+<scanner>=/dev/scanner /dev/usb/scanner*
+<rio500>=/dev/usb/rio500
+<camera>=/mnt/camera* /dev/usb/dc2xx* /dev/usb/mdc800*
+<memstick>=/mnt/memstick*
+<flash>=/mnt/flash*
+<diskonkey>=/mnt/diskonkey*
+<rem_ide>=/mnt/microdrive*
+<fb>=/dev/fb /dev/fb[0-9]* \
+     /dev/fb/*
+<kbd>=/dev/kbd
+<joystick>=/dev/js[0-9]*
+<v4l>=/dev/video* /dev/radio* /dev/winradio* /dev/vtx* /dev/vbi* \
+      /dev/video/*
+<gpm>=/dev/gpmctl
+<dri>=/dev/nvidia* /dev/3dfx*
+<mainboard>=/dev/apm_bios
+
+# permission definitions
+<console>  0660 <floppy>     0660 root.floppy
+<console>  0600 <sound>      0600 root
+<console>  0600 <cdrom>      0660 root.disk
+<console>  0600 <pilot>      0660 root.uucp
+<console>  0600 <jaz>        0660 root.disk
+<console>  0600 <zip>        0660 root.disk
+<console>  0600 <ls120>      0660 root.disk
+<console>  0600 <scanner>    0600 root
+<console>  0600 <camera>     0600 root
+<console>  0600 <memstick>   0600 root
+<console>  0600 <flash>      0600 root
+<console>  0600 <diskonkey>  0660 root.disk
+<console>  0600 <rem_ide>    0660 root.disk
+<console>  0600 <fb>         0600 root
+<console>  0600 <kbd>        0600 root
+<console>  0600 <joystick>   0600 root
+<console>  0600 <v4l>        0600 root
+<console>  0700 <gpm>	     0700 root
+<console>  0600 <mainboard>  0600 root
+<console>  0600 <rio500>     0600 root
+
+<xconsole> 0600 /dev/console 0600 root.root
+<xconsole> 0600 <dri>	     0600 root
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/console.perms.5 Linux-PAM-0.77/modules/pam_console/console.perms.5
--- Linux-PAM-0.77.orig/modules/pam_console/console.perms.5	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/console.perms.5	2001-03-20 22:50:14.000000000 +0200
@@ -0,0 +1,49 @@
+.\" Copyright 1999 Red Hat Software, Inc.
+.\" Written by Michael K. Johnson <johnsonm@redhat.com>
+.TH console.perms 5 1999/2/3 "Red Hat Software" "System Administrator's Manual"
+.SH NAME
+console.perms \- permissions control file for users at the system console
+.SH DESCRIPTION
+/etc/security/console.perms determines the permissions that will be
+given to priviledged users of the console at login time, and the
+permissions to which to revert when the users log out.  It is
+read by the pam_console module.
+
+The format is:
+
+\f(CR<\fBclass\f(CR>=\fBspace-separated list of words
+
+\fBlogin-regexp\fI|\f(CR<\fBlogin-class\f(CR> \fBperm dev-glob\fI|\f(CR<\fBdev-class\f(CR> \e
+.br
+\f(CR        \fBrevert-mode revert-owner\fI[\fP.revert-group\fI]\fR
+
+The \fBrevert-mode\fP, \fBrevert-owner\fR, and revert-group fields are optional,
+and default to \fB0600\fP, \fBroot\fP, and \fBroot\fP, respectively.
+
+The words in a class definition are evaluated as globs if they
+refer to files, but as regular expressions if they apply to a
+console definition.  Do not mix them.
+
+Any line can be broken and continued on the next line by using a
+\e character as the last character on the line.
+
+The \fBlogin-class\fP class and the \fBlogin-regexp\fP word are evaluated as
+regular expressions.
+The \fBdev-class\fP and the \fBdev-glob\fP word are evaluated as
+shell-style globs.  If a name given corresponds to a directory, and
+if it is a mount point listed in \fI/etc/fstab\fP, the device node
+associated with the filesystem mounted at that point will be
+substituted in its place.
+
+Classes are denoted by being contained in \f(CR<\fR angle bracket \f(CR>\fR
+characters; a lack of \f(CR<\fR angle brackets \f(CR>\fR indicates that
+the string is to be taken literally as a \fBlogin-regexp\fP or a
+\fBdev-glob\fP, depending on its input position.
+.SH "SEE ALSO"
+.BR pam_console (8)
+.br
+.BR pam_console_apply (8)
+.br
+.BR console.apps (5)
+.SH AUTHOR
+Michael K. Johnson <johnsonm@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/COPYING Linux-PAM-0.77/modules/pam_console/COPYING
--- Linux-PAM-0.77.orig/modules/pam_console/COPYING	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/COPYING	2000-01-03 20:08:44.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/.cvsignore Linux-PAM-0.77/modules/pam_console/.cvsignore
--- Linux-PAM-0.77.orig/modules/pam_console/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/.cvsignore	2000-03-21 00:22:32.000000000 +0200
@@ -0,0 +1,3 @@
+config.tab.c
+config.tab.h
+config.lex.c
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/Makefile Linux-PAM-0.77/modules/pam_console/Makefile
--- Linux-PAM-0.77.orig/modules/pam_console/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/Makefile	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,130 @@
+#
+# This Makefile controls a build process of $(TITLE) module for
+# Linux-PAM. You should not modify this Makefile (unless you know
+# what you are doing!).
+#
+
+include ../../Make.Rules
+
+TITLE=pam_console
+
+LOCKDIR = /var/run/console
+LOCKMODE = 755
+LIBS +=  $(shell glib-config --libs) -L../pammodutil -lpammodutil
+LDFLAGS = $(LIBS)
+
+BINARY = pam_console_apply
+BINSRC = $(TITLE)_apply.c
+LOCAL_CONFILE = console.perms
+INSTALLED_CONFILE = $(SCONFIGD)/console.perms
+MAN5 = console.apps.5 console.perms.5
+MAN8 = pam_console.8 pam_console_apply.8
+
+CFLAGS += $(shell glib-config --cflags) -D_GNU_SOURCE -DLOCKDIR=\"$(LOCKDIR)\" -I../pammodutil/include
+
+FLEX_OPTS = -Cr
+BISON_OPTS = -d
+
+LIBSRC = $(TITLE).c
+LIBOBJ = $(TITLE).o
+LIBOBJD = $(addprefix dynamic/,$(LIBOBJ))
+LIBOBJS = $(addprefix static/,$(LIBOBJ))
+
+ifdef DYNAMIC
+LIBSHARED = $(TITLE).so
+endif
+
+ifdef STATIC
+LIBSTATIC = lib$(TITLE).o
+endif
+
+####################### don't edit below #######################
+
+all: dirs $(LIBSHARED) $(LIBSTATIC) register $(BINARY)
+
+dynamic/%.o : %.c
+	$(CC) $(CFLAGS) $(DYNAMIC) $(TARGET_ARCH) -c $< -o $@
+
+static/%.o : %.c
+	$(CC) $(CFLAGS) $(STATIC) $(TARGET_ARCH) -c $< -o $@
+
+dirs:
+ifdef DYNAMIC
+	@$(MKDIR) ./dynamic
+endif
+ifdef STATIC
+	@$(MKDIR) ./static
+endif
+
+register:
+ifdef STATIC
+	( cd .. ; ./register_static $(TITLE) $(TITLE)/$(LIBSTATIC) )
+endif
+
+$(BINARY): $(BINSRC)
+	$(CC) $(CFLAGS) $(TARGET_ARCH) -o $@ $^ -Wl,-Bstatic $(LDFLAGS) -Wl,-Bdynamic ../../libpam/libpam.so -lc
+
+ifdef DYNAMIC
+$(LIBOBJD): $(LIBSRC)
+endif
+
+ifdef DYNAMIC
+$(LIBSHARED):	$(LIBOBJD)
+	$(LD_D) -o $@ $(LIBOBJD) $(LIBS) $(NEED_LINK_LIB_C)
+
+endif
+
+ifdef STATIC
+$(LIBOBJS): $(LIBSRC)
+endif
+
+ifdef STATIC
+$(LIBSTATIC): $(LIBOBJS)
+	$(LD) -r -o $@ $(LIBOBJS) $(LIBS)
+endif
+
+install: all
+	$(MKDIR) $(FAKEROOT)$(SECUREDIR)
+ifdef DYNAMIC
+	$(INSTALL) -m $(SHLIBMODE) $(LIBSHARED) $(FAKEROOT)$(SECUREDIR)
+endif
+ifdef MAN3
+	test -d $(FAKEROOT)$(MANDIR)/man3 || $(MKDIR) $(FAKEROOT)$(MANDIR)/man3
+	$(INSTALL) -m $(MANMODE) $(MAN3) $(FAKEROOT)$(MANDIR)/man3/
+endif
+ifdef MAN5
+	test -d $(FAKEROOT)$(MANDIR)/man5 || $(MKDIR) $(FAKEROOT)$(MANDIR)/man5
+	$(INSTALL) -m $(MANMODE) $(MAN5) $(FAKEROOT)$(MANDIR)/man5/
+endif
+ifdef MAN8
+	test -d $(FAKEROOT)$(MANDIR)/man8 || $(MKDIR) $(FAKEROOT)$(MANDIR)/man8
+	$(INSTALL) -m $(MANMODE) $(MAN8) $(FAKEROOT)$(MANDIR)/man8/
+endif
+	$(MKDIR) -m $(LOCKMODE) $(FAKEROOT)$(LOCKDIR) $(FAKEROOT)/$(SCONFIGD)/console.apps && bash -f ../install_conf "$(FAKEROOT)" "$(SCONFIGD)" "$(INSTALLED_CONFILE)" "$(TITLE)" "$(LOCAL_CONFILE)"
+	test -d  $(FAKEROOT)$(SUPLEMENTED) || install -m 755 -d $(FAKEROOT)$(SUPLEMENTED)
+	install -m 555 $(BINARY) $(FAKEROOT)$(SUPLEMENTED)
+
+
+remove:
+	rm -f $(FAKEROOT)$(SECUREDIR)/$(TITLE).so
+
+clean:
+	rm -f $(BINARY) $(LIBOBJD) $(LIBOBJS) core *~
+	rm -f *.a *.o *.so *.bak
+	rm -f config.tab.c config.tab.h config.lex.c
+	rm -rf dynamic static
+	$(CLEAN)
+
+.c.o:	
+	$(CC) $(CFLAGS) -c $<
+
+config.tab.c: config.y
+	bison $(BISON_OPTS) -p _pc_yy $<
+	sh ./sed-static $@
+
+config.lex.c: config.l config.tab.c
+	flex $(FLEX_OPTS) -o$@ -P_pc_yy $<
+	sh ./sed-static $@
+
+$(LIBSRC): pam_console.h chmod.c modechange.c regerr.c config.lex.c config.tab.c
+$(BINSRC): pam_console.h chmod.c modechange.c regerr.c config.lex.c config.tab.c
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/modechange.c Linux-PAM-0.77/modules/pam_console/modechange.c
--- Linux-PAM-0.77.orig/modules/pam_console/modechange.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/modechange.c	2001-10-12 01:02:55.000000000 +0300
@@ -0,0 +1,324 @@
+/* This file is derived from modechange.c included in the GNU fileutils
+   distribution.  It has been changed to be a library specifically
+   for use within pam_console
+   Changes Copyright 1999 Red Hat Software, Inc.
+ */
+
+/* modechange.c -- file mode manipulation
+   Copyright (C) 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* Written by David MacKenzie <djm@ai.mit.edu> */
+
+/* The ASCII mode string is compiled into a linked list of `struct
+   modechange', which can then be applied to each file to be changed.
+   We do this instead of re-parsing the ASCII string for each file
+   because the compiled form requires less computation to use; when
+   changing the mode of many files, this probably results in a
+   performance gain. */
+
+#include "../../_pam_aconf.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "modechange.h"
+
+#include <stdlib.h>
+
+/* Return newly allocated memory to hold one element of type TYPE. */
+#define talloc(type) ((type *) malloc (sizeof (type)))
+
+#define isodigit(c) ((c) >= '0' && (c) <= '7')
+
+/* Return a positive integer containing the value of the ASCII
+   octal number S.  If S is not an octal number, return -1.  */
+
+static int
+oatoi (const char *s)
+{
+  register int i;
+
+  if (*s == 0)
+    return -1;
+  for (i = 0; isodigit (*s); ++s)
+    i = i * 8 + *s - '0';
+  if (*s)
+    return -1;
+  return i;
+}
+
+/* Return a linked list of file mode change operations created from
+   MODE_STRING, an ASCII string that contains either an octal number
+   specifying an absolute mode, or symbolic mode change operations with
+   the form:
+   [ugoa...][[+-=][rwxXstugo...]...][,...]
+   MASKED_OPS is a bitmask indicating which symbolic mode operators (=+-)
+   should not affect bits set in the umask when no users are given.
+   Operators not selected in MASKED_OPS ignore the umask.
+
+   Return MODE_INVALID if `mode_string' does not contain a valid
+   representation of file mode change operations;
+   return MODE_MEMORY_EXHAUSTED if there is insufficient memory. */
+
+STATIC struct mode_change *
+mode_compile (mode_string, masked_ops)
+     const char *mode_string;
+     unsigned masked_ops;
+{
+  struct mode_change *head;	/* First element of the linked list. */
+  struct mode_change *change;	/* An element of the linked list. */
+  int i;			/* General purpose temporary. */
+  int umask_value;		/* The umask value (surprise). */
+  unsigned short affected_bits;	/* Which bits in the mode are operated on. */
+  unsigned short affected_masked; /* `affected_bits' modified by umask. */
+  unsigned ops_to_mask;		/* Operators to actually use umask on. */
+
+  i = oatoi (mode_string);
+  if (i >= 0)
+    {
+      if (i > 07777)
+	return MODE_INVALID;
+      head = talloc (struct mode_change);
+      if (head == NULL)
+	return MODE_MEMORY_EXHAUSTED;
+      head->next = NULL;
+      head->op = '=';
+      head->flags = 0;
+      head->value = i;
+      head->affected = 07777;	/* Affect all permissions. */
+      return head;
+    }
+
+  umask_value = umask (0);
+  umask (umask_value);		/* Restore the old value. */
+
+  head = NULL;
+  change = NULL;
+  --mode_string;
+
+  /* One loop iteration for each "ugoa...=+-rwxXstugo...[=+-rwxXstugo...]". */
+  do
+    {
+      affected_bits = 0;
+      ops_to_mask = 0;
+      /* Turn on all the bits in `affected_bits' for each group given. */
+      for (++mode_string;; ++mode_string)
+	switch (*mode_string)
+	  {
+	  case 'u':
+	    affected_bits |= 04700;
+	    break;
+	  case 'g':
+	    affected_bits |= 02070;
+	    break;
+	  case 'o':
+	    affected_bits |= 01007;
+	    break;
+	  case 'a':
+	    affected_bits |= 07777;
+	    break;
+	  default:
+	    goto no_more_affected;
+	  }
+
+    no_more_affected:
+      /* If none specified, affect all bits, except perhaps those
+	 set in the umask. */
+      if (affected_bits == 0)
+	{
+	  affected_bits = 07777;
+	  ops_to_mask = masked_ops;
+	}
+
+      while (*mode_string == '=' || *mode_string == '+' || *mode_string == '-')
+	{
+	  /* Add the element to the tail of the list, so the operations
+	     are performed in the correct order. */
+	  if (head == NULL)
+	    {
+	      head = talloc (struct mode_change);
+	      if (head == NULL)
+		return MODE_MEMORY_EXHAUSTED;
+	      change = head;
+	    }
+	  else
+	    {
+	      change->next = talloc (struct mode_change);
+	      if (change->next == NULL)
+		{
+		  mode_free (change);
+		  return MODE_MEMORY_EXHAUSTED;
+		}
+	      change = change->next;
+	    }
+
+	  change->next = NULL;
+	  change->op = *mode_string;	/* One of "=+-". */
+	  affected_masked = affected_bits;
+	  if (ops_to_mask & (*mode_string == '=' ? MODE_MASK_EQUALS
+			     : *mode_string == '+' ? MODE_MASK_PLUS
+			     : MODE_MASK_MINUS))
+	    affected_masked &= ~umask_value;
+	  change->affected = affected_masked;
+	  change->value = 0;
+	  change->flags = 0;
+
+	  /* Set `value' according to the bits set in `affected_masked'. */
+	  for (++mode_string;; ++mode_string)
+	    switch (*mode_string)
+	      {
+	      case 'r':
+		change->value |= 00444 & affected_masked;
+		break;
+	      case 'w':
+		change->value |= 00222 & affected_masked;
+		break;
+	      case 'X':
+		change->flags |= MODE_X_IF_ANY_X;
+		/* Fall through. */
+	      case 'x':
+		change->value |= 00111 & affected_masked;
+		break;
+	      case 's':
+		/* Set the setuid/gid bits if `u' or `g' is selected. */
+		change->value |= 06000 & affected_masked;
+		break;
+	      case 't':
+		/* Set the "save text image" bit if `o' is selected. */
+		change->value |= 01000 & affected_masked;
+		break;
+	      case 'u':
+		/* Set the affected bits to the value of the `u' bits
+		   on the same file.  */
+		if (change->value)
+		  goto invalid;
+		change->value = 00700;
+		change->flags |= MODE_COPY_EXISTING;
+		break;
+	      case 'g':
+		/* Set the affected bits to the value of the `g' bits
+		   on the same file.  */
+		if (change->value)
+		  goto invalid;
+		change->value = 00070;
+		change->flags |= MODE_COPY_EXISTING;
+		break;
+	      case 'o':
+		/* Set the affected bits to the value of the `o' bits
+		   on the same file.  */
+		if (change->value)
+		  goto invalid;
+		change->value = 00007;
+		change->flags |= MODE_COPY_EXISTING;
+		break;
+	      default:
+		goto no_more_values;
+	      }
+	no_more_values:;
+	}
+  } while (*mode_string == ',');
+  if (*mode_string == 0)
+    return head;
+invalid:
+  mode_free (head);
+  return MODE_INVALID;
+}
+
+/* Return file mode OLDMODE, adjusted as indicated by the list of change
+   operations CHANGES.  If OLDMODE is a directory, the type `X'
+   change affects it even if no execute bits were set in OLDMODE.
+   The returned value has the S_IFMT bits cleared. */
+
+STATIC unsigned short
+mode_adjust (oldmode, changes)
+     unsigned oldmode;
+     const struct mode_change *changes;
+{
+  unsigned short newmode;	/* The adjusted mode and one operand. */
+  unsigned short value;		/* The other operand. */
+
+  newmode = oldmode & 07777;
+
+  for (; changes; changes = changes->next)
+    {
+      if (changes->flags & MODE_COPY_EXISTING)
+	{
+	  /* Isolate in `value' the bits in `newmode' to copy, given in
+	     the mask `changes->value'. */
+	  value = newmode & changes->value;
+
+	  if (changes->value & 00700)
+	    /* Copy `u' permissions onto `g' and `o'. */
+	    value |= (value >> 3) | (value >> 6);
+	  else if (changes->value & 00070)
+	    /* Copy `g' permissions onto `u' and `o'. */
+	    value |= (value << 3) | (value >> 3);
+	  else
+	    /* Copy `o' permissions onto `u' and `g'. */
+	    value |= (value << 3) | (value << 6);
+
+	  /* In order to change only `u', `g', or `o' permissions,
+	     or some combination thereof, clear unselected bits.
+	     This can not be done in mode_compile because the value
+	     to which the `changes->affected' mask is applied depends
+	     on the old mode of each file. */
+	  value &= changes->affected;
+	}
+      else
+	{
+	  value = changes->value;
+	  /* If `X', do not affect the execute bits if the file is not a
+	     directory and no execute bits are already set. */
+	  if ((changes->flags & MODE_X_IF_ANY_X)
+	      && !S_ISDIR (oldmode)
+	      && (newmode & 00111) == 0)
+	    value &= ~00111;	/* Clear the execute bits. */
+	}
+
+      switch (changes->op)
+	{
+	case '=':
+	  /* Preserve the previous values in `newmode' of bits that are
+	     not affected by this change operation. */
+	  newmode = (newmode & ~changes->affected) | value;
+	  break;
+	case '+':
+	  newmode |= value;
+	  break;
+	case '-':
+	  newmode &= ~value;
+	  break;
+	}
+    }
+  return newmode;
+}
+
+/* Free the memory used by the list of file mode change operations
+   CHANGES. */
+
+STATIC void
+mode_free (changes)
+     register struct mode_change *changes;
+{
+  register struct mode_change *next;
+
+  while (changes)
+    {
+      next = changes->next;
+      free (changes);
+      changes = next;
+    }
+}
+
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/modechange.h Linux-PAM-0.77/modules/pam_console/modechange.h
--- Linux-PAM-0.77.orig/modules/pam_console/modechange.h	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/modechange.h	2000-01-03 20:08:44.000000000 +0200
@@ -0,0 +1,67 @@
+/* modechange.h -- definitions for file mode manipulation
+   Copyright (C) 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _MODECHANGE_H
+#define _MODECHANGE_H
+
+#ifndef STATIC
+#define STATIC
+#endif
+
+
+/* Masks for the `flags' field in a `struct mode_change'. */
+
+/* Affect the execute bits only if at least one execute bit is set already,
+   or if the file is a directory. */
+#define MODE_X_IF_ANY_X 01
+
+/* If set, copy some existing permissions for u, g, or o onto the other two.
+   Which of u, g, or o is copied is determined by which bits are set in the
+   `value' field. */
+#define MODE_COPY_EXISTING 02
+
+struct mode_change
+{
+  char op;			/* One of "=+-". */
+  char flags;			/* Special operations. */
+  unsigned short affected;	/* Set for u/g/o/s/s/t, if to be affected. */
+  unsigned short value;		/* Bits to add/remove. */
+  struct mode_change *next;	/* Link to next change in list. */
+};
+
+/* Masks for mode_compile argument. */
+#define MODE_MASK_EQUALS 1
+#define MODE_MASK_PLUS 2
+#define MODE_MASK_MINUS 4
+
+/* Error return values for mode_compile. */
+#define MODE_INVALID (struct mode_change *) 0
+#define MODE_MEMORY_EXHAUSTED (struct mode_change *) 1
+
+#ifndef __P
+# if defined (__GNUC__) || (defined (__STDC__) && __STDC__)
+#  define __P(Args) Args
+# else
+#  define __P(Args) ()
+# endif
+#endif
+
+STATIC struct mode_change *mode_compile __P ((const char *, unsigned));
+STATIC unsigned short mode_adjust __P ((unsigned, const struct mode_change *));
+STATIC void mode_free __P ((struct mode_change *));
+
+#endif /* _MODECHANGE_H */
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/pam_console.8 Linux-PAM-0.77/modules/pam_console/pam_console.8
--- Linux-PAM-0.77.orig/modules/pam_console/pam_console.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/pam_console.8	2001-10-04 02:29:48.000000000 +0300
@@ -0,0 +1,70 @@
+.\" Copyright 1999 Red Hat Software, Inc.
+.\" Written by Michael K. Johnson <johnsonm@redhat.com>
+.TH pam_console 8 2000/7/11 "Red Hat" "System Administrator's Manual"
+.SH NAME
+pam_console \- control permissions for users at the system console
+.SH SYNOPSIS
+.B session optional /lib/security/pam_console.so
+.br
+.B auth required /lib/security/pam_console.so
+.SH DESCRIPTION
+pam_console.so is designed to give users at the physical console
+(virtual terminals and local xdm-managed X sessions by default, but
+that is configurable) capabilities that they would not otherwise have,
+and to take those capabilities away when the are no longer logged in at
+the console.  It provides two main kinds of capabilities: file permissions
+and authentication.
+
+When a user logs in at the console and \fBno other user is currently
+logged in at the console\fP, pam_console.so will change permissions
+and ownership of files as described in the file /etc/security/console.perms.
+That user may then log in on other terminals that are considered part
+of the console, and as long as the user is still logged in at any one
+of those terminals, that user will own those devices.  When the user
+logs out of the last terminal, the console may be taken by the next
+user to log in.  Other users who have logged in at the console during
+the time that the first user was logged in will not be given ownership
+of the devices unless they log in on one of the terminals; having done
+so on any one terminal, the next user will own those devices until
+he or she has logged out of every terminal that is part of the physical
+console.  Then the race can start for the next user.  In practice, this
+is not a problem; the physical console is not generally in use by many
+people at the same time, and pam_console.so just tries to do the right
+thing in weird cases.
+.SH ARGUMENTS
+.IP debug
+turns on debugging
+.IP allow_nonroot_tty
+gain console locks and change permissions even if the TTY's owner is not root.
+.IP permsfile=\fIfilename\fP
+tells pam_console.so to get its permissions database from a different
+file than /etc/security/console.perms
+.IP fstab=\fIfilename\fP
+tells pam_console.so to read the table of configured filesystems from a
+file other than \fI/etc/fstab\fP when scanning \fIpermsfile\fP.  This file
+is used to map directories to device names.
+.\" .IP glob
+.\" \fBnot yet implemented\fP interpret strings as globs instead of
+.\" regexp expressions.
+.SH FILES
+\fI/var/run/console.lock\fP
+.br
+\fI/var/run/console/\fP
+.br
+\fI/etc/security/console.apps\fP
+.br
+\fI/etc/security/console.perms\fP
+.SH "SEE ALSO"
+.BR console.perms (5)
+.br
+.BR console.apps (5)
+.br
+\fI/usr/doc/pam*/html/index.html\fP
+.BR pam_console_apply (8)
+.br
+\fI/usr/doc/pam*/html/index.html\fP
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+.SH AUTHOR
+Michael K. Johnson <johnsonm@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/pam_console_apply.8 Linux-PAM-0.77/modules/pam_console/pam_console_apply.8
--- Linux-PAM-0.77.orig/modules/pam_console/pam_console_apply.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/pam_console_apply.8	2001-10-04 02:29:48.000000000 +0300
@@ -0,0 +1,35 @@
+.\" Copyright 2001 Red Hat, Inc.
+.TH pam_console_appy 8 2001/3/6 "Red Hat" "System Administrator's Manual"
+.SH NAME
+pam_console_apply \- set or revoke permissions for users at the system console
+.SH SYNOPSIS
+.B pam_console_apply [-r]
+.SH DESCRIPTION
+\fBpam_console_apply\fP sets or resets permissions on devices in the same
+manner as pam_console.
+.br
+If \fI/var/run/console.lock\fP exists, \fBpam_console_apply\fP will grant
+permissions to the user listed therein.  If the lock file does not exist,
+permissions are reset to those listed in \fI/etc/security/console.perms\fP,
+which should be configured to set permissions on devices so that \fBroot\fP
+owns them.
+.SH ARGUMENTS
+.IP -r
+Signals \fBpam_console_apply\fP to reset permissions.  The default is to set
+permissions so that the user listed in \fI/var/run/console.lock\fP has access
+to the devices, and to reset permissions if no such file exists.
+.SH FILES
+\fI/var/run/console.lock\fP
+.br
+\fI/etc/security/console.perms\fP
+.SH "SEE ALSO"
+.BR pam_console(8)
+.br
+.BR console.perms(5)
+.br
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>, using code shamelessly stolen from parts of
+pam_console.
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/pam_console_apply.c Linux-PAM-0.77/modules/pam_console/pam_console_apply.c
--- Linux-PAM-0.77.orig/modules/pam_console/pam_console_apply.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/pam_console_apply.c	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,116 @@
+/*
+ * Read in the file, and grant ownerships to whoever has the lock.
+ */
+
+#include "../../_pam_aconf.h"
+#include <errno.h>
+#include <glib.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#define STATIC static
+#include "pam_console.h"
+
+#include <security/_pam_macros.h>
+
+#define CAST_ME_HARDER (const void**)
+
+static char consolelock[PATH_MAX] = LOCKDIR ".lock";
+static char consoleperms[PATH_MAX] = "/etc/security/console.perms";
+static int debug = 0;
+
+static void *
+_do_malloc(size_t req)
+{
+	void *ret;
+	ret = malloc(req);
+	if (!ret) abort();
+	return ret;
+}
+
+static void
+_pam_log(int err, int debug_p, const char *format, ...)
+{
+	va_list args;
+	if (debug_p && !debug) return;
+        va_start(args, format);
+	fprintf(stderr, format, args);
+	va_end(args);
+}
+
+int
+main(int argc, char **argv)
+{
+	int fd;
+	int i, c;
+	struct stat st;
+	char *consoleuser = NULL;
+	enum {Set, Reset} sense = Set;
+
+	while((c = getopt(argc, argv, "c:f:r")) != -1) {
+		switch(c) {
+			case 'c': strncpy(consoleperms, optarg, sizeof(consoleperms) - 1);
+				  consoleperms[sizeof(consoleperms) - 1] = '\0';
+				  break;
+			case 'f': chmod_set_fstab(optarg);
+				  break;
+			case 'r':
+				  sense = Reset;
+				  break;
+			default:
+				  fprintf(stderr, "usage: %s [-f /etc/fstab] "
+					  "[-c %s] [-r]\n", argv[0],
+					  consoleperms);
+				  exit(1);
+		}
+	}
+
+	parse_file(consoleperms);
+        fd = open(consolelock, O_RDONLY);
+	if (fd != -1) {
+		if (fstat (fd, &st)) {
+			fprintf(stderr,
+			       "\"impossible\" fstat error on %s", consolelock);
+			goto return_error;
+		}
+		if (st.st_size) {
+			consoleuser = _do_malloc(st.st_size+1);
+			memset(consoleuser, '\0', st.st_size);
+			if ((i = read (fd, consoleuser, st.st_size)) == -1) {
+				fprintf(stderr,
+				       "\"impossible\" read error on %s",
+				       consolelock);
+				goto return_error;
+			}
+			consoleuser[i] = '\0';
+		}
+		close (fd);
+	} else {
+		sense = Reset;
+	}
+	if((sense == Set) && (consoleuser != NULL)) {
+		set_permissions(NULL, "tty0", consoleuser, TRUE);
+	}
+	if(sense == Reset) {
+		reset_permissions(NULL, "tty0", TRUE);
+	}
+	return 0;
+
+return_error:
+	return 1;
+}
+
+/* supporting functions included from other .c files... */
+
+#include "regerr.c"
+#include "chmod.c"
+#include "modechange.c"
+#include "config.lex.c"
+#include "config.tab.c"
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/pam_console.c Linux-PAM-0.77/modules/pam_console/pam_console.c
--- Linux-PAM-0.77.orig/modules/pam_console/pam_console.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/pam_console.c	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,493 @@
+/*
+ *
+ * /var/run/console.lock is the file used to control access to
+ * devices.  It is created when the first console user logs in,
+ * and that user has the control of the console until they have
+ * logged out of all concurrent login sessions.  That is,
+ * user A logs in on console 1 (gets access to console devices)
+ * user B logs in on console 2 (does not get access)
+ * user A logs in on console 3 (already has access)
+ * user A logs out of console 1 (still has access on console 3)
+ * user A logs out of console 3 (access revoked; user B does NOT get access)
+ * Note that all console users (both A and B in this situation)
+ * should be able to run console access programs (that is,
+ * pam_sm_authenticate() should return PAM_SUCCESS) even if
+ * console access to files/devices is not available to any one of
+ * the users (B in this case).
+ *
+ * /var/run/console/<username> is used for reference counting
+ * and to make console authentication easy -- if it exists, then
+ * <username> has console access.
+ *
+ * A system startup script should remove /var/run/console.lock
+ * and everything in /var/run/console/
+ */
+
+#include "../../_pam_aconf.h"
+#include <errno.h>
+#include <glib.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#define STATIC static
+#include "pam_console.h"
+
+#include <security/pam_modules.h>
+#include <security/_pam_macros.h>
+#include <security/_pam_modutil.h>
+
+/* In order to avoid errors in pam_get_item(), we need a very
+ * unfortunate cast.  This is a terrible design error in PAM
+ * that Linux-PAM slavishly follows.  :-(
+ */
+#define CAST_ME_HARDER (const void**)
+
+static char consolelock[PATH_MAX] = LOCKDIR ".lock";
+static char consolerefs[PATH_MAX] = LOCKDIR "/";
+static char consoleapps[PATH_MAX] = "/etc/security/console.apps/";
+static char consoleperms[PATH_MAX] = "/etc/security/console.perms";
+static int configfileparsed = 0;
+static int debug = 0;
+static int allow_nonroot_tty = 0;
+
+/* some syslogging */
+
+static void
+_pam_log(int err, int debug_p, const char *format, ...)
+{
+    va_list args;
+
+    if (debug_p && !debug) return;
+
+    va_start(args, format);
+    openlog("pam_console", LOG_CONS|LOG_PID, LOG_AUTHPRIV);
+    vsyslog(err, format, args);
+    va_end(args);
+    closelog();
+}
+
+static void *
+_do_malloc(size_t req)
+{
+  void *ret;
+
+  ret = malloc(req);
+  if (!ret) abort();
+  return ret;
+}
+
+static void
+_args_parse(int argc, const char **argv)
+{
+    for (; argc-- > 0; ++argv) {
+	if (!strcmp(*argv,"debug"))
+	    debug = 1;
+	else if (!strcmp(*argv,"allow_nonroot_tty"))
+	    allow_nonroot_tty = 1;
+	else if (!strncmp(*argv,"permsfile=",10))
+	    strcpy(consoleperms,*argv+10);
+	else if (!strncmp(*argv,"fstab=",6))
+	    chmod_set_fstab(*argv+6);
+	else {
+	    _pam_log(LOG_ERR, FALSE,
+		     "_args_parse: unknown option; %s",*argv);
+	}
+    }
+}
+
+static int
+is_root(pam_handle_t *pamh, const char *username) {
+    /* this should correspond to suser() in the kernel, since the
+     * whole point of this is to avoid doing unnecessary file ops
+     */
+    struct passwd *pwd;
+
+    pwd = _pammodutil_getpwnam(pamh, username);
+    if (pwd == NULL) {
+        _pam_log(LOG_ERR, FALSE, "getpwnam failed for %s", username);
+        return 0;
+    }
+    return !pwd->pw_uid;
+}
+
+static int
+lock_console(const char *id)
+{
+    int fd;
+
+    fd = open(consolelock, O_RDWR|O_CREAT|O_EXCL, 0600);
+    if (fd < 0) {
+	_pam_log(LOG_INFO, TRUE,
+		"console file lock already in place %s", consolelock);
+	return -1;
+    }
+    write (fd, id, strlen(id));
+    close (fd);
+    return 0;
+}
+
+/* warning, the following function uses goto for error recovery.
+ * If you can't stand goto, don't read this function.  :-P
+ */
+static int
+use_count(char *filename, int increment, int delete)
+{
+    int fd, err, val;
+    static int cache_fd = 0;
+    struct stat st;
+    struct flock lockinfo;
+    char *buf = NULL;
+
+    if (cache_fd) {
+	fd = cache_fd;
+	cache_fd = 0;
+	/* the cached fd is always already locked */
+    } else {
+top:
+	fd = open(filename, O_RDWR|O_CREAT, 0600);
+    	if (fd < 0) {
+	    _pam_log(LOG_ERR, FALSE,
+		    "Could not open lock file %s, disallowing console access",
+		    filename);
+	    return -1;
+	}
+
+	lockinfo.l_type = F_WRLCK;
+	lockinfo.l_whence = SEEK_SET;
+	lockinfo.l_start = 0;
+	lockinfo.l_len = 0;
+	alarm(20);
+	err = fcntl(fd, F_SETLKW, &lockinfo);
+	alarm(0);
+	if (err == EAGAIN) {
+	    /* if someone has locked the file and not written to it in
+	     * at least 20 seconds, we assume they either forgot to unlock
+	     * it or are catatonic -- chances are slim that they are in
+	     * the middle of a read-write cycle and I don't want to make
+	     * us lock users out.  Perhaps I should just return PAM_SUCCESS
+	     * instead and log the event?  Kill the process holding the
+	     * lock?  Options abound...  For now, we ignore it.
+	     */
+	    fcntl(fd, F_GETLK, &lockinfo);
+	    /* now lockinfo.l_pid == 0 implies that the lock was released
+	     * by the other process between returning from the 20 second
+	     * wait and calling fcntl again, not likely to ever happen, and
+	     * not a problem other than cosmetics even if it does.
+	     */
+	    _pam_log(LOG_ERR, FALSE,
+		    "ignoring stale lock on file %s by process %d",
+		    lockinfo.l_pid, filename);
+	}
+
+	/* it is possible at this point that the file has been removed
+	 * by a previous login; if this happens, we need to start over.
+	 * Unfortunately, the only way to do this without potential stack
+	 * trashing is a goto.
+	 */
+	if (access (filename, F_OK) < 0) {
+	    close (fd);
+	    goto top;
+	}
+    }
+
+
+    if (fstat (fd, &st)) {
+	_pam_log(LOG_ERR, FALSE,
+		"\"impossible\" fstat error on open fd for %s", filename);
+	err = -1; goto return_error;
+    }
+    buf = _do_malloc(st.st_size+2); /* size will never grow by more than one */
+    if (st.st_size) {
+	if (read (fd, buf, st.st_size) == -1) {
+	    _pam_log(LOG_ERR, FALSE,
+		    "\"impossible\" read error on %s", filename);
+	    err = -1; goto return_error;
+	}
+	if (lseek(fd, 0, SEEK_SET) == -1) {
+	    _pam_log(LOG_ERR, FALSE,
+		    "\"impossible\" lseek error on %s", filename);
+	    err = -1; goto return_error;
+	}
+	buf[st.st_size] = '\0';
+        val = atoi(buf);
+    } else {
+	val = 0;
+    }
+
+    if (increment) { /* increment == 0 implies query */
+	val += increment;
+	if (val <= 0 && delete) {
+	    if (unlink (filename)) {
+		_pam_log(LOG_ERR, FALSE,
+			"\"impossible\" unlink error on %s", filename);
+		err = -1; goto return_error;
+	    }
+	    err = 0; goto return_error;
+	}
+
+	sprintf(buf, "%d", val);
+	if (write(fd, buf, strlen(buf)) == -1) {
+	    _pam_log(LOG_ERR, FALSE,
+		    "\"impossible\" write error on %s", filename);
+	    err = -1; goto return_error;
+	}
+    }
+
+    err = val;
+
+    if (!increment) {
+	cache_fd = fd;
+    } else {
+return_error:
+	close (fd);
+    }
+    if (buf) free (buf);
+    return err;
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+  /* getuid() must return an id that maps to a username as a filename in
+   * /var/run/console/
+   * and the service name must be listed in
+   * /etc/security/console-apps
+   */
+    struct passwd *pwd;
+    char *lockfile = NULL;
+    char *appsfile = NULL;
+    char *service;
+    int ret = PAM_AUTH_ERR;
+
+    D(("called."));
+    _args_parse(argc, argv);
+
+    /* FIXME: this appears to be unnecessary, since I always see pam_rootok
+     * listed before this module -- remove if not explicitly required by the
+     * pam_console white paper */
+    if (getuid() == 0) return PAM_SUCCESS; /* root always trivially succeeds */
+
+    pwd = _pammodutil_getpwuid(pamh, getuid());
+    if (pwd == NULL) {
+	_pam_log(LOG_ERR, FALSE, "user with id %d not found", getuid());
+	return PAM_AUTH_ERR;
+    }
+
+    lockfile = _do_malloc(strlen(consolerefs) + strlen(pwd->pw_name) + 2);
+    sprintf(lockfile, "%s%s", consolerefs, pwd->pw_name); /* trusted data */
+
+    pam_get_item(pamh, PAM_SERVICE, CAST_ME_HARDER &service);
+    appsfile = _do_malloc(strlen(consoleapps) + strlen(service) + 2);
+    sprintf(appsfile, "%s%s", consoleapps, service); /* trusted data */
+
+    if (access(lockfile, F_OK) < 0) {
+	_pam_log(LOG_ERR, TRUE,
+		 "user %s not a console user", pwd->pw_name);
+	ret = PAM_AUTH_ERR; goto error_return;
+    }
+
+    if (access(appsfile, F_OK) < 0) {
+	_pam_log(LOG_ERR, TRUE,
+		 "console access disallowed for service %s", service);
+	ret = PAM_AUTH_ERR; goto error_return;
+    }
+
+    /* all checks OK, must be OK */
+    ret = PAM_SUCCESS;
+
+error_return:
+    if (lockfile) free (lockfile);
+    if (appsfile) free (appsfile);
+    return ret;
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+    return PAM_SUCCESS;
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+  /* Create /var/run/console.lock if it does not exist
+   * Create /var/run/console/<username> if it does not exist
+   * Increment its use count
+   * Change file ownerships and permissions as given in
+   * /etc/security/console.perms IFF returned use count was 0
+   * and we created /var/run/console.lock
+   */
+    int got_console = 0;
+    int count = 0;
+    int ret = PAM_SESSION_ERR;
+    const char *username;
+    char *lockfile;
+    char *tty;
+
+    D(("called."));
+    _pam_log(LOG_ERR, TRUE, "pam_console open_session");
+    _args_parse(argc, argv);
+    pam_get_item(pamh, PAM_USER, (const void**) &username);
+    _pam_log(LOG_DEBUG, TRUE, "user is \"%s\"",
+	     username ? username : "(null)");
+    if (!username || !username[0]) {
+        _pam_log(LOG_DEBUG, TRUE, "user is \"%s\"",
+	         username ? username : "(null)");
+	return PAM_SESSION_ERR;
+    }
+    if (is_root(pamh, username)) {
+        _pam_log(LOG_DEBUG, TRUE, "user \"%s\" is root", username);
+	return PAM_SUCCESS;
+    }
+    pam_get_item(pamh, PAM_TTY, CAST_ME_HARDER &tty);
+    if (!tty || !tty[0]) {
+        _pam_log(LOG_ERR, TRUE, "TTY not defined");
+	return PAM_SESSION_ERR;
+    }
+
+    /* get configuration */
+    if (!configfileparsed) { parse_file(consoleperms); configfileparsed = 1; }
+
+    /* return success quietly if not a terminal login */
+    if (!check_console_name(tty, allow_nonroot_tty)) return PAM_SUCCESS;
+
+    if (!lock_console(username)) got_console = 1;
+
+    lockfile = _do_malloc(strlen(consolerefs) + strlen(username) + 2);
+    sprintf(lockfile, "%s%s", consolerefs, username); /* trusted data */
+    count = use_count(lockfile , 1, 0);
+    if (count < 0) ret = PAM_SESSION_ERR;
+
+    if (got_console) {
+	_pam_log(LOG_DEBUG, TRUE, "%s is console user", username);
+	/* woohoo!  We got here first, grab ownership and perms... */
+	set_permissions(pamh, tty, username, allow_nonroot_tty);
+	/* errors will be logged and are not critical */
+        ret = PAM_SUCCESS;
+    }
+
+    free(lockfile);
+    return ret;
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+  /* Get /var/run/console/<username> use count, leave it locked
+   * If use count is now 1:
+   *   If /var/run/console.lock contains <username>"
+   *     Revert file ownerships and permissions as given in
+   *     /etc/security/console.perms
+   * Decrement /var/run/console/<username>, removing both it and
+   *   /var/run/console.lock if 0, unlocking /var/run/console/<username>
+   *   in any case.
+   */
+    int fd;
+    int count = 0;
+    int err;
+    int delete_consolelock = 0;
+    const char *username = NULL;
+    char *lockfile = NULL;
+    char *consoleuser = NULL;
+    char *tty;
+    struct stat st;
+
+    D(("called."));
+    _args_parse(argc, argv);
+    pam_get_item(pamh, PAM_USER, (const void **) &username);
+
+    if (!username || !username[0]) return PAM_SESSION_ERR;
+    if (is_root(pamh, username)) return PAM_SUCCESS;
+    pam_get_item(pamh, PAM_TTY, CAST_ME_HARDER &tty);
+    if (!tty || !tty[0]) return PAM_SESSION_ERR;
+
+    /* get configuration */
+    if (!configfileparsed) { parse_file(consoleperms); configfileparsed = 1; }
+
+    /* return success quietly if not a terminal login */
+    if (!check_console_name(tty, allow_nonroot_tty)) return PAM_SUCCESS;
+
+    lockfile = _do_malloc(strlen(consolerefs) + strlen(username) + 2);
+    sprintf(lockfile, "%s%s", consolerefs, username); /* trusted data */
+    count = use_count(lockfile, 0, 0);
+    if (count < 0) {
+	err = PAM_SESSION_ERR; goto return_error;
+    }
+
+    if (count == 1) {
+	fd = open(consolelock, O_RDONLY);
+	if (fd != -1) {
+	    if (fstat (fd, &st)) {
+		_pam_log(LOG_ERR, FALSE,
+			"\"impossible\" fstat error on %s", consolelock);
+		err = PAM_SESSION_ERR; goto return_error;
+	    }
+	    consoleuser = _do_malloc(st.st_size+1);
+	    if (st.st_size) {
+		if (read (fd, consoleuser, st.st_size) == -1) {
+		    _pam_log(LOG_ERR, FALSE,
+			    "\"impossible\" read error on %s", consolelock);
+		    err = PAM_SESSION_ERR; goto return_error;
+		}
+		consoleuser[st.st_size] = '\0';
+	    }
+	    close (fd);
+
+	    if (!strcmp(username, consoleuser)) {
+		delete_consolelock = 1;
+		reset_permissions(pamh, tty, allow_nonroot_tty);
+		/* errors will be logged and at this stage we cannot do
+		 * anything about them...
+		 */
+	    }
+	}
+    }
+
+    count = use_count(lockfile, -1, 1);
+    if (count < 1 && delete_consolelock) {
+	if (unlink(consolelock)) {
+	    _pam_log(LOG_ERR, FALSE,
+		     "\"impossible\" unlink error on %s", consolelock);
+	    err = PAM_SESSION_ERR; goto return_error;
+	}
+    }
+
+    err = PAM_SUCCESS;
+return_error:
+    if (lockfile) free(lockfile);
+    if (consoleuser) free (consoleuser);
+    return err;
+}
+
+#ifdef PAM_STATIC
+
+/* static module data */
+
+struct pam_module _pam_console_modstruct = {
+    "pam_console",
+    pam_sm_authenticate,
+    pam_sm_setcred,
+    NULL,
+    pam_sm_open_session,
+    pam_sm_close_session,
+    NULL,
+};
+
+#endif
+
+/* end of module definition */
+
+/* supporting functions included from other .c files... */
+
+#include "regerr.c"
+#include "chmod.c"
+#include "modechange.c"
+#include "config.lex.c"
+#include "config.tab.c"
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/pam_console.h Linux-PAM-0.77/modules/pam_console/pam_console.h
--- Linux-PAM-0.77.orig/modules/pam_console/pam_console.h	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/pam_console.h	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,46 @@
+/* Copyright 1999 Red Hat Software, Inc.
+ * This software may be used under the terms of the GNU General Public
+ * License, available in the file COPYING accompanying this file
+ */
+#ifndef _PAM_CONSOLE_H
+#define _PAM_CONSOLE_H
+#include <glib.h>
+#include <security/pam_modules.h>
+#include "chmod.h"
+
+typedef struct class_s class;
+struct class_s {
+	char*	name;
+	GSList*	list;
+};
+
+typedef struct config_s config;
+struct config_s {
+	class*	console_class;
+	char*	mode;
+	class*	device_class;
+	char*	revert_mode;
+	char*	revert_owner;
+	char*	revert_group;
+};
+
+/* pam_console.c */
+
+static void
+_pam_log(int err, int debug_p, const char *format, ...);
+
+/* config.y */
+
+STATIC void
+parse_file(char *name);
+
+STATIC int
+check_console_name (const char *consolename, int allow_nonroot);
+
+STATIC int
+set_permissions(pam_handle_t *pamh, const char *consolename, const char *username, int allow_nonroot);
+
+STATIC int
+reset_permissions(pam_handle_t *pamh, const char *consolename, int allow_nonroot);
+
+#endif /* _PAM_CONSOLE_H */
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/README Linux-PAM-0.77/modules/pam_console/README
--- Linux-PAM-0.77.orig/modules/pam_console/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/README	2000-01-03 20:08:44.000000000 +0200
@@ -0,0 +1,38 @@
+README for pam_console
+======================
+
+NOTE: This software is very powerful.  Incautious use could leave your
+system open to attack, or difficult to use.
+
+pam_console is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+Because pam_console integrates GPL-licensed code, all of pam_console
+is licensed only under the GPL, unlike most PAM modules.  See the
+file COPYING for the license terms under which this software is
+licensed.
+
+(If this software breaks your system, you get to keep all the pieces.)
+
+The pam_console module exists to change file permissions when users
+log on at the console, and to change them back when they log out of
+the console.  It also cooperates with the pam_listfile module to
+make it possible to allow users who are at the console to run
+various programs that would otherwise be restricted to root only.
+
+The pam_console.8 man page explains this software in more detail.
+
+Please note: the current version depends on too many external tools
+and libraries, making it big and hard to evaluate for security.
+This is only a bootstrap stage; I'll be fixing it later.  I'm using
+lex/yacc right now so that it is trivial to change the grammar, and
+I'm using glib because I didn't want to write my own hashtables
+while I was busy thinking about file locking.  Don't report those
+as bugs, I'll fix them later once I've ironed out the important
+details...
+
+Michael K. Johnson
+Red Hat Software, Inc.
+
+Copyright 1999 Red Hat Software, Inc.
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/regerr.c Linux-PAM-0.77/modules/pam_console/regerr.c
--- Linux-PAM-0.77.orig/modules/pam_console/regerr.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/regerr.c	2001-10-12 01:02:55.000000000 +0300
@@ -0,0 +1,29 @@
+/* Copyright 1999 Red Hat Software, Inc.
+ * This software may be used under the terms of the GNU General Public
+ * License, available in the file COPYING accompanying this file
+ */
+#include "../../_pam_aconf.h"
+#include <sys/types.h>
+#include <regex.h>
+#include "pam_console.h"
+
+#ifndef STATIC
+#define STATIC
+#endif
+
+STATIC void
+do_regerror(int errcode, const regex_t *preg) {
+    char *errbuf;
+    size_t errbuf_size;
+
+    errbuf_size = regerror(errcode, preg, NULL, 0); /* missing ; */
+    errbuf = alloca(errbuf_size);
+    if(!errbuf) {
+	perror("alloca");
+	return;
+    }
+
+    regerror(errcode, preg, errbuf, errbuf_size);
+    _pam_log(LOG_ERR, 0,
+	     "regular expression error %s", errbuf);
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_console/sed-static Linux-PAM-0.77/modules/pam_console/sed-static
--- Linux-PAM-0.77.orig/modules/pam_console/sed-static	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_console/sed-static	2000-01-03 20:08:44.000000000 +0200
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+[ -n "$1" ] || { echo $0: 'sed what file?' 1>&2 ; exit 1 ; }
+
+sed '
+/^YY_BUFFER_STATE yy_create_buffer/s/^/STATIC /
+/^void yy_delete_buffer/s/^/STATIC /
+/^void yy_flush_buffer/s/^/STATIC /
+/^void yy_init_buffer/s/^/STATIC /
+/^void yy_load_buffer_state/s/^/STATIC /
+/^void YY_BUFFER_STATE yy_scan_buffer/s/^/STATIC /
+/^YY_BUFFER_STATE yy_scan_bytes/s/^/STATIC /
+/^YY_BUFFER_STATE yy_scan_buffer/s/^/STATIC /
+/^YY_BUFFER_STATE yy_scan_string/s/^/STATIC /
+/^void yy_switch_to_buffer/s/^/STATIC /
+/define YY_DECL int yylex/s/YY_DECL /YY_DECL STATIC /
+/^int$/s/^/STATIC /
+/^void yyrestart/s/^/STATIC /
+' < $1 > sedtmp.$$ && mv sedtmp.$$ $1
diff -Nur Linux-PAM-0.77.orig/modules/pam_localuser/Makefile Linux-PAM-0.77/modules/pam_localuser/Makefile
--- Linux-PAM-0.77.orig/modules/pam_localuser/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_localuser/Makefile	2001-01-05 02:14:42.000000000 +0200
@@ -0,0 +1,14 @@
+# $Id: Makefile,v 1.3 2001/01/05 00:14:42 nalin Exp $
+#
+# This Makefile controls a build process of $(TITLE) module for
+# Linux-PAM. You should not modify this Makefile (unless you know
+# what you are doing!).
+#
+#
+
+include ../../Make.Rules
+
+TITLE=pam_localuser
+MAN8=pam_localuser.8
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_localuser/pam_localuser.8 Linux-PAM-0.77/modules/pam_localuser/pam_localuser.8
--- Linux-PAM-0.77.orig/modules/pam_localuser/pam_localuser.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_localuser/pam_localuser.8	2001-10-04 02:29:48.000000000 +0300
@@ -0,0 +1,36 @@
+.\" Copyright 2000 Red Hat, Inc.
+.TH pam_localuser 8 2000/7/21 "Red Hat" "System Administrator's Manual"
+
+.SH NAME
+pam_localuser \- require users to be listed in /etc/passwd
+
+.SH SYNOPSIS
+.B account sufficient /lib/security/pam_localuser.so \fIargs\fP
+.br
+.B account required /lib/security/pam_wheel.so group=devel
+
+.SH DESCRIPTION
+pam_localuser.so exists to help implement site-wide login policies, where
+they typically include a subset of the network's users and a few accounts
+that are local to a particular workstation.  Using pam_localuser.so and
+pam_wheel.so or pam_listfile.so is an effective way to restrict access to
+either local users and/or a subset of the network's users.
+
+This could also be implemented using pam_listfile.so and a very short awk
+script invoked by cron, but it's common enough to have been separated out.
+
+.SH ARGUMENTS
+.IP debug
+turns on debugging
+.IP file=\fBFILE\fP
+uses a file other than \fB/etc/passwd\fP.
+
+.SH FILES
+/etc/passwd
+
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_localuser/pam_localuser.c Linux-PAM-0.77/modules/pam_localuser/pam_localuser.c
--- Linux-PAM-0.77.orig/modules/pam_localuser/pam_localuser.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_localuser/pam_localuser.c	2002-04-18 18:27:10.000000000 +0300
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2001 Red Hat, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../../_pam_aconf.h"
+
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#define PAM_SM_AUTH
+#define PAM_SM_ACCOUNT
+#include "../../libpam/include/security/pam_modules.h"
+#include "../../libpam/include/security/_pam_macros.h"
+
+#define MODULE_NAME "pam_localuser"
+
+PAM_EXTERN
+int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	int i, ret = PAM_SUCCESS;
+	FILE *fp;
+	int debug = 0;
+	char filename[PATH_MAX] = "/etc/passwd";
+	char line[LINE_MAX], name[LINE_MAX];
+	const char* user;
+
+	/* process arguments */
+	for(i = 0; i < argc; i++) {
+		if(strcmp("debug", argv[i]) == 0) {
+			debug = 1;
+		}
+	}
+	for(i = 0; i < argc; i++) {
+		if(strncmp("file=", argv[i], 5) == 0) {
+			strncpy(filename, argv[i] + 5, sizeof(filename) - 1);
+			filename[sizeof(filename) - 1] = '\0';
+			if(debug) {
+				openlog(MODULE_NAME, LOG_PID, LOG_AUTHPRIV);
+				syslog(LOG_DEBUG, "set filename to \"%s\"",
+				       filename);
+				closelog();
+			}
+		}
+	}
+
+	/* open the file */
+	fp = fopen(filename, "r");
+	if(fp == NULL) {
+		openlog(MODULE_NAME, LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_ERR, "error opening \"%s\": %s", filename,
+		       strerror(errno));
+		closelog();
+		return PAM_SYSTEM_ERR;
+	}
+
+	if(pam_get_item(pamh, PAM_USER, (const void**) &user) != PAM_SUCCESS) {
+		openlog(MODULE_NAME, LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_ERR, "user name not specified yet");
+		closelog();
+		return PAM_SYSTEM_ERR;
+	}
+
+	/* scan the file, using fgets() instead of fgetpwent() because i
+	 * don't want to mess with applications which call fgetpwent() */
+	ret = PAM_PERM_DENIED;
+	snprintf(name, sizeof(name), "%s:", user);
+	i = strlen(name);
+	while(fgets(line, sizeof(line), fp) != NULL) {
+		if(debug) {
+			openlog(MODULE_NAME, LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "checking \"%s\"", line);
+			closelog();
+		}
+		if(strncmp(name, line, i) == 0) {
+			ret = PAM_SUCCESS;
+			break;
+		}
+	}
+
+	/* okay, we're done */	
+	fclose(fp);
+	return ret;
+}
+
+PAM_EXTERN
+int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return PAM_SUCCESS;
+}
+
+PAM_EXTERN
+int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return pam_sm_authenticate(pamh, flags, argc, argv);
+}
+
+#ifdef PAM_STATIC
+
+/* static module data */
+
+struct pam_module _pam_localuser_modstruct = {
+     "pam_localuser",
+     pam_sm_authenticate,
+     pam_sm_setcred,
+     pam_sm_acct_mgmt,
+     NULL,
+     NULL,
+     NULL,
+};
+
+#endif
diff -Nur Linux-PAM-0.77.orig/modules/pam_localuser/README Linux-PAM-0.77/modules/pam_localuser/README
--- Linux-PAM-0.77.orig/modules/pam_localuser/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_localuser/README	2000-07-21 17:37:13.000000000 +0300
@@ -0,0 +1,17 @@
+pam_localuser:
+	Succeeds iff the PAM_USER is listed in /etc/passwd.  This seems to be a
+	common policy need (allowing only a subset of network-wide users, and
+	any locally-defined users, to access services).  Simpler than using
+	awk to generate a file for use with pam_listfile (-F: '{print $1}'),
+	I guess.
+
+RECOGNIZED ARGUMENTS:
+	debug		write debugging messages to syslog
+	passwd=FILE	scan FILE instead of /etc/passwd
+
+MODULE SERVICES PROVIDED:
+	auth,account	scan the FILE (/etc/passwd by default) and return
+			a success code if an entry is found for the user
+
+AUTHOR:
+	Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_postgresok/Makefile Linux-PAM-0.77/modules/pam_postgresok/Makefile
--- Linux-PAM-0.77.orig/modules/pam_postgresok/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_postgresok/Makefile	2003-07-24 22:21:50.000000000 +0300
@@ -0,0 +1,16 @@
+#
+# $Id: Makefile,v 1.1 2003/07/24 19:21:50 nalin Exp $
+#
+# This Makefile controls a build process of $(TITLE) module for
+# Linux-PAM. You should not modify this Makefile (unless you know
+# what you are doing!).
+#
+# Created by Andrew Morgan <morgan@linux.kernel.org> 2000/08/27
+#
+
+include ../../Make.Rules
+
+TITLE=pam_postgresok
+MAN8=$(TITLE).8
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_postgresok/pam_postgresok.8 Linux-PAM-0.77/modules/pam_postgresok/pam_postgresok.8
--- Linux-PAM-0.77.orig/modules/pam_postgresok/pam_postgresok.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_postgresok/pam_postgresok.8	2003-07-24 22:21:50.000000000 +0300
@@ -0,0 +1,28 @@
+.\" Copyright 2003 Red Hat, Inc.
+.\" Module written by Fernando Nasser <fnasser@redhat.com>
+.TH pam_postgresok 8 2003/7/24 "Red Hat Linux" "System Administrator's Manual"
+
+.SH NAME
+pam_postgresok \- simple check of real UID and corresponding account name
+
+.SH SYNOPSIS
+.B auth sufficient pam_postgresok.so
+
+.SH DESCRIPTION
+pam_postgresok.so is designed to check that the real UID of the calling
+process belongs to the "postgres" user and equal to 26 (the value assigned
+to that user on Red Hat Linux systems).
+
+.SH ARGUMENTS
+.IP debug
+Enable module debugging.  The module will log its progress to syslog.
+
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+
+.SH FILES
+/usr/share/doc/setup-*/uidgid
+
+.SH AUTHOR
+Fernando Nasser <fnasser@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_postgresok/pam_postgresok.c Linux-PAM-0.77/modules/pam_postgresok/pam_postgresok.c
--- Linux-PAM-0.77.orig/modules/pam_postgresok/pam_postgresok.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_postgresok/pam_postgresok.c	2003-07-24 22:29:08.000000000 +0300
@@ -0,0 +1,119 @@
+/* pam_postgresok module */
+
+/*
+ * Written by Fernando Nasser <fnasser@redhat.com> 2003/4/28
+ * Based on the pam_rootok module
+ * written by Andrew Morgan <morgan@linux.kernel.org> 1996/3/11
+ */
+
+#define _GNU_SOURCE
+
+#include "../../_pam_aconf.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <stdarg.h>
+#include <string.h>
+#include <pwd.h>
+
+/*
+ * here, we make a definition for the externally accessible function
+ * in this file (this definition is required for static a module
+ * but strongly encouraged generally) it is used to instruct the
+ * modules include file to define the function prototypes.
+ */
+
+#define PAM_SM_AUTH
+
+#include <security/pam_modules.h>
+#include <security/_pam_modutil.h>
+
+/* some syslogging */
+
+static void _pam_log(int err, const char *format, ...)
+{
+    va_list args;
+
+    va_start(args, format);
+    openlog("PAM-postgresok", LOG_CONS|LOG_PID, LOG_AUTHPRIV);
+    vsyslog(err, format, args);
+    va_end(args);
+    closelog();
+}
+
+
+/* argument parsing */
+
+#define PAM_DEBUG_ARG       01
+
+static int _pam_parse(int argc, const char **argv)
+{
+    int ctrl=0;
+
+    /* step through arguments */
+    for (ctrl=0; argc-- > 0; ++argv) {
+
+	/* generic options */
+
+	if (!strcmp(*argv,"debug"))
+	    ctrl |= PAM_DEBUG_ARG;
+	else {
+	    _pam_log(LOG_ERR,"pam_parse: unknown option; %s",*argv);
+	}
+    }
+
+    return ctrl;
+}
+
+/* --- authentication management functions (only) --- */
+
+PAM_EXTERN
+int pam_sm_authenticate(pam_handle_t *pamh,int flags,int argc
+			,const char **argv)
+{
+    uid_t uid;
+    struct passwd *pw;
+    int ctrl;
+    int retval = PAM_AUTH_ERR;
+
+    ctrl = _pam_parse(argc, argv);
+
+    uid = getuid();
+    pw = _pammodutil_getpwuid(pamh, uid);
+
+    if ((uid == 26) && (pw != NULL) && (strcmp(pw->pw_name, "postgres") == 0))
+	retval = PAM_SUCCESS;
+
+    if (ctrl & PAM_DEBUG_ARG) {
+	_pam_log(LOG_DEBUG, "authentication %s"
+		 , retval==PAM_SUCCESS ? "succeeded":"failed" );
+    }
+
+    return retval;
+}
+
+PAM_EXTERN
+int pam_sm_setcred(pam_handle_t *pamh,int flags,int argc
+		   ,const char **argv)
+{
+    return PAM_SUCCESS;
+}
+
+
+#ifdef PAM_STATIC
+
+/* static module data */
+
+struct pam_module _pam_postgresok_modstruct = {
+    "pam_postgresok",
+    pam_sm_authenticate,
+    pam_sm_setcred,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+};
+
+#endif
+
+/* end of module definition */
diff -Nur Linux-PAM-0.77.orig/modules/pam_postgresok/README Linux-PAM-0.77/modules/pam_postgresok/README
--- Linux-PAM-0.77.orig/modules/pam_postgresok/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_postgresok/README	2003-07-24 22:21:50.000000000 +0300
@@ -0,0 +1,13 @@
+pam_postgresok:
+	Similar to pam_rootok, this module checks that the current real
+	user ID is 26 (per /usr/share/doc/setup-*/uidgid on Red Hat
+	Linux) and belongs to a user named "postgres".
+
+RECOGNIZED ARGUMENTS:
+	debug		write debugging messages to syslog
+
+MODULE SERVICES PROVIDED:
+	authentication
+
+AUTHOR:
+	Fernando Nasser <fnasser@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_rps/Makefile Linux-PAM-0.77/modules/pam_rps/Makefile
--- Linux-PAM-0.77.orig/modules/pam_rps/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_rps/Makefile	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,16 @@
+#
+# $Id: Makefile,v 1.2 2003/07/08 03:16:28 nalin Exp $
+#
+# This Makefile controls a build process of $(TITLE) module for
+# Linux-PAM. You should not modify this Makefile (unless you know
+# what you are doing!).
+#
+# Created by Andrew Morgan <morgan@linux.kernel.org> 2000/08/27
+#
+
+include ../../Make.Rules
+
+TITLE=pam_rps
+MAN8=$(TITLE).8
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_rps/pam_rps.8 Linux-PAM-0.77/modules/pam_rps/pam_rps.8
--- Linux-PAM-0.77.orig/modules/pam_rps/pam_rps.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_rps/pam_rps.8	2003-07-08 07:02:01.000000000 +0300
@@ -0,0 +1,35 @@
+.\" Copyright 2003 Red Hat, Inc.
+.\" Written by Nalin Dahyabhai <nalin@redhat.com>
+.TH pam_rps 8 2003/6/30 "Red Hat Linux" "System Administrator's Manual"
+
+.SH NAME
+pam_rps \- challenge-response authentication
+
+.SH SYNOPSIS
+.B auth sufficient pam_rps.so
+
+.SH DESCRIPTION
+pam_rps.so is designed to provide a true challenge-response authentication
+mechanism for PAM-enabled applications.
+
+Without pam_rps, successful authentication can only occur for a user if the
+user has previously established an authentication token for use with the
+server.  Using pam_rps removes this limitation.
+
+.SH ARGUMENTS
+.IP debug
+Enable module debugging.  The module will log its progress to syslog.
+.IP throw=\fInumber\fP
+The challenge issued to the user is derived from a random number.  This
+argument allows the administrator to control which challenge will be presented
+to the user.  This argument is meant for use only when debugging.
+
+.SH NOTES
+Never use this module.
+
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_rps/pam_rps.c Linux-PAM-0.77/modules/pam_rps/pam_rps.c
--- Linux-PAM-0.77.orig/modules/pam_rps/pam_rps.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_rps/pam_rps.c	2003-06-25 22:30:12.000000000 +0300
@@ -0,0 +1,154 @@
+/******************************************************************************
+ * A truly challenge-response module for PAM.
+ *
+ * Copyright (c) 2003 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <sys/types.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <security/pam_modules.h>
+
+#define MODULE_PREFIX "pam_rps: "
+
+int
+pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	const char *values[] = {
+		"\x72\x6f\x63\x6b",
+		"\x70\x61\x70\x65\x72",
+		"\x73\x63\x69\x73\x73\x6f\x72\x73"};
+	char prompt_text[32] = "";
+	const char *want = "";
+	const struct pam_message message = {
+		PAM_PROMPT_ECHO_OFF,
+		prompt_text,
+	};
+	const struct pam_message *messages[] = {
+		&message,
+	};
+	struct pam_response *responses = NULL;
+
+	int debug = 0;
+
+	struct pam_conv *conv;
+	int ret, fd, r, i;
+	unsigned char c;
+
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug = 1;
+			break;
+		}
+	}
+
+	ret = pam_get_item(pamh, PAM_CONV, (const void **) &conv);
+	if (ret != PAM_SUCCESS) {
+		syslog(LOG_AUTHPRIV | LOG_CRIT,
+		       MODULE_PREFIX "error determining user name");
+		return ret;
+	}
+	if ((conv == NULL) || (conv->conv == NULL)) {
+		syslog(LOG_AUTHPRIV | LOG_CRIT,
+		       MODULE_PREFIX "conversation error");
+		return PAM_CONV_ERR;
+	}
+
+	r = -1;
+	for (i = 0; i < argc; i++) {
+		if (strncmp(argv[i], "throw=", 6) == 0) {
+			r = atol(argv[i] + 6) % 3;
+			break;
+		}
+	}
+	if (r == -1) {
+		r = 0;
+		fd = open("/dev/urandom", O_RDONLY);
+		if (fd != -1) {
+			c = 0;
+			do {
+				ret = read(fd, &c, 1);
+			} while ((ret == 1) && (c == 0xff));
+			/* We drop 0xff here to avoid a variation on
+			 * Bleichenbacher's attack. */
+			r = c / 85;
+			close(fd);
+		}
+	}
+	switch (r) {
+	case 0:
+		strcpy(prompt_text, values[0]);
+		want = values[1];
+		break;
+	case 1:
+		strcpy(prompt_text, values[1]);
+		want = values[2];
+		break;
+	case 2:
+		strcpy(prompt_text, values[2]);
+		want = values[0];
+		break;
+	}
+	if (debug) {
+		syslog(LOG_AUTHPRIV | LOG_DEBUG, "challenge is \"%s\", "
+		       "expected response is \"%s\"", prompt_text, want);
+	}
+	strcat(prompt_text, ": ");
+	ret = conv->conv(1, messages, &responses, conv->appdata_ptr);
+	if (ret != PAM_SUCCESS) {
+		syslog(LOG_AUTHPRIV | LOG_CRIT,
+		       MODULE_PREFIX "conversation error");
+		return PAM_CONV_ERR;
+	}
+	if ((responses != NULL) &&
+	    (responses[0].resp_retcode == 0) &&
+	    (responses[0].resp != NULL) &&
+	    (strcasecmp(responses[0].resp, want) == 0)) {
+		ret = PAM_SUCCESS;
+	} else {
+		ret = PAM_AUTH_ERR;
+	}
+	return ret;
+}
+
+int
+pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return PAM_SUCCESS;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_rps/README Linux-PAM-0.77/modules/pam_rps/README
--- Linux-PAM-0.77.orig/modules/pam_rps/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_rps/README	2003-07-08 07:02:01.000000000 +0300
@@ -0,0 +1,12 @@
+pam_rps:
+	A primitive challenge-response authentication module.
+
+RECOGNIZED ARGUMENTS:
+	debug		write debugging messages to syslog
+	throw=		control the challenge issued
+
+MODULE SERVICES PROVIDED:
+	authentication
+
+AUTHOR:
+	Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_stack/COPYING Linux-PAM-0.77/modules/pam_stack/COPYING
--- Linux-PAM-0.77.orig/modules/pam_stack/COPYING	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_stack/COPYING	2000-03-20 21:39:50.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Nur Linux-PAM-0.77.orig/modules/pam_stack/Makefile Linux-PAM-0.77/modules/pam_stack/Makefile
--- Linux-PAM-0.77.orig/modules/pam_stack/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_stack/Makefile	2001-01-05 02:14:42.000000000 +0200
@@ -0,0 +1,10 @@
+#
+# $Id: Makefile,v 1.6 2001/01/05 00:14:42 nalin Exp $
+#
+
+include ../../Make.Rules
+
+TITLE=pam_stack
+MAN8=pam_stack.8
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_stack/pam_stack.8 Linux-PAM-0.77/modules/pam_stack/pam_stack.8
--- Linux-PAM-0.77.orig/modules/pam_stack/pam_stack.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_stack/pam_stack.8	2001-01-30 10:04:56.000000000 +0200
@@ -0,0 +1,48 @@
+.TH pam_stack 8 2001/01/30 "Red Hat Linux" "System Administrator's Manual"
+.SH NAME
+pam_stack \- recurse into other PAM stacks
+.SH SYNOPSIS
+.B auth required /lib/security/pam_stack.so service=foo
+.br
+.B session optional /lib/security/pam_stack.so service=foo
+.br
+.B password optional /lib/security/pam_stack.so service=foo
+.br
+.B account optional /lib/security/pam_stack.so service=foo
+.SH DESCRIPTION
+In a nutshell, pam_stack lets you "call", from inside of the stack for a
+particular service, the stack defined for any another service.  The intention
+is to allow multiple services to "include" a system-wide setup, so that when
+that setup needs to be changed, it need only be changed in one place.
+
+.SH ARGUMENTS
+.IP debug
+turns on debugging via \fBsyslog(3)\fR.
+.IP service=\fIname\fP
+tells pam_stack.so to execute the stack defined for the service \fIname\fP,
+which will usually be another file in \fB/etc/pam.d\fP.
+
+.SH EXAMPLE
+\fB/etc/pam.d/imap\fP:
+.br
+auth required /lib/security/pam_stack.so service=system-auth
+.br
+auth required /lib/security/pam_shells.so
+.br
+\fB/etc/pam.d/system-auth\fP:
+.br
+auth sufficient /lib/security/pam_krb5.so
+.br
+auth sufficient /lib/security/pam_unix.so shadow nullok
+.br
+auth required /lib/security/pam_deny.so
+
+.br
+.SH CAVEAT
+Because recursion is fully supported, there is potential to really break things
+by having a stack call itself either directly or via mutual recursion.
+.br
+.SH BUGS
+Let's hope not, but if you find any, please email the author.  
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_stack/pam_stack.c Linux-PAM-0.77/modules/pam_stack/pam_stack.c
--- Linux-PAM-0.77.orig/modules/pam_stack/pam_stack.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_stack/pam_stack.c	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,571 @@
+/******************************************************************************
+ * A module for Linux-PAM that will divert to another file and use configuration
+ * information from it, percolating the result code back up.  Recursion is fun.
+ *
+ * Copyright (c) 2000,2001 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ * Portions also Copyright (c) 2000 Dmitry V. Levin
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Log: pam_stack.c,v $
+ * Revision 1.29  2003/07/08 03:16:28  nalin
+ * - port to 0.77, mainly using the new pammodutil getXXXXX_r wrappers instead of
+ *   the macro forms we used for 0.75
+ *
+ * Revision 1.28  2001/11/21 19:38:57  nalin
+ * free handlers at clean-up time
+ *
+ * Revision 1.27  2001/11/21 19:38:33  nalin
+ * free handlers at clean-up time
+ *
+ * Revision 1.26  2001/11/21 17:54:59  nalin
+ * fix some memory leaks (reported by Fernando Trias)
+ *
+ */
+
+#define PAM_SM_AUTH
+#define PAM_SM_SESSION
+#define PAM_SM_ACCOUNT
+#define PAM_SM_PASSWD
+
+#define PAM_CONST const
+
+#include "../../_pam_aconf.h"
+#include "../../libpam/include/security/_pam_types.h"
+#include "../../libpam/pam_private.h"
+#include <sys/syslog.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define STACK_DATA_NAME "pam_stack_saved_stacks"
+struct stack_data {
+	char *service;
+	int debug;
+	pam_handle_t *pamh;
+	struct stack_data *next;
+};
+
+static int _pam_stack_dispatch(pam_handle_t *pamh, int flags,
+			       int argc, const char **argv,
+			       int which_stack);
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return _pam_stack_dispatch(pamh, flags, argc, argv, PAM_AUTHENTICATE);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return _pam_stack_dispatch(pamh, flags, argc, argv, PAM_SETCRED);
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return _pam_stack_dispatch(pamh, flags, argc, argv, PAM_OPEN_SESSION);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return _pam_stack_dispatch(pamh, flags, argc, argv, PAM_CLOSE_SESSION);
+}
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return _pam_stack_dispatch(pamh, flags, argc, argv, PAM_ACCOUNT);
+}
+
+PAM_EXTERN int
+pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return _pam_stack_dispatch(pamh, flags, argc, argv, PAM_CHAUTHTOK);
+}
+
+/* Current libpam now distinguishes between modules and applications, so the
+   neat behavior we depended on is gone.  So we have to this the messy way.
+   What's surprising is that this simplifies things due to the lack of a need
+   to check for error return codes. */
+static void
+_pam_stack_copy(pam_handle_t *source, pam_handle_t *dest, unsigned int item,
+		const char *recipient)
+{
+	const char *name = NULL;			/* name of the item */
+	int copied = 0;					/* was it copied */
+	const char *reason = "(no reason)";		/* if not copied, why */
+	switch(item) {
+		case PAM_AUTHTOK:
+			name = "PAM_AUTHTOK";
+			if(source->authtok) {
+				copied = 1;
+				if(dest->authtok) {
+					_pam_drop(dest->authtok);
+				}
+				dest->authtok = _pam_strdup(source->authtok);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_CONV:
+			name = "PAM_CONV";
+			if(source->pam_conversation && !dest->pam_conversation) {
+				copied = 1;
+				dest->pam_conversation = calloc(1, sizeof(struct pam_conv));
+				*dest->pam_conversation = *source->pam_conversation;
+			} else {
+				if(!source->pam_conversation)
+					reason = "source not NULL";
+				if(dest->pam_conversation)
+					reason = "destination already set";
+			}
+			break;
+		case PAM_FAIL_DELAY:
+			name = "PAM_FAIL_DELAY";
+			if(source->fail_delay.set) {
+				copied = 1;
+				dest->fail_delay = source->fail_delay;
+			} else {
+				reason = "source not set";
+			}
+			break;
+		case PAM_OLDAUTHTOK:
+			name = "PAM_OLDAUTHTOK";
+			if(source->oldauthtok) {
+				copied = 1;
+				if(dest->oldauthtok) {
+					_pam_drop(dest->oldauthtok);
+				}
+				dest->oldauthtok = _pam_strdup(source->oldauthtok);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_RHOST:
+			name = "PAM_RHOST";
+			if(source->rhost) {
+				copied = 1;
+				if(dest->rhost) {
+					_pam_drop(dest->rhost);
+				}
+				dest->rhost = _pam_strdup(source->rhost);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_RUSER:
+			name = "PAM_RUSER";
+			if(source->ruser) {
+				copied = 1;
+				if(dest->ruser) {
+					_pam_drop(dest->ruser);
+				}
+				dest->ruser = _pam_strdup(source->ruser);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_SERVICE:
+			name = "PAM_SERVICE";
+			if(source->service_name) {
+				copied = 1;
+				if(dest->service_name) {
+					_pam_drop(dest->service_name);
+				}
+				dest->service_name = _pam_strdup(source->service_name);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_TTY:
+			name = "PAM_TTY";
+			if(source->tty) {
+				copied = 1;
+				if(dest->tty) {
+					_pam_drop(dest->tty);
+				}
+				dest->tty = _pam_strdup(source->tty);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_USER:
+			name = "PAM_USER";
+			if(source->user) {
+				copied = 1;
+				if(dest->user) {
+					_pam_drop(dest->user);
+				}
+				dest->user = _pam_strdup(source->user);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+		case PAM_USER_PROMPT:
+			name = "PAM_USER_PROMPT";
+			if(source->prompt) {
+				copied = 1;
+				if(dest->prompt) {
+					_pam_drop(dest->prompt);
+				}
+				dest->prompt = _pam_strdup(source->prompt);
+			} else {
+				reason = "source is NULL";
+			}
+			break;
+	}
+	if(recipient) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		if(copied) {
+			syslog(LOG_DEBUG, "passing %s to %s", name, recipient);
+		} else {
+			syslog(LOG_DEBUG, "NOT passing %s to %s: %s", name,
+			       recipient, reason);
+		}
+		closelog();
+	}
+}
+
+static void
+_pam_stack_cleanup(pam_handle_t *pamh, void *data, int status)
+{
+	struct stack_data *stack_this = (struct stack_data*) data, *next;
+	while(stack_this != NULL) {
+		if(stack_this->debug) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "freeing stack data for `%s' service",
+			       stack_this->service);
+			closelog();
+		}
+		/* Clean up and bug out.  Don't free the ITEMs because they're
+		 * shared by the parent's pamh.  Because of how setting items
+		 * works, we don't actually leak memory doing this (!). */
+		next = stack_this->next;
+		stack_this->pamh->data = NULL;
+		_pam_free_handlers(stack_this->pamh);
+		_pam_drop(stack_this->pamh->pam_conversation);
+		_pam_drop(stack_this->pamh->service_name);
+		_pam_drop(stack_this->pamh->user);
+		_pam_drop(stack_this->pamh->authtok);
+		_pam_drop(stack_this->pamh->oldauthtok);
+		_pam_drop(stack_this->pamh->tty);
+		_pam_drop(stack_this->pamh->rhost);
+		_pam_drop(stack_this->pamh->ruser);
+		_pam_drop_env(stack_this->pamh);
+		_pam_drop(stack_this->pamh);
+		free(stack_this->service);
+		free(stack_this);
+		stack_this = next;
+	}
+}
+
+static int
+_pam_stack_dispatch(pam_handle_t *pamh, int flags, int argc, const char **argv,
+		    int which_stack)
+{
+	char **env = NULL, *service = NULL;
+	const char *parent_service = NULL;
+	int debug = 0, i = 0, ret = PAM_SUCCESS, final_ret = PAM_SUCCESS;
+	struct stack_data *stack_data = NULL, *stack_this;
+
+	/* Save the main service name. */
+	ret = pam_get_item(pamh, PAM_SERVICE, (const void **) &parent_service);
+	if(ret != PAM_SUCCESS) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_ERR, "pam_get_item(PAM_SERVICE) returned %s",
+		       pam_strerror(pamh, ret));
+		closelog();
+		return PAM_SYSTEM_ERR;
+	}
+
+	/* Parse arguments. */
+	for(i = 0; i < argc; i++) {
+		if(strncmp("debug", argv[i], 5) == 0) {
+			const char *stack_description = NULL;
+			debug = 1;
+			switch(which_stack) {
+				case PAM_AUTHENTICATE:
+					stack_description = "PAM_AUTHENTICATE";
+					break;
+				case PAM_SETCRED:
+					stack_description = "PAM_SETCRED";
+					break;
+				case PAM_OPEN_SESSION:
+					stack_description = "PAM_OPEN_SESSION";
+					break;
+				case PAM_CLOSE_SESSION:
+					stack_description = "PAM_CLOSE_SESSION";
+					break;
+				case PAM_ACCOUNT:
+					stack_description = "PAM_ACCOUNT";
+					break;
+				case PAM_CHAUTHTOK:
+					stack_description = "PAM_CHAUTHTOK";
+					break;
+				default:
+					stack_description = "(unknown)";
+			}
+			if(stack_description) {
+				openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+				syslog(LOG_DEBUG, "called for \"%s\"",
+				       stack_description);
+				closelog();
+			}
+		}
+		if(strncmp("service=", argv[i], 8) == 0) {
+			_pam_drop(service);
+			service = _pam_strdup(argv[i] + 8);
+		}
+	}
+
+	/* Sign-on message. */
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "called from \"%s\"",
+		       parent_service ? parent_service : "unknown service");
+		closelog();
+	}
+	if(service == NULL) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_ERR, "required argument \"service\" not given");
+		closelog();
+		return PAM_SYSTEM_ERR;
+	}
+
+	/* Log that we're initializing. */
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "initializing");
+		closelog();
+	}
+
+	/* Retrieve a previously-used stack, if we've been called before. */
+	if(pam_get_data(pamh, STACK_DATA_NAME, (const void**)&stack_data) != PAM_SUCCESS) {
+		stack_data = NULL;
+	}
+
+	/* Search for the record for this stack. */
+	stack_this = stack_data;
+	while(stack_this != NULL) {
+		if(strcmp(service, stack_this->service) == 0) {
+			break;
+		}
+		stack_this = stack_this->next;
+	}
+
+	/* If we didn't find one, create one and put it at the front of the
+	 * list of substacks we have contexts for. */
+	if(stack_this == NULL) {
+		if(debug) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "creating child stack `%s'", service);
+			closelog();
+		}
+
+		stack_this = malloc(sizeof(struct stack_data));
+		if(stack_this == NULL) {
+			return PAM_BUF_ERR;
+		}
+
+		memset(stack_this, 0, sizeof(struct stack_data));
+		stack_this->service = _pam_strdup(service);
+		stack_this->pamh = calloc(1, sizeof(pam_handle_t));
+
+		/* Create an environment for the child. */
+		if(debug) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "creating environment");
+			closelog();
+		}
+		ret = _pam_make_env(stack_this->pamh);
+		if(ret != PAM_SUCCESS) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_ERR, "_pam_make_env() returned %s",
+			       pam_strerror(stack_this->pamh, ret));
+			closelog();
+			return PAM_SYSTEM_ERR;
+		}
+
+		/* Set the service.  This loads the service modules. */
+		ret = pam_set_item(stack_this->pamh, PAM_SERVICE, service);
+		if(ret != PAM_SUCCESS) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_ERR, "pam_set_item(PAM_SERVICE) returned %d (%s)",
+			       ret, pam_strerror(stack_this->pamh, ret));
+			closelog();
+			return PAM_SYSTEM_ERR;
+		}
+
+		/* Initialize the handlers for the substack. */
+		_pam_start_handlers(stack_this->pamh);
+		ret = _pam_init_handlers(stack_this->pamh);
+		if(ret != PAM_SUCCESS) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_ERR, "_pam_init_handlers() returned %d (%s)",
+			       ret, pam_strerror(stack_this->pamh, ret));
+			closelog();
+			return PAM_SYSTEM_ERR;
+		}
+
+		/* Insert the data item at the end of the stack list, or make
+		 * it the head if we don't have one yet. */
+		if(stack_data == NULL) {
+			pam_set_data(pamh, STACK_DATA_NAME, stack_this,
+				     _pam_stack_cleanup);
+		} else {
+			while(stack_data->next != NULL) {
+				stack_data = stack_data->next;
+			}
+			stack_data->next = stack_this;
+		}
+
+	} else {
+		if(debug) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "found previously-used child stack "
+			       "`%s'", service);
+			closelog();
+		}
+	}
+	stack_this->debug = debug;
+
+	/* Copy the environment from the upper stack to the lower stack. */
+	env = pam_getenvlist(pamh); 
+	for(i = 0; (env != NULL) && (env[i] != NULL); i++) {
+		if(debug) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "setting environment \"%s\" in child",
+			       env[i]);
+			closelog();
+		}
+		pam_putenv(stack_this->pamh, env[i]);
+	}
+
+	/* Copy named PAM items to the child. */
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_AUTHTOK, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_CONV, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_FAIL_DELAY, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_OLDAUTHTOK, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_RHOST, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_RUSER, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_SERVICE, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_TTY, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_USER, debug ? "child" : NULL);
+	_pam_stack_copy(pamh, stack_this->pamh, PAM_USER_PROMPT, debug ? "child" : NULL);
+
+	/* Pass the generic data pointer, too. */
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "passing data to child");
+		closelog();
+	}
+	stack_this->pamh->data = pamh->data;
+
+	/* Now call the substack. */
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "calling substack");
+		closelog();
+	}
+	final_ret = _pam_dispatch(stack_this->pamh, flags, which_stack);
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "substack returned %d (%s)", final_ret,
+		       pam_strerror(stack_this->pamh, final_ret));
+		closelog();
+	}
+
+	/* Copy the useful data back up to the main stack, environment first. */
+	env = pam_getenvlist(stack_this->pamh); 
+	for(i = 0; (env != NULL) && (env[i] != NULL); i++) {
+		if(debug) {
+			openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+			syslog(LOG_DEBUG, "setting environment \"%s\" in "
+			       "parent", env[i]);
+			closelog();
+		}
+		pam_putenv(pamh, env[i]);
+	}
+
+	/* Now the named data items. */
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_AUTHTOK, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_CONV, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_FAIL_DELAY, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_OLDAUTHTOK, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_RHOST, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_RUSER, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_SERVICE, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_TTY, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_USER, debug ? "parent" : NULL);
+	_pam_stack_copy(stack_this->pamh, pamh, PAM_USER_PROMPT, debug ? "parent" : NULL);
+
+	/* Wow, passing the extra data back is hard. */
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "passing data back");
+		closelog();
+	}
+	pamh->data = stack_this->pamh->data;
+
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "passing former back");
+		closelog();
+	}
+	/* pamh->former = stack_this->pamh->former; FIXME: deep copy? */
+
+	if(debug) {
+		openlog("pam_stack", LOG_PID, LOG_AUTHPRIV);
+		syslog(LOG_DEBUG, "returning %d (%s)", final_ret,
+		       pam_strerror(stack_this->pamh, final_ret));
+		closelog();
+	}
+
+	return final_ret;
+}
+
+#ifdef PAM_STATIC
+/* static module data */
+struct pam_module _pam_stack_modstruct = {
+	"pam_stack",
+	pam_sm_authenticate,
+	pam_sm_setcred,
+	pam_sm_acct_mgmt,
+	pam_sm_open_session,
+	pam_sm_close_session,
+	pam_sm_chauthtok,
+};
+#endif
+
diff -Nur Linux-PAM-0.77.orig/modules/pam_stack/README Linux-PAM-0.77/modules/pam_stack/README
--- Linux-PAM-0.77.orig/modules/pam_stack/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_stack/README	2001-02-13 21:29:32.000000000 +0200
@@ -0,0 +1,22 @@
+This is pam_stack, a module for implementing recursive stacking with
+Linux-PAM.  Because it's naughty and accesses some of the internals of
+libpam, it's not likely that it can be made to work on anything but
+Linux-PAM on Linux, FreeBSD, and other OSs that use Linux-PAM.
+
+In a nutshell, calling pam_stack diverts a PAM stack into another
+configuration file.  If the substack executes successfully, pam_stack
+returns PAM_SUCCESS.  If the substack fails, pam_stack returns the
+error code returned by the internal PAM dispatching routines, which
+is typically the code returned by the module that failed.
+
+This is primarily of use for when you want a consistent authentication
+model for all of your system services, but want to allow the specifics
+to change from service to service (like whether or not to use pam_rootok
+or pam_securetty).
+
+The module takes only two arguments:
+debug		log lots of information to the system log
+service=NAME	use as a substack the stack defined for the NAME service,
+		usually the name of a file in /etc/pam.d
+
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_succeed_if/Makefile Linux-PAM-0.77/modules/pam_succeed_if/Makefile
--- Linux-PAM-0.77.orig/modules/pam_succeed_if/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_succeed_if/Makefile	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,16 @@
+#
+# $Id: Makefile,v 1.2 2003/07/08 03:16:28 nalin Exp $
+#
+# This Makefile controls a build process of $(TITLE) module for
+# Linux-PAM. You should not modify this Makefile (unless you know
+# what you are doing!).
+#
+# Created by Andrew Morgan <morgan@linux.kernel.org> 2000/08/27
+#
+
+include ../../Make.Rules
+
+TITLE=pam_succeed_if
+MAN8=$(TITLE).8
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_succeed_if/pam_succeed_if.8 Linux-PAM-0.77/modules/pam_succeed_if/pam_succeed_if.8
--- Linux-PAM-0.77.orig/modules/pam_succeed_if/pam_succeed_if.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_succeed_if/pam_succeed_if.8	2003-07-08 07:02:01.000000000 +0300
@@ -0,0 +1,30 @@
+.\" Copyright 2003 Red Hat, Inc.
+.\" Written by Nalin Dahyabhai <nalin@redhat.com>
+.TH pam_succeed_if 8 2003/6/30 "Red Hat Linux" "System Administrator's Manual"
+
+.SH NAME
+pam_succeed_if \- succeed or fail based on account characteristics
+
+.SH SYNOPSIS
+.B account sufficient pam_succeed_if.so uid < 500
+
+.SH DESCRIPTION
+pam_succeed_if.so is designed to succeed or fail authentication based on
+characteristics of the account belonging to the user being authenticated.
+
+The module can be given one or more conditions as module arguments, and
+authentication will succeed only if all of the conditions are met.
+
+.SH ARGUMENTS
+.IP debug
+Turns on debugging messages sent to syslog.
+.IP use_uid
+Evaluate conditions using the account of the user whose UID the application
+is running under instead of the user being authenticated.
+
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_succeed_if/pam_succeed_if.c Linux-PAM-0.77/modules/pam_succeed_if/pam_succeed_if.c
--- Linux-PAM-0.77.orig/modules/pam_succeed_if/pam_succeed_if.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_succeed_if/pam_succeed_if.c	2003-07-22 07:22:25.000000000 +0300
@@ -0,0 +1,453 @@
+/******************************************************************************
+ * A simple user-attribute based module for PAM.
+ *
+ * Copyright (c) 2003 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <fnmatch.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <pwd.h>
+#include <grp.h>
+#include <security/pam_modules.h>
+#include <security/_pam_modutil.h>
+
+#define MODULE "pam_succeed_if"
+
+static void
+log_error(int priority, const char *fmt, ...)
+{
+	va_list va;
+	char *fmt2;
+	fmt2 = malloc(strlen(fmt) + strlen(MODULE) + 3);
+	va_start(va, fmt);
+	if (fmt2 == NULL) {
+		vsyslog(LOG_AUTHPRIV | priority, fmt, va);
+	} else {
+		snprintf(fmt2, strlen(fmt) + strlen(MODULE) + 3,
+			 "%s: %s", MODULE, fmt);
+		vsyslog(LOG_AUTHPRIV | priority, fmt2, va);
+	}
+	va_end(va);
+}
+
+/* Basically, run cmp(atol(left), atol(right)), returning PAM_SUCCESS if
+ * the function returns non-zero, PAM_AUTH_ERR if it returns zero, and
+ * PAM_SYSTEM_ERR if the arguments can't be parsed as numbers. */
+static int
+evaluate_num(const char *left, const char *right, int (*cmp)(int, int))
+{
+	long l, r;
+	char *p;
+	int ret = PAM_SUCCESS;
+
+	l = strtol(left, &p, 0);
+	if ((p == NULL) || (*p != '\0')) {
+		log_error(LOG_INFO, "\"%s\" is not a number", left);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	r = strtol(right, &p, 0);
+	if ((p == NULL) || (*p != '\0')) {
+		log_error(LOG_INFO, "\"%s\" is not a number", right);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	if (ret != PAM_SUCCESS) {
+		return ret;
+	}
+		
+	return cmp(l, r) ? PAM_SUCCESS : PAM_AUTH_ERR;
+}
+
+/* Simple numeric comparison callbacks. */
+static int
+eq(int i, int j)
+{
+	return i == j;
+}
+static int
+ne(int i, int j)
+{
+	return i != j;
+}
+static int
+lt(int i, int j)
+{
+	return i < j;
+}
+static int
+le(int i, int j)
+{
+	return lt(i, j) || eq(i, j);
+}
+static int
+gt(int i, int j)
+{
+	return i > j;
+}
+static int
+ge(int i, int j)
+{
+	return gt(i, j) || eq(i, j);
+}
+
+/* Test for numeric equality. */
+static int
+evaluate_eqn(const char *left, const char *right)
+{
+	return evaluate_num(left, right, eq);
+}
+/* Test for string equality. */
+static int
+evaluate_eqs(const char *left, const char *right)
+{
+	return (strcmp(left, right) == 0) ? PAM_SUCCESS : PAM_AUTH_ERR;
+}
+/* Test for numeric inequality. */
+static int
+evaluate_nen(const char *left, const char *right)
+{
+	return evaluate_num(left, right, ne);
+}
+/* Test for string inequality. */
+static int
+evaluate_nes(const char *left, const char *right)
+{
+	return (strcmp(left, right) != 0) ? PAM_SUCCESS : PAM_AUTH_ERR;
+}
+/* Test for numeric less-than-ness(?) */
+static int
+evaluate_lt(const char *left, const char *right)
+{
+	return evaluate_num(left, right, lt);
+}
+/* Test for numeric less-than-or-equal-ness(?) */
+static int
+evaluate_le(const char *left, const char *right)
+{
+	return evaluate_num(left, right, le);
+}
+/* Test for numeric greater-than-ness(?) */
+static int
+evaluate_gt(const char *left, const char *right)
+{
+	return evaluate_num(left, right, gt);
+}
+/* Test for numeric greater-than-or-equal-ness(?) */
+static int
+evaluate_ge(const char *left, const char *right)
+{
+	return evaluate_num(left, right, ge);
+}
+/* Check for file glob match. */
+static int
+evaluate_glob(const char *left, const char *right)
+{
+	return (fnmatch(right, left, 0) == 0) ? PAM_SUCCESS : PAM_AUTH_ERR;
+}
+/* Check for file glob mismatch. */
+static int
+evaluate_noglob(const char *left, const char *right)
+{
+	return (fnmatch(right, left, 0) != 0) ? PAM_SUCCESS : PAM_AUTH_ERR;
+}
+/* Return PAM_SUCCESS if the user is in the group. */
+static int
+evaluate_ingroup(pam_handle_t *pamh, const char *user, const char *group)
+{
+	int ret;
+	ret = _pammodutil_user_in_group_nam_nam(pamh, user, group);
+	switch (ret) {
+	case 1:
+		return PAM_SUCCESS;
+		break;
+	default:
+		break;
+	}
+	return PAM_AUTH_ERR;
+}
+/* Return PAM_SUCCESS if the user is NOT in the group. */
+static int
+evaluate_notingroup(pam_handle_t *pamh, const char *user, const char *group)
+{
+	int ret;
+	ret = _pammodutil_user_in_group_nam_nam(pamh, user, group);
+	switch (ret) {
+	case 0:
+		return PAM_SUCCESS;
+		break;
+	default:
+		break;
+	}
+	return PAM_AUTH_ERR;
+}
+
+/* Match a triple. */
+static int
+evaluate(pam_handle_t *pamh, int debug,
+	 const char *left, const char *qual, const char *right,
+	 struct passwd *pwd, gid_t *grouplist, size_t grlistlen)
+{
+	char buf[LINE_MAX] = "";
+	const char *attribute = left;
+	/* Figure out what we're evaluating here, and convert it to a string.*/
+	if ((strcasecmp(left, "login") == 0) ||
+	    (strcasecmp(left, "name") == 0) ||
+	    (strcasecmp(left, "user") == 0)) {
+		snprintf(buf, sizeof(buf), "%s", pwd->pw_name);
+		left = buf;
+	}
+	if (strcasecmp(left, "uid") == 0) {
+		snprintf(buf, sizeof(buf), "%lu", (unsigned long) pwd->pw_uid);
+		left = buf;
+	}
+	if (strcasecmp(left, "gid") == 0) {
+		snprintf(buf, sizeof(buf), "%lu", (unsigned long) pwd->pw_gid);
+		left = buf;
+	}
+	if (strcasecmp(left, "shell") == 0) {
+		snprintf(buf, sizeof(buf), "%s", pwd->pw_shell);
+		left = buf;
+	}
+	if ((strcasecmp(left, "home") == 0) ||
+	    (strcasecmp(left, "dir") == 0) ||
+	    (strcasecmp(left, "homedir") == 0)) {
+		snprintf(buf, sizeof(buf), "%s", pwd->pw_dir);
+		left = buf;
+	}
+	/* If we have no idea what's going on, return an error. */
+	if (left != buf) {
+		log_error(LOG_CRIT, "unknown attribute \"%s\"", left);
+		return PAM_SERVICE_ERR;
+	}
+	if (debug) {
+		log_error(LOG_DEBUG, "'%s' resolves to '%s'", attribute, left);
+	}
+
+	/* Attribute value < some threshold. */
+	if ((strcasecmp(qual, "<") == 0) ||
+	    (strcasecmp(qual, "lt") == 0)) {
+		return evaluate_lt(left, right);
+	}
+	/* Attribute value <= some threshold. */
+	if ((strcasecmp(qual, "<=") == 0) ||
+	    (strcasecmp(qual, "le") == 0)) {
+		return evaluate_le(left, right);
+	}
+	/* Attribute value > some threshold. */
+	if ((strcasecmp(qual, ">") == 0) ||
+	    (strcasecmp(qual, "gt") == 0)) {
+		return evaluate_gt(left, right);
+	}
+	/* Attribute value >= some threshold. */
+	if ((strcasecmp(qual, ">=") == 0) ||
+	    (strcasecmp(qual, "ge") == 0)) {
+		return evaluate_ge(left, right);
+	}
+	/* Attribute value == some threshold. */
+	if (strcasecmp(qual, "eq") == 0) {
+		return evaluate_eqn(left, right);
+	}
+	/* Attribute value = some string. */
+	if (strcasecmp(qual, "=") == 0) {
+		return evaluate_eqs(left, right);
+	}
+	/* Attribute value != some threshold. */
+	if (strcasecmp(qual, "ne") == 0) {
+		return evaluate_nen(left, right);
+	}
+	/* Attribute value != some string. */
+	if (strcasecmp(qual, "!=") == 0) {
+		return evaluate_nes(left, right);
+	}
+	/* Attribute value matches some pattern. */
+	if ((strcasecmp(qual, "=~") == 0) ||
+	    (strcasecmp(qual, "glob") == 0)) {
+		return evaluate_glob(left, right);
+	}
+	if ((strcasecmp(qual, "!~") == 0) ||
+	    (strcasecmp(qual, "noglob") == 0)) {
+		return evaluate_noglob(left, right);
+	}
+	/* User is in this group. */
+	if (strcasecmp(qual, "ingroup") == 0) {
+		return evaluate_ingroup(pamh, pwd->pw_name, right);
+	}
+	/* User is not in this group. */
+	if (strcasecmp(qual, "notingroup") == 0) {
+		return evaluate_notingroup(pamh, pwd->pw_name, right);
+	}
+	/* Fail closed. */
+	return PAM_SERVICE_ERR;
+}
+
+int
+pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	const char *prompt;
+	const char *user;
+	struct passwd *pwd;
+	gid_t *grouplist = NULL;
+	size_t grlistlen = 2;
+	int ret, i, count, use_uid, debug;
+	const char *left, *right, *qual;
+
+	/* Get the user prompt. */
+	ret = pam_get_item(pamh, PAM_USER_PROMPT, (const void**) &prompt);
+	if ((ret != PAM_SUCCESS) || (prompt == NULL) || (strlen(prompt) == 0)) {
+		prompt = "login: ";
+	}
+
+	for (use_uid = 0, debug = 0, i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug++;
+		}
+		if (strcmp(argv[i], "use_uid") == 0) {
+			use_uid++;
+		}
+	}
+
+	if (use_uid) {
+		/* Get information about the user. */
+		pwd = _pammodutil_getpwuid(pamh, getuid());
+		if (pwd == NULL) {
+			log_error(LOG_CRIT,
+				  "error retrieving information about user %ld",
+				  (long)getuid());
+			return PAM_SERVICE_ERR;
+		}
+	} else {
+		/* Get the user's name. */
+		ret = pam_get_user(pamh, &user, prompt);
+		if ((ret != PAM_SUCCESS) || (user == NULL)) {
+			log_error(LOG_CRIT, "error retrieving user name: %s",
+				  pam_strerror(pamh, ret));
+			return ret;
+		}
+
+		/* Get information about the user. */
+		pwd = _pammodutil_getpwnam(pamh, user);
+		if (pwd == NULL) {
+			log_error(LOG_CRIT,
+				  "error retrieving information about user %s",
+				  user);
+			return PAM_SERVICE_ERR;
+		}
+	}
+
+	/* Get the user's supplemental group list. */
+	grlistlen = 2;
+	do {
+		grouplist = malloc(sizeof(gid_t) * grlistlen);
+		ret = getgrouplist(pwd->pw_name, pwd->pw_gid,
+				   grouplist, &grlistlen);
+		if (ret == -1) {
+			free(grouplist);
+			grlistlen *= 2;
+		}
+	} while (ret == -1);
+	if ((ret == -1) || (grlistlen < 0)) {
+		log_error(LOG_CRIT,
+			  "error retrieving group list for user %s", user);
+		return PAM_SERVICE_ERR;
+	}
+
+	/* Walk the argument list. */
+	i = count = 0;
+	left = qual = right = NULL;
+	while (i <= argc) {
+		if ((left != NULL) && (qual != NULL) && (right != NULL)) {
+			ret = evaluate(pamh, debug,
+				       left, qual, right,
+				       pwd, grouplist, grlistlen);
+			if (ret != PAM_SUCCESS) {
+				log_error(LOG_INFO,
+					  "requirement \"%s %s %s\" "
+					  "not met by user \"%s\"",
+					  left, qual, right, user);
+				break;
+			}
+			left = qual = right = NULL;
+		}
+		if ((i < argc) && (strcmp(argv[i], "debug") == 0)) {
+			i++;
+			continue;
+		}
+		if ((i < argc) && (strcmp(argv[i], "use_uid") == 0)) {
+			i++;
+			continue;
+		}
+		if ((i < argc) && (left == NULL)) {
+			left = argv[i++];
+			count++;
+			continue;
+		}
+		if ((i < argc) && (qual == NULL)) {
+			qual = argv[i++];
+			count++;
+			continue;
+		}
+		if ((i < argc) && (right == NULL)) {
+			right = argv[i++];
+			count++;
+			continue;
+		}
+		i++;
+	}
+
+	return ret;
+}
+
+int
+pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return PAM_SUCCESS;
+}
+
+int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return pam_sm_authenticate(pamh, flags, argc, argv);
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_succeed_if/README Linux-PAM-0.77/modules/pam_succeed_if/README
--- Linux-PAM-0.77.orig/modules/pam_succeed_if/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_succeed_if/README	2003-07-08 07:02:01.000000000 +0300
@@ -0,0 +1,65 @@
+pam_succeed_if:
+	Succeed or fail based on account characteristics.
+
+	pam_succeed_if.so is designed to succeed or fail authentication based
+	on characteristics of the account belonging to the user being
+	authenticated.
+
+	The module can be given one or more conditions as module arguments, and
+	authentication will succeed only if all of the conditions are met.
+
+	Conditions are expressed in the form
+
+		ATTRIBUTE OPERATOR VALUE
+	
+	Recognized attributes:
+
+		LOGIN	- The user's login name.
+		UID	- The user's UID.
+		GID	- The user's primary GID.
+		SHELL	- The user's shell.
+		HOME	- The user's home directory.
+
+	Recognized operators:
+
+		<		- Arithmetic less-than.
+		<=		- Arithmetic less-than-or-equal-to.
+		>		- Arithmetic greater-than.
+		>=		- Arithmetic greater-than-or-equal-to.
+		eq		- Arithmetic equality.
+		=		- String equality.
+		ne		- Arithmetic inequality.
+		!=		- String inequality.
+		=~		- Wildcard match.
+		!~		- Wildcard mismatch.
+		ingroup		- Group membership check. [*]
+		notingroup	- Group non-membership check. [*]
+
+		* The "ingroup" and "notingroup" operators should only be
+		  used with the USER attribute.
+
+	Examples:
+
+		Deny authentication to all users except those in the wheel
+		group, before even asking for a password:
+			auth requisite pam_succeed_if.so user ingroup wheel
+
+		Assume all users with UID less than 500 ("system users") have
+		valid accounts.
+			account sufficient pam_succeed_if.so uid < 500
+
+		Deny login to all nologin users.
+			auth requisite pam_succeed_if.so shell !~ nologin
+
+RECOGNIZED ARGUMENTS:
+	debug		write debugging messages to syslog
+	use_uid 	perform checks on the account of the user under whose
+			UID the application is running instead of the user
+			being authenticated
+
+
+MODULE SERVICES PROVIDED:
+	authentication, account management
+
+AUTHOR:
+	Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/hmacfile.c Linux-PAM-0.77/modules/pam_timestamp/hmacfile.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/hmacfile.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/hmacfile.c	2003-07-03 04:53:51.000000000 +0300
@@ -0,0 +1,119 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include "hmacsha1.h"
+
+static void
+testvectors(void)
+{
+	char *hmac;
+	size_t hmac_len;
+	int i, j;
+	char hex[3];
+	struct vector {
+		const unsigned char *key;
+		int key_len;
+		const unsigned char *data;
+		int data_len;
+		const char *hmac;
+	} vectors[] = {
+		{
+		"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b", 20,
+		"Hi There", 8,
+		"b617318655057264e28bc0b6fb378c8ef146be00",
+		},
+
+		{
+		"Jefe", 4,
+		"what do ya want for nothing?", 28,
+		"effcdf6ae5eb2fa2d27416d5f184df9c259a7c79",
+		},
+
+		{
+		"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa", 20,
+		"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd", 50,
+		"125d7342b9ac11cd91a39af48aa17b4f63f175d3",
+		},
+
+		{
+		"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19", 25,
+		"\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd",
+		50,
+		"4c9007f4026250c6bc8414f9bf50c86c2d7235da",
+		},
+
+		{
+		"\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c", 20,
+		"Test With Truncation", 20,
+		"4c1a03424b55e07fe7f27be1d58bb9324a9a5a04",
+		},
+
+		{
+		"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		80,
+		"Test Using Larger Than Block-Size Key - Hash Key First", 54,
+		"aa4ae5e15272d00e95705637ce8a3b55ed402112",
+		},
+
+		{
+		"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa",
+		80,
+		"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data", 73,
+		"e8e99d0f45237d786d6bbaa7965c7808bbff1a91",
+		},
+	};
+	for (i = 0; i < sizeof(vectors) / sizeof(vectors[0]); i++) {
+		hmac = NULL;
+		hmac_len = 0;
+		hmac_sha1_generate(&hmac, &hmac_len,
+				   vectors[i].key, vectors[i].key_len,
+				   vectors[i].data, vectors[i].data_len);
+		if (hmac != NULL) {
+			for (j = 0; j < hmac_len; j++) {
+				snprintf(hex, sizeof(hex), "%02x",
+					 hmac[j] & 0xff);
+				if (strncasecmp(hex,
+						vectors[i].hmac + 2 * j,
+						2) != 0) {
+					printf("Incorrect result for vector %d\n", i + 1);
+					exit(1);
+
+				}
+			}
+			free(hmac);
+		} else {
+			printf("Error in vector %d.\n", i + 1);
+			exit(1);
+		}
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	char *hmac;
+	size_t maclen;
+	const char *keyfile;
+	int i, j;
+
+	testvectors();
+
+	keyfile = argv[1];
+	for (i = 2; i < argc; i++) {
+		hmac_sha1_generate_file(&hmac, &maclen, keyfile, -1, -1,
+					argv[i], strlen(argv[i]));
+		if (hmac != NULL) {
+			for (j = 0; j < maclen; j++) {
+				printf("%02x", hmac[j] & 0xff);
+			}
+			printf("  %s\n", argv[i]);
+			free(hmac);
+		}
+	}
+	return 0;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/hmacsha1.c Linux-PAM-0.77/modules/pam_timestamp/hmacsha1.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/hmacsha1.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/hmacsha1.c	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,265 @@
+/* An implementation of HMAC using SHA-1.
+ *
+ * Copyright (c) 2003 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* See RFC 2104 for descriptions. */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include "hmacsha1.h"
+#include "sha1.h"
+
+#define MINIMUM_KEY_SIZE SHA1_OUTPUT_SIZE
+#define MAXIMUM_KEY_SIZE SHA1_BLOCK_SIZE
+
+static void
+hmac_key_create(const char *filename, size_t key_size, uid_t owner, gid_t group)
+{
+	int randfd, keyfd, count, i;
+	char *key;
+
+	/* Open the destination file. */
+	keyfd = open(filename,
+		     O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
+		     S_IRUSR | S_IWUSR);
+	if ((keyfd == -1) || (fchown(keyfd, owner, group) == -1)) {
+		return;
+	}
+
+	/* Open the random device to get key data. */
+	randfd = open("/dev/urandom", O_RDONLY);
+	if (randfd == -1) {
+		close(keyfd);
+		return;
+	}
+
+	/* Read random data for use as the key. */
+	key = malloc(key_size);
+	count = 0;
+	while (count < key_size) {
+		i = read(randfd, key + count, key_size - count);
+		if ((i == 0) || (i == -1)) {
+			break;
+		}
+		count += i;
+	}
+
+	close(randfd);
+
+	/* If we didn't get enough, stop here. */
+	if (count < key_size) {
+		memset(key, 0, key_size);
+		free(key);
+		close(keyfd);
+		return;
+	}
+
+	/* Now write the key. */
+	count = 0;
+	while (count < key_size) {
+		i = write(keyfd, key + count, key_size - count);
+		if ((i == 0) || (i == -1)) {
+			break;
+		}
+		count += i;
+	}
+	memset(key, 0, key_size);
+	free(key);
+	close(keyfd);
+}
+
+static void
+hmac_key_read(const char *filename, size_t default_key_size,
+	      uid_t owner, gid_t group,
+	      unsigned char **key, size_t *key_size)
+{
+	char *tmp;
+	int keyfd, i, count;
+	struct stat st;
+
+	tmp = NULL;
+	*key = NULL;
+	*key_size = 0;
+
+	/* Try to open the key file. */
+	keyfd = open(filename, O_RDONLY);
+	if (keyfd == -1) {
+		/* No such thing? Create it. */
+		if (errno == ENOENT) {
+			hmac_key_create(filename, default_key_size,
+					owner, group);
+			keyfd = open(filename, O_RDONLY);
+		}
+	}
+
+	/* If we failed to open the file, we're done. */
+	if ((keyfd == -1) || (fstat(keyfd, &st) == -1)) {
+		close(keyfd);
+		return;
+	}
+
+	/* Read the contents of the file. */
+	tmp = malloc(st.st_size);
+
+	count = 0;
+	while (count < st.st_size) {
+		i = read(keyfd, tmp + count, st.st_size - count);
+		if ((i == 0) || (i == -1)) {
+			break;
+		}
+		count += i;
+	}
+	close(keyfd);
+
+	/* Require that we got the expected amount of data. */
+	if (count < st.st_size) {
+		memset(tmp, 0, st.st_size);
+		free(tmp);
+		return;
+	}
+
+	/* Pass the key back. */
+	*key = tmp;
+	*key_size = st.st_size;
+}
+
+static void
+xor_block(unsigned char *p, unsigned char byte, size_t length)
+{
+	int i;
+	for (i = 0; i < length; i++) {
+		p[i] = p[i] ^ byte;
+	}
+}
+
+void
+hmac_sha1_generate(char **mac, size_t *mac_length,
+		   const unsigned char *raw_key, size_t raw_key_size,
+		   const char *text, size_t text_length)
+{
+	char key[MAXIMUM_KEY_SIZE], tmp_key[MAXIMUM_KEY_SIZE];
+	size_t maximum_key_size = SHA1_BLOCK_SIZE,
+	       minimum_key_size = SHA1_OUTPUT_SIZE;
+	const unsigned char ipad = 0x36, opad = 0x5c;
+	struct sha1_context sha1;
+	char inner[SHA1_OUTPUT_SIZE], outer[SHA1_OUTPUT_SIZE];
+
+	*mac = NULL;
+	*mac_length = 0;
+
+#ifndef HMAC_ALLOW_SHORT_KEYS
+	/* If the key is too short, don't bother. */
+	if (raw_key_size < minimum_key_size) {
+		return;
+	}
+#endif
+
+	/* If the key is too long, "compress" it, else copy it and pad it
+	 * out with zero bytes. */
+	memset(key, 0, sizeof(key));
+	if (raw_key_size > maximum_key_size) {
+		sha1_init(&sha1);
+		sha1_update(&sha1, raw_key, raw_key_size);
+		sha1_output(&sha1, key);
+	} else {
+		memmove(key, raw_key, raw_key_size);
+	}
+
+	/* Generate the inner sum. */
+	memcpy(tmp_key, key, sizeof(tmp_key));
+	xor_block(tmp_key, ipad, sizeof(tmp_key));
+
+	sha1_init(&sha1);
+	sha1_update(&sha1, tmp_key, sizeof(tmp_key));
+	sha1_update(&sha1, text, text_length);
+	sha1_output(&sha1, inner);
+
+	/* Generate the outer sum. */
+	memcpy(tmp_key, key, sizeof(tmp_key));
+	xor_block(tmp_key, opad, sizeof(tmp_key));
+
+	sha1_init(&sha1);
+	sha1_update(&sha1, tmp_key, sizeof(tmp_key));
+	sha1_update(&sha1, inner, sizeof(inner));
+	sha1_output(&sha1, outer);
+
+	/* We don't need any of the keys any more. */
+	memset(key, 0, sizeof(key));
+	memset(tmp_key, 0, sizeof(tmp_key));
+
+	/* Allocate space to store the output. */
+	*mac_length = sizeof(outer);
+	*mac = malloc(*mac_length);
+	if (*mac == NULL) {
+		*mac_length = 0;
+		return;
+	}
+
+	memcpy(*mac, outer, *mac_length);
+}
+
+void
+hmac_sha1_generate_file(char **mac, size_t *mac_length,
+			const char *keyfile, uid_t owner, gid_t group,
+			const char *text, size_t text_length)
+{
+	unsigned char *key;
+	size_t key_length;
+
+	hmac_key_read(keyfile,
+		      MAXIMUM_KEY_SIZE, owner, group,
+		      &key, &key_length);
+	if (key == NULL) {
+		return;
+	}
+	hmac_sha1_generate(mac, mac_length,
+			   key, key_length,
+			   text, text_length);
+	memset(key, 0, key_length);
+	free(key);
+}
+
+size_t
+hmac_sha1_size(void)
+{
+	return SHA1_OUTPUT_SIZE;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/hmacsha1.h Linux-PAM-0.77/modules/pam_timestamp/hmacsha1.h
--- Linux-PAM-0.77.orig/modules/pam_timestamp/hmacsha1.h	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/hmacsha1.h	2003-07-03 04:52:31.000000000 +0300
@@ -0,0 +1,14 @@
+#ifndef pam_timestamp_hmacfile_h
+#define pam_timestamp_hmacfile_h
+
+#include <sys/types.h>
+
+size_t hmac_sha1_size(void);
+void hmac_sha1_generate(char **mac, size_t *mac_length,
+			const unsigned char *key, size_t key_length,
+			const char *text, size_t text_length);
+void hmac_sha1_generate_file(char **mac, size_t *mac_length,
+			     const char *keyfile, uid_t owner, gid_t group,
+			     const char *text, size_t text_length);
+
+#endif
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/hmactest.c Linux-PAM-0.77/modules/pam_timestamp/hmactest.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/hmactest.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/hmactest.c	2003-07-03 04:53:51.000000000 +0300
@@ -0,0 +1,58 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+
+static void
+read_key_file(const char *filename, char **key, int *keylen)
+{
+	int fd;
+	struct stat st;
+
+	*key = NULL;
+	*keylen = 0;
+
+	fd = open(filename, O_RDONLY);
+	if (fd == -1) {
+		return;
+	}
+
+	if (fstat(fd, &st) == -1) {
+		close(fd);
+		return;
+	}
+	
+	*keylen = st.st_size;
+	*key = malloc(st.st_size);
+	read(fd, *key, st.st_size);
+}
+
+int
+main(int argc, char **argv)
+{
+	unsigned char hmac[EVP_MAX_MD_SIZE];
+	unsigned int hmaclen;
+	const char *keyfile;
+	char *key;
+	int keylen;
+	int i, j;
+
+	keyfile = argv[1];
+	for (i = 2; i < argc; i++) {
+		read_key_file(keyfile, &key, &keylen);
+		HMAC(EVP_sha1(), key, keylen, argv[i], strlen(argv[i]),
+		     hmac, &hmaclen);
+		for (j = 0; j < hmaclen; j++) {
+			printf("%02x", hmac[j] & 0xff);
+		}
+		printf("  %s\n", argv[i]);
+		free(key);
+	}
+	return 0;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/Makefile Linux-PAM-0.77/modules/pam_timestamp/Makefile
--- Linux-PAM-0.77.orig/modules/pam_timestamp/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/Makefile	2003-07-08 06:16:28.000000000 +0300
@@ -0,0 +1,23 @@
+#
+# $Id: Makefile,v 1.5 2003/07/08 03:16:28 nalin Exp $
+#
+
+include ../../Make.Rules
+
+TITLE=pam_timestamp
+APPLICATION=$(TITLE)_check
+APPMODE=04511
+MAN8=$(TITLE).8 $(TITLE)_check.8
+MODULE_SIMPLE_EXTRAFILES=sha1 hmacsha1
+
+MODULE_SIMPLE_INSTALL=$(MAKE) $(APPLICATION); $(INSTALL) -m $(APPMODE) $(APPLICATION) $(FAKEROOT)$(SUPLEMENTED)
+
+include ../Simple.Rules
+
+$(APPLICATION): $(APPLICATION).c
+	$(CC) $(CFLAGS) $(INCLUDE_PAMMODUTILS) -o $@ $^ $(LINK_PAMMODUTILS)
+
+hmacfile: hmacfile.c hmacsha1.c sha1.c
+	$(CC) $(CFLAGS) -DHMAC_ALLOW_SHORT_KEYS -o $@ $^
+hmactest: hmactest.c
+	$(CC) $(CFLAGS) -o $@ $^ -lcrypto
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp.8 Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp.8
--- Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp.8	2002-05-24 02:11:07.000000000 +0300
@@ -0,0 +1,54 @@
+.TH pam_timestamp 8 2002/02/07 "Red Hat Linux" "System Administrator's Manual"
+.SH NAME
+pam_timestamp \- authenticate using cached successful authentication attempts
+.SH SYNOPSIS
+.B auth sufficient /lib/security/pam_timestamp.so
+.br
+.B session optional /lib/security/pam_timestamp.so
+.br
+
+.SH DESCRIPTION
+In a nutshell, pam_timestamp caches successful authentication attempts, and
+allows you to use a recent successful attempt as the basis for authentication.
+
+When an application opens a session using pam_timestamp, a timestamp file is
+created in the \fItimestampdir\fP directory for the user.  When an application
+attempts to authenticate the user, a pam_timestamp will treat a sufficiently-
+recent timestamp file as grounds for succeeding.
+
+.SH ARGUMENTS
+.IP debug
+turns on debugging via \fBsyslog(3)\fR.
+.IP timestampdir=\fIname\fP
+tells pam_timestamp.so where to place and search for timestamp files.  This
+should match the directory configured for sudo(1) in the sudoers(5) file.
+.IP timestamp_timeout=\fInumber\fP
+tells pam_timestamp.so how long it should treat timestamp files as valid
+after their last modification date.  This should match the value configured
+for sudo(1) in the sudoers(5) file.
+.IP verbose
+attempt to inform the user when access is granted.
+
+.SH EXAMPLE
+\fB/etc/pam.d/some-config-tool\fP:
+.br
+auth sufficient /lib/security/pam_timestamp.so verbose
+auth required   /lib/security/pam_unix.so
+.br
+session required /lib/security/pam_permit.so
+session optional /lib/security/pam_timestamp.so
+.br
+
+.SH CAVEATS
+Users can get confused when they aren't always asked for passwords when running
+a given program.  Some users reflexively begin typing information before
+noticing that it's not being asked for.
+
+.SH SEE ALSO
+pam_timestamp_check(8)
+
+.SH BUGS
+Let's hope not, but if you find any, please email the author.  
+
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp.c Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp.c	2003-10-17 20:02:43.000000000 +0300
@@ -0,0 +1,738 @@
+/******************************************************************************
+ * A module for Linux-PAM that will cache authentication results, inspired by
+ * (and implemented with an eye toward being mixable with) sudo.
+ *
+ * Copyright (c) 2002 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define PAM_SM_AUTH
+#define PAM_SM_SESSION
+
+#include "../../_pam_aconf.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include "hmacsha1.h"
+
+#include "../../_pam_aconf.h"
+#include <security/pam_modules.h>
+#include <security/_pam_macros.h>
+#include <security/_pam_modutil.h>
+
+/* The default timeout we use is 5 minutes, which matches the sudo default
+ * for the timestamp_timeout parameter. */
+#define DEFAULT_TIMESTAMP_TIMEOUT (5 * 60)
+#define MODULE "pam_timestamp"
+#define TIMESTAMPDIR "/var/run/sudo"
+#define TIMESTAMPKEY TIMESTAMPDIR "/_pam_timestamp_key"
+
+/* Various buffers we use need to be at least as large as either PATH_MAX or
+ * LINE_MAX, so choose the larger of the two. */
+#if (LINE_MAX > PATH_MAX)
+#define BUFLEN LINE_MAX
+#else
+#define BUFLEN PATH_MAX
+#endif
+
+/* Return PAM_SUCCESS if the given directory looks "safe". */
+static int
+check_dir_perms(const char *tdir)
+{
+	char scratch[BUFLEN];
+	struct stat st;
+	int i;
+	/* Check that the directory is "safe". */
+	if ((tdir == NULL) || (strlen(tdir) == 0)) {
+		return PAM_AUTH_ERR;
+	}
+	/* Iterate over the path, checking intermediate directories. */
+	memset(scratch, 0, sizeof(scratch));
+	for (i = 0; (tdir[i] != '\0') && (i < sizeof(scratch)); i++) {
+		scratch[i] = tdir[i];
+		if ((scratch[i] == '/') || (tdir[i + 1] == '\0')) {
+			/* We now have the name of a directory in the path, so
+			 * we need to check it. */
+			if ((lstat(scratch, &st) == -1) && (errno != ENOENT)) {
+				syslog(LOG_ERR,
+				       MODULE ": unable to read `%s'",
+				       scratch);
+				return PAM_AUTH_ERR;
+			}
+			if (!S_ISDIR(st.st_mode)) {
+				syslog(LOG_ERR,
+				       MODULE ": `%s' is not a directory",
+				       scratch);
+				return PAM_AUTH_ERR;
+			}
+			if (S_ISLNK(st.st_mode)) {
+				syslog(LOG_ERR,
+				       MODULE ": `%s' is a symbolic link",
+				       scratch);
+				return PAM_AUTH_ERR;
+			}
+			if (st.st_uid != 0) {
+				syslog(LOG_ERR,
+				       MODULE ": `%s' owner UID != 0",
+				       scratch);
+				return PAM_AUTH_ERR;
+			}
+			if (st.st_gid != 0) {
+				syslog(LOG_ERR,
+				       MODULE ": `%s' owner GID != 0",
+				       scratch);
+				return PAM_AUTH_ERR;
+			}
+			if ((st.st_mode & (S_IWGRP | S_IWOTH)) != 0) {
+				syslog(LOG_ERR,
+				       MODULE ": `%s' permissions are lax",
+				       scratch);
+				return PAM_AUTH_ERR;
+			}
+		}
+	}
+	return PAM_SUCCESS;
+}
+
+/* Validate a tty pathname as actually belonging to a tty, and return its base
+ * name if it's valid. */
+static const char *
+check_tty(const char *tty)
+{
+	/* Check that we're not being set up to take a fall. */
+	if ((tty == NULL) || (strlen(tty) == 0)) {
+		return NULL;
+	}
+	/* Pull out the meaningful part of the tty's name. */
+	if (strchr(tty, '/') != NULL) {
+		if (strncmp(tty, "/dev/", 5) != 0) {
+			/* Make sure the device node is actually in /dev/,
+			 * noted by Michal Zalewski. */
+			return NULL;
+		}
+		tty = strrchr(tty, '/') + 1;
+	}
+	/* Make sure the tty wasn't actually a directory (no basename). */
+	if (strlen(tty) == 0) {
+		return NULL;
+	}
+	return tty;
+}
+
+/* Determine the right path name for a given user's timestamp. */
+static int
+format_timestamp_name(char *path, size_t len,
+		      const char *timestamp_dir,
+		      const char *tty,
+		      const char *ruser,
+		      const char *user)
+{
+	if (strcmp(ruser, user) == 0) {
+		return snprintf(path, len, "%s/%s/%s", timestamp_dir,
+				ruser, tty);
+	} else {
+		return snprintf(path, len, "%s/%s/%s:%s", timestamp_dir,
+				ruser, tty, user);
+	}
+}
+
+/* Check if a given timestamp date, when compared to a current time, fits
+ * within the given interval. */
+static int
+timestamp_good(time_t then, time_t now, time_t interval)
+{
+	if (((now >= then) && ((now - then) < interval)) ||
+	    ((now < then) && ((then - now) < (2 * interval)))) {
+		return PAM_SUCCESS;
+	}
+	return PAM_AUTH_ERR;
+}
+
+#ifndef PAM_TIMESTAMP_MAIN
+/* Get the path to the timestamp to use. */
+static int
+get_timestamp_name(pam_handle_t *pamh, int argc, const char **argv,
+		   char *path, size_t len)
+{
+	const char *user, *ruser, *tty;
+	const char *tdir = TIMESTAMPDIR;
+	char scratch[BUFLEN];
+	struct passwd *pwd;
+	int i, debug = 0;
+
+	/* Parse arguments. */
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug = 1;
+		}
+	}
+	for (i = 0; i < argc; i++) {
+		if (strncmp(argv[i], "timestampdir=", 13) == 0) {
+			tdir = argv[i] + 13;
+			if (debug) {
+				syslog(LOG_DEBUG,
+				       MODULE ": storing timestamps in `%s'",
+				       tdir);
+			}
+		}
+	}
+	i = check_dir_perms(tdir);
+	if (i != PAM_SUCCESS) {
+		return i;
+	}
+	/* Get the name of the target user. */
+	if (pam_get_item(pamh, PAM_USER, (const void**)&user) != PAM_SUCCESS) {
+		user = NULL;
+	}
+	if ((user == NULL) || (strlen(user) == 0)) {
+		return PAM_AUTH_ERR;
+	}
+	if (debug) {
+		syslog(LOG_DEBUG, MODULE ": becoming user `%s'", user);
+	}
+	/* Get the name of the source user. */
+	if (pam_get_item(pamh, PAM_RUSER, (const void**)&ruser) != PAM_SUCCESS) {
+		ruser = NULL;
+	}
+	if ((ruser == NULL) || (strlen(ruser) == 0)) {
+		/* Barring that, use the current RUID. */
+		pwd = _pammodutil_getpwuid(pamh, getuid());
+		if (pwd != NULL) {
+			if (strlen(pwd->pw_name) < sizeof(scratch)) {
+				strncpy(scratch, pwd->pw_name, sizeof(scratch));
+				scratch[sizeof(scratch) - 1] = '\0';
+				ruser = scratch;
+			}
+		}
+	}
+	if ((ruser == NULL) || (strlen(ruser) == 0)) {
+		return PAM_AUTH_ERR;
+	}
+	if (debug) {
+		syslog(LOG_DEBUG, MODULE ": currently user `%s'", ruser);
+	}
+	/* Get the name of the terminal. */
+	if (pam_get_item(pamh, PAM_TTY, (const void**)&tty) != PAM_SUCCESS) {
+		tty = NULL;
+	}
+	if ((tty == NULL) || (strlen(tty) == 0)) {
+		tty = ttyname(STDIN_FILENO);
+		if ((tty == NULL) || (strlen(tty) == 0)) {
+			tty = ttyname(STDOUT_FILENO);
+		}
+		if ((tty == NULL) || (strlen(tty) == 0)) {
+			tty = ttyname(STDERR_FILENO);
+		}
+		if ((tty == NULL) || (strlen(tty) == 0)) {
+			/* Match sudo's behavior for this case. */
+			tty = "unknown";
+		}
+	}
+	if (debug) {
+		syslog(LOG_DEBUG, MODULE ": tty is `%s'", tty);
+	}
+	/* Snip off all but the last part of the tty name. */
+	tty = check_tty(tty);
+	if (tty == NULL) {
+		return PAM_AUTH_ERR;
+	}
+	/* Generate the name of the file used to cache auth results.  These
+	 * paths should jive with sudo's per-tty naming scheme. */
+	if (format_timestamp_name(path, len, tdir, tty, ruser, user) >= len) {
+		return PAM_AUTH_ERR;
+	}
+	if (debug) {
+		syslog(LOG_DEBUG, MODULE ": using timestamp file `%s'", path);
+	}
+	return PAM_SUCCESS;
+}
+
+/* Tell the user that access has been granted. */
+static void
+verbose_success(pam_handle_t *pamh, int debug, int diff)
+{
+	struct pam_conv *conv;
+	char text[BUFLEN];
+	struct pam_message message;
+	const struct pam_message *messages[] = {&message};
+	struct pam_response *responses;
+	if (pam_get_item(pamh, PAM_CONV, (const void**) &conv) == PAM_SUCCESS) {
+		if (conv->conv != NULL) {
+			memset(&message, 0, sizeof(message));
+			message.msg_style = PAM_TEXT_INFO;
+			snprintf(text, sizeof(text),
+				 "Access granted (last access was %d "
+				 "seconds ago).", diff);
+			message.msg = text;
+			syslog(LOG_DEBUG, MODULE ": %s", message.msg);
+			conv->conv(1, messages, &responses, conv->appdata_ptr);
+		} else {
+			syslog(LOG_DEBUG, MODULE ": bogus conversation function");
+		}
+	} else {
+		syslog(LOG_DEBUG, MODULE ": no conversation function");
+	}
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	struct stat st;
+	time_t interval = DEFAULT_TIMESTAMP_TIMEOUT;
+	int i, fd, debug = 0, verbose = 0;
+	char path[BUFLEN], *p, *message, *message_end;
+	long tmp;
+	const char *service = "(unknown)";
+	time_t now, then;
+
+	/* Parse arguments. */
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug = 1;
+		}
+	}
+	for (i = 0; i < argc; i++) {
+		if (strncmp(argv[i], "timestamp_timeout=", 18) == 0) {
+			tmp = strtol(argv[i] + 18, &p, 0);
+			if ((p != NULL) && (*p == '\0')) {
+				interval = tmp;
+				if (debug) {
+					syslog(LOG_DEBUG,
+					       MODULE ": setting timeout to %ld"
+					       " seconds", (long)interval);
+				}
+			}
+		} else
+		if (strcmp(argv[i], "verbose") == 0) {
+			verbose = 1;
+			if (debug) {
+				syslog(LOG_DEBUG,
+				       MODULE ": becoming more verbose");
+			}
+		}
+	}
+
+	/* Get the name of the timestamp file. */
+	if (get_timestamp_name(pamh, argc, argv,
+			       path, sizeof(path)) != PAM_SUCCESS) {
+		return PAM_AUTH_ERR;
+	}
+
+	/* Get the name of the service. */
+	if (pam_get_item(pamh, PAM_SERVICE, (const void**)&service) != PAM_SUCCESS) {
+		service = NULL;
+	}
+	if ((service == NULL) || (strlen(service) == 0)) {
+		service = "(unknown)";
+	}
+
+	/* Open the timestamp file. */
+	fd = open(path, O_RDONLY | O_NOFOLLOW);
+	if (fd == -1) {
+		if (debug) {
+			syslog(LOG_DEBUG,
+			       MODULE ": cannot open timestamp `%s': %s",
+			       path, strerror(errno));
+		}
+		return PAM_AUTH_ERR;
+	}
+
+	if (fstat(fd, &st) == 0) {
+		int count;
+		char *mac;
+		size_t maclen;
+
+		/* Check that the file is owned by the superuser. */
+		if ((st.st_uid != 0) || (st.st_gid != 0)) {
+			syslog(LOG_ERR, MODULE ": timestamp file `%s' is "
+			       "not owned by root", path);
+			close(fd);
+			return PAM_AUTH_ERR;
+		}
+
+		/* Check that the file is a normal file. */
+		if (!(S_ISREG(st.st_mode))) {
+			syslog(LOG_ERR, MODULE ": timestamp file `%s' is "
+			       "not a regular file", path);
+			close(fd);
+			return PAM_AUTH_ERR;
+		}
+
+		/* Check that the file is the expected size. */
+		if (st.st_size == 0) {
+			/* Invalid, but may have been created by sudo. */
+			close(fd);
+			return PAM_AUTH_ERR;
+		}
+		if (st.st_size !=
+		    strlen(path) + 1 + sizeof(then) + hmac_sha1_size()) {
+			syslog(LOG_NOTICE, MODULE ": timestamp file `%s' "
+			       "appears to be corrupted", path);
+			close(fd);
+			return PAM_AUTH_ERR;
+		}
+
+		/* Read the file contents. */
+		message = malloc(st.st_size);
+		count = 0;
+		while (count < st.st_size) {
+			i = read(fd, message + count, st.st_size - count);
+			if ((i == 0) || (i == -1)) {
+				break;
+			}
+			count += i;
+		}
+		if (count < st.st_size) {
+			syslog(LOG_NOTICE, MODULE ": error reading timestamp "
+				"file `%s'", path);
+			close(fd);
+			return PAM_AUTH_ERR;
+		}
+		message_end = message + strlen(path) + 1 + sizeof(then);
+
+		/* Regenerate the MAC. */
+		hmac_sha1_generate_file(&mac, &maclen, TIMESTAMPKEY, 0, 0,
+					message, message_end - message);
+		if ((mac == NULL) ||
+		    (memcmp(path, message, strlen(path)) != 0) ||
+		    (memcmp(mac, message_end, maclen) != 0)) {
+			syslog(LOG_NOTICE, MODULE ": timestamp file `%s' is "
+				"corrupted", path);
+			close(fd);
+			return PAM_AUTH_ERR;
+		}
+		free(mac);
+		memmove(&then, message + strlen(path) + 1, sizeof(then));
+		free(message);
+
+		/* Compare the dates. */
+		now = time(NULL);
+		if (timestamp_good(then, now, interval) == PAM_SUCCESS) {
+			syslog(LOG_NOTICE, MODULE ": timestamp file `%s' is "
+			       "only %ld seconds old, allowing access to %s "
+			       "for UID %ld", path, (long) (now - st.st_mtime),
+			       service, (long)getuid());
+			if (verbose) {
+				verbose_success(pamh, debug, now - st.st_mtime);
+			}
+			return PAM_SUCCESS;
+		} else {
+			syslog(LOG_NOTICE, MODULE ": timestamp file `%s' has "
+			       "unacceptable age (%ld seconds), disallowing "
+			       "access to %s for UID %ld",
+			       path, (long) (now - st.st_mtime),
+			       service, (long)getuid());
+			return PAM_AUTH_ERR;
+		}
+	}
+	close(fd);
+
+	/* Fail by default. */
+	return PAM_AUTH_ERR;
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return PAM_SUCCESS;
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	char path[BUFLEN], subdir[BUFLEN], *mac, *text, *p;
+	size_t maclen;
+	time_t now;
+	int fd, i, debug = 0;
+
+	/* Parse arguments. */
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug = 1;
+		}
+	}
+
+	/* Get the name of the timestamp file. */
+	if (get_timestamp_name(pamh, argc, argv,
+			       path, sizeof(path)) != PAM_SUCCESS) {
+		return PAM_SESSION_ERR;
+	}
+
+	/* Create the directory for the timestamp file if it doesn't already
+	 * exist. */
+	for (i = 1; path[i] != '\0'; i++) {
+		if (path[i] == '/') {
+			/* Attempt to create the directory. */
+			strncpy(subdir, path, i);
+			subdir[i] = '\0';
+			if (mkdir(subdir, 0700) == 0) {
+				/* Attempt to set the owner to the superuser. */
+				lchown(subdir, 0, 0);
+			} else {
+				if (errno != EEXIST) {
+					if (debug) {
+						syslog(LOG_DEBUG,
+						       MODULE ": error creating"
+						       " directory `%s': %s",
+						       subdir, strerror(errno));
+					}
+					return PAM_SESSION_ERR;
+				}
+			}
+		}
+	}
+
+	/* Generate the message. */
+	text = malloc(strlen(path) + 1 + sizeof(now) + hmac_sha1_size());
+	if (text == NULL) {
+		syslog(LOG_ERR, MODULE ": unable to allocate memory: %m");
+		return PAM_SESSION_ERR;
+	}
+	p = text;
+
+	strcpy(text, path);
+	p += strlen(path) + 1;
+
+	now = time(NULL);
+	memmove(p, &now, sizeof(now));
+	p += sizeof(now);
+
+	/* Generate the MAC and append it to the plaintext. */
+	hmac_sha1_generate_file(&mac, &maclen,
+				TIMESTAMPKEY,
+				0, 0,
+				text, p - text);
+	if (mac == NULL) {
+		syslog(LOG_ERR, MODULE ": failure generating MAC: %m");
+		free(text);
+		return PAM_SESSION_ERR;
+	}
+	memmove(p, mac, maclen);
+	p += maclen;
+	free(mac);
+
+	/* Open the file. */
+	fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+	if (fd == -1) {
+		syslog(LOG_ERR, MODULE ": unable to open `%s': %m", path);
+		free(text);
+		return PAM_SESSION_ERR;
+	}
+
+	/* Attempt to set the owner to the superuser. */
+	fchown(fd, 0, 0);
+
+	/* Write the timestamp to the file. */
+	if (write(fd, text, p - text) != p - text) {
+		syslog(LOG_ERR, MODULE ": unable to write to `%s': %m", path);
+		close(fd);
+		free(text);
+		return PAM_SESSION_ERR;
+	}
+
+	/* Close the file and return successfully. */
+	close(fd);
+	free(text);
+	syslog(LOG_DEBUG, MODULE ": updated timestamp file `%s'", path);
+	return PAM_SUCCESS;
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	return PAM_SUCCESS;
+}
+
+#else /* PAM_TIMESTAMP_MAIN */
+
+#define USAGE "Usage: %s [[-k] | [-d]] [target user]\n"
+#define CHECK_INTERVAL 5
+
+int
+main(int argc, char **argv)
+{
+	int i, pretval = -1, retval = 0, dflag = 0, kflag = 0;
+	const char *target_user = NULL, *user = NULL, *tty = NULL;
+	struct passwd *pwd;
+	struct timeval tv;
+	fd_set write_fds;
+	char path[BUFLEN];
+	struct stat st;
+
+	/* Check that there's nothing funny going on with stdio. */
+	if ((fstat(STDIN_FILENO, &st) == -1) ||
+	    (fstat(STDOUT_FILENO, &st) == -1) ||
+	    (fstat(STDERR_FILENO, &st) == -1)) {
+		/* Appropriate the "no controlling tty" error code. */
+		return 3;
+	}
+
+	/* Parse arguments. */
+	while ((i = getopt(argc, argv, "dk")) != -1) {
+		switch (i) {
+			case 'd':
+				dflag++;
+				break;
+			case 'k':
+				kflag++;
+				break;
+			default:
+				fprintf(stderr, USAGE, argv[0]);
+				return 1;
+				break;
+		}
+	}
+
+	/* Bail if both -k and -d are given together. */
+	if ((kflag + dflag) > 1) {
+		fprintf(stderr, USAGE, argv[0]);
+		return 1;
+	}
+
+	/* Check that we're setuid. */
+	if (geteuid() != 0) {
+		fprintf(stderr, "%s must be setuid root\n",
+			argv[0]);
+		retval = 2;
+	}
+
+	/* Check that we have a controlling tty. */
+	tty = ttyname(STDIN_FILENO);
+	if ((tty == NULL) || (strlen(tty) == 0)) {
+		tty = ttyname(STDOUT_FILENO);
+	}
+	if ((tty == NULL) || (strlen(tty) == 0)) {
+		tty = ttyname(STDERR_FILENO);
+	}
+	if ((tty == NULL) || (strlen(tty) == 0)) {
+		tty = "unknown";
+	}
+
+	/* Get the name of the invoking (requesting) user. */
+	pwd = getpwuid(getuid());
+	if (pwd == NULL) {
+		retval = 4;
+	}
+
+	/* Get the name of the target user. */
+	user = strdup(pwd->pw_name);
+	if (user == NULL) {
+		retval = 4;
+	} else {
+		target_user = (optind < argc) ? argv[optind] : user;
+		if ((strchr(target_user, '.') != NULL) ||
+		    (strchr(target_user, '/') != NULL) ||
+		    (strchr(target_user, '%') != NULL)) {
+			fprintf(stderr, "unknown user: %s\n",
+				target_user);
+			retval = 4;
+		}
+	}
+
+	/* Sanity check the tty to make sure we should be checking
+	 * for timestamps which pertain to it. */
+	if (retval == 0) {
+		tty = check_tty(tty);
+		if (tty == NULL) {
+			fprintf(stderr, "invalid tty\n");
+			retval = 6;
+		}
+	}
+
+	do {
+		/* Sanity check the timestamp directory itself. */
+		if (retval == 0) {
+			if (check_dir_perms(TIMESTAMPDIR) != PAM_SUCCESS) {
+				retval = 5;
+			}
+		}
+
+		if (retval == 0) {
+			/* Generate the name of the timestamp file. */
+			format_timestamp_name(path, sizeof(path), TIMESTAMPDIR,
+					      tty, user, target_user);
+		}
+
+		if (retval == 0) {
+			if (kflag) {
+				/* Remove the timestamp. */
+				if (lstat(path, &st) != -1) {
+					retval = unlink(path);
+				}
+			} else {
+				/* Check the timestamp. */
+				if (lstat(path, &st) != -1) {
+					if (!timestamp_good(st.st_mtime, time(NULL),
+							    DEFAULT_TIMESTAMP_TIMEOUT) == PAM_SUCCESS) {
+						retval = 7;
+					}
+				} else {
+					retval = 7;
+				}
+			}
+		}
+
+		if (dflag > 0) {
+			/* Send the would-be-returned value to our parent. */
+			signal(SIGPIPE, SIG_DFL);
+			fprintf(stdout, "%d\n", retval);
+			fflush(stdout);
+			/* Wait. */
+			tv.tv_sec = CHECK_INTERVAL;
+			tv.tv_usec = 0;
+			FD_ZERO(&write_fds);
+			FD_SET(STDOUT_FILENO, &write_fds);
+			select(STDOUT_FILENO + 1,
+			       NULL, NULL, &write_fds,
+			       &tv);
+			pretval = retval;
+			retval = 0;
+		}
+	} while (dflag > 0);
+
+	return retval;
+}
+
+#endif
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp_check.8 Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp_check.8
--- Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp_check.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp_check.8	2003-06-25 00:38:05.000000000 +0300
@@ -0,0 +1,51 @@
+.TH pam_timestamp_check 8 2002/05/23 "Red Hat Linux" "System Administrator's Manual"
+.SH NAME
+pam_timestamp_check \- check or clear authentication timestamps
+.SH SYNOPSIS
+.B pam_timestamp_check [[-d]|[-k]] [target_user]
+.br
+
+.SH DESCRIPTION
+With no arguments,
+.B pam_timestamp_check
+will check to see if the default timestamp is valid, or optionally remove it.
+
+.SH OPTIONS
+.IP -k
+instead of checking the validity of a timestamp, remove it.  This is analogous
+to sudo's
+.B -k
+option.
+.IP -d
+Instead of returning validity using an exit status, loop indefinitely,
+polling regularly and printing the status on standard output.
+.IP target_user
+The default behavior of
+.B pam_timestamp_check
+checks or removes timestamps generated by
+.B pam_timestamp
+when the user authenticates as herself.  When the user authenticates as a
+different user, the name of the timestamp file changes to accomodate this.
+
+.SH DIAGNOSTICS
+When checking if a timestamp is valid,
+.B pam_timestamp_check
+returns an exit code of 0 for success and > 0 on error:
+
+.nf
+2: binary is not setuid-root
+3: invalid invocation
+4: user unknown
+5: permissions error
+6: invalid controlling tty
+7: other error
+.fi
+
+.SH SEE ALSO
+pam_timestamp(8)
+
+.SH BUGS
+Let's hope not, but if you find any, please email the author.  
+
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp_check.c Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp_check.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/pam_timestamp_check.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/pam_timestamp_check.c	2002-05-24 02:11:07.000000000 +0300
@@ -0,0 +1,42 @@
+/******************************************************************************
+ * A module for Linux-PAM that will cache authentication results, inspired by
+ * (and implemented with an eye toward being mixable with) sudo.
+ *
+ * Copyright (c) 2002 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define PAM_TIMESTAMP_MAIN 1
+#include "pam_timestamp.c"
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/README Linux-PAM-0.77/modules/pam_timestamp/README
--- Linux-PAM-0.77.orig/modules/pam_timestamp/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/README	2003-07-03 04:54:15.000000000 +0300
@@ -0,0 +1,32 @@
+This is pam_timestamp, a module for implementing sudo-style authentication
+timestamps via PAM.
+
+Background:  sudo [1] provides a means for allowing certain users (by name,
+or by group membership) to execute a fixed set of commands under a different
+UID (even root).  Additionally, sudo adds the concept of timestamp files,
+which will allow a user to use commands via sudo, without needing to reenter
+her password, within a short period after a previous command was run.
+
+The authentication service function checks for the existence and validity of
+the timestamp file, and if a valid timestamp file exists which is less than
+timestamp_timeout seconds old, succeeds.
+
+The session management service creates or updates the timestamp file.  This
+means that in order for a service to use this module, it must perform PAM
+session management.
+
+The module takes these arguments:
+	debug			Log debug messages (with priority DEBUG) to
+				syslog.
+	timestampdir		The directory in which timestamp files will be
+				stored and checked for.  The default setting is
+				"/var/run/sudo".
+	timestamp_timeout	The number of seconds which can pass after its
+				creation during which a timestamp is file is
+				considered to be valid.  The default setting,
+				which mirrors sudo's, is 600 (five minutes).
+	verbose			Attempt to tell the user when access is granted.
+
+Nalin Dahyabhai <nalin@redhat.com>
+
+[1] http://www.courtesan.com/sudo/
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/sha1.c Linux-PAM-0.77/modules/pam_timestamp/sha1.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/sha1.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/sha1.c	2003-07-03 02:37:02.000000000 +0300
@@ -0,0 +1,254 @@
+/* Yet another SHA-1 implementation.
+ *
+ * Copyright (c) 2003 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* See http://www.itl.nist.gov/fipspubs/fip180-1.htm for descriptions. */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <endian.h>
+#include <unistd.h>
+#include "sha1.h"
+
+static unsigned char
+padding[SHA1_BLOCK_SIZE] = {
+	0x80, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+	   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+	   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+	   0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+};
+
+static u_int32_t
+F(u_int32_t b, u_int32_t c, u_int32_t d)
+{
+	return (b & c) | ((~b) & d);
+}
+
+static u_int32_t
+G(u_int32_t b, u_int32_t c, u_int32_t d)
+{
+	return b ^ c ^ d;
+}
+
+static u_int32_t
+H(u_int32_t b, u_int32_t c, u_int32_t d)
+{
+	return (b & c) | (b & d) | (c & d);
+}
+
+static u_int32_t
+RL(u_int32_t n, u_int32_t s)
+{
+	return (n << s) | (n >> (32 - s));
+}
+
+static u_int32_t
+round(u_int32_t (*FUNC)(u_int32_t, u_int32_t, u_int32_t),
+      u_int32_t a, u_int32_t b, u_int32_t c, u_int32_t d, u_int32_t e,
+      u_int32_t i, u_int32_t n)
+{
+	return RL(a, 5) + FUNC(b, c, d) + e + i + n;
+}
+
+void
+sha1_init(struct sha1_context *ctx)
+{
+	memset(ctx, 0, sizeof(*ctx));
+	ctx->a = 0x67452301;
+	ctx->b = 0xefcdab89;
+	ctx->c = 0x98badcfe;
+	ctx->d = 0x10325476;
+	ctx->e = 0xc3d2e1f0;
+}
+
+static void
+sha1_process(struct sha1_context *ctx, u_int32_t buffer[SHA1_BLOCK_SIZE / 4])
+{
+	u_int32_t a, b, c, d, e, temp;
+	u_int32_t data[80];
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		data[i] = htonl(buffer[i]);
+	}
+	for (i = 16; i < 80; i++) {
+		data[i] = RL(data[i - 3] ^ data[i - 8] ^ data[i - 14] ^ data[i - 16], 1);
+	}
+
+	a = ctx->a;
+	b = ctx->b;
+	c = ctx->c;
+	d = ctx->d;
+	e = ctx->e;
+
+	for (i =  0; i < 20; i++) {
+		temp = round(F, a, b, c, d, e, data[i], 0x5a827999);
+		e = d; d = c; c = RL(b, 30); b = a; a = temp;
+	}
+	for (i = 20; i < 40; i++) {
+		temp = round(G, a, b, c, d, e, data[i], 0x6ed9eba1);
+		e = d; d = c; c = RL(b, 30); b = a; a = temp;
+	}
+	for (i = 40; i < 60; i++) {
+		temp = round(H, a, b, c, d, e, data[i], 0x8f1bbcdc);
+		e = d; d = c; c = RL(b, 30); b = a; a = temp;
+	}
+	for (i = 60; i < 80; i++) {
+		temp = round(G, a, b, c, d, e, data[i], 0xca62c1d6);
+		e = d; d = c; c = RL(b, 30); b = a; a = temp;
+	}
+
+	ctx->a += a;
+	ctx->b += b;
+	ctx->c += c;
+	ctx->d += d;
+	ctx->e += e;
+
+	memset(buffer, 0, sizeof(buffer));
+	memset(data, 0, sizeof(data));
+}
+
+void
+sha1_update(struct sha1_context *ctx, const unsigned char *data, size_t length)
+{
+	size_t i = 0, l = length, c, t;
+	u_int32_t count = 0;
+
+	/* Process any pending + data blocks. */
+	while (l + ctx->pending_count >= SHA1_BLOCK_SIZE) {
+		c = ctx->pending_count;
+		t = SHA1_BLOCK_SIZE - c;
+		memcpy(ctx->pending + c, &data[i], t);
+		sha1_process(ctx, (u_int32_t*) ctx->pending);
+		i += t;
+		l -= t;
+		ctx->pending_count = 0;
+	}
+
+	/* Save what's left of the data block as a pending data block. */
+	c = ctx->pending_count;
+	memcpy(ctx->pending + c, &data[i], l);
+	ctx->pending_count += l;
+
+	/* Update the message length. */
+	ctx->count += length;
+
+	/* Update our internal counts. */
+	if (length != 0) {
+		count = ctx->counts[0];
+		ctx->counts[0] += length;
+		if (count >= ctx->counts[0]) {
+			ctx->counts[1]++;
+		}
+	}
+}
+
+size_t
+sha1_output(struct sha1_context *ctx, unsigned char *out)
+{
+	struct sha1_context ctx2;
+	
+	/* Output the sum. */
+	if (out != NULL) {
+		u_int32_t c;
+		memcpy(&ctx2, ctx, sizeof(ctx2));
+
+		/* Pad this block. */
+		c = ctx2.pending_count;
+		memcpy(ctx2.pending + c,
+		       padding, SHA1_BLOCK_SIZE - c);
+
+		/* Do we need to process two blocks now? */
+		if (c >= (SHA1_BLOCK_SIZE - (sizeof(u_int32_t) * 2))) {
+			/* Process this block. */
+			sha1_process(&ctx2,
+				    (u_int32_t*) ctx2.pending);
+			/* Set up another block. */
+			ctx2.pending_count = 0;
+			memset(ctx2.pending, 0, SHA1_BLOCK_SIZE);
+                        ctx2.pending[0] =
+				(c == SHA1_BLOCK_SIZE) ? 0x80 : 0;
+		}
+
+		/* Process the final block. */
+		ctx2.counts[1] <<= 3;
+		if (ctx2.counts[0] >> 29) {
+			ctx2.counts[1] |=
+			(ctx2.counts[0] >> 29);
+		}
+		ctx2.counts[0] <<= 3;
+		ctx2.counts[0] = htonl(ctx2.counts[0]);
+		ctx2.counts[1] = htonl(ctx2.counts[1]);
+		memcpy(ctx2.pending + 56,
+		       &ctx2.counts[1], sizeof(u_int32_t));
+		memcpy(ctx2.pending + 60,
+		       &ctx2.counts[0], sizeof(u_int32_t));
+		sha1_process(&ctx2, (u_int32_t*) ctx2.pending);
+
+		/* Output the data. */
+		out[ 3] = (ctx2.a >>  0) & 0xff;
+		out[ 2] = (ctx2.a >>  8) & 0xff;
+		out[ 1] = (ctx2.a >> 16) & 0xff;
+		out[ 0] = (ctx2.a >> 24) & 0xff;
+
+		out[ 7] = (ctx2.b >>  0) & 0xff;
+		out[ 6] = (ctx2.b >>  8) & 0xff;
+		out[ 5] = (ctx2.b >> 16) & 0xff;
+		out[ 4] = (ctx2.b >> 24) & 0xff;
+
+		out[11] = (ctx2.c >>  0) & 0xff;
+		out[10] = (ctx2.c >>  8) & 0xff;
+		out[ 9] = (ctx2.c >> 16) & 0xff;
+		out[ 8] = (ctx2.c >> 24) & 0xff;
+
+		out[15] = (ctx2.d >>  0) & 0xff;
+		out[14] = (ctx2.d >>  8) & 0xff;
+		out[13] = (ctx2.d >> 16) & 0xff;
+		out[12] = (ctx2.d >> 24) & 0xff;
+
+		out[19] = (ctx2.e >>  0) & 0xff;
+		out[18] = (ctx2.e >>  8) & 0xff;
+		out[17] = (ctx2.e >> 16) & 0xff;
+		out[16] = (ctx2.e >> 24) & 0xff;
+	}
+
+	return SHA1_OUTPUT_SIZE;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/sha1.h Linux-PAM-0.77/modules/pam_timestamp/sha1.h
--- Linux-PAM-0.77.orig/modules/pam_timestamp/sha1.h	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/sha1.h	2003-07-03 02:37:02.000000000 +0300
@@ -0,0 +1,60 @@
+/* Yet another SHA-1 implementation.
+ *
+ * Copyright (c) 2003 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef pam_timestamp_sha1_h
+#define pam_timestamp_sha1_h
+
+#include <sys/types.h>
+
+#define SHA1_BLOCK_SIZE 64
+
+struct sha1_context {
+	size_t count;
+	unsigned char pending[SHA1_BLOCK_SIZE];
+	u_int32_t counts[2];
+	size_t pending_count;
+	u_int32_t a, b, c, d, e;
+};
+
+#define SHA1_OUTPUT_SIZE 20
+
+void sha1_init(struct sha1_context *ctx);
+void sha1_update(struct sha1_context *ctx,
+		 const unsigned char *data, size_t length);
+size_t sha1_output(struct sha1_context *ctx, unsigned char *out);
+
+#endif
diff -Nur Linux-PAM-0.77.orig/modules/pam_timestamp/sha1sum.c Linux-PAM-0.77/modules/pam_timestamp/sha1sum.c
--- Linux-PAM-0.77.orig/modules/pam_timestamp/sha1sum.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_timestamp/sha1sum.c	2003-07-03 02:37:02.000000000 +0300
@@ -0,0 +1,72 @@
+/* Yet another sha1sum implementation.  This one doesn't know how to check
+ * sha1sum files, though.  Use the version which comes with coreutils for that.
+ *
+ * Copyright (c) 2003 Red Hat, Inc.
+ * Written by Nalin Dahyabhai <nalin@redhat.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <unistd.h>
+#include "sha1.h"
+int
+main(int argc, char **argv)
+{
+	char buf[109], output[SHA1_OUTPUT_SIZE];
+	int fd, i, j, count;
+	struct sha1_context sha1;
+
+	for (i = 1; i < argc; i++) {
+		fd = open(argv[i], O_RDONLY);
+		if (fd != -1) {
+			sha1_init(&sha1);
+			do {
+				count = read(fd, buf, sizeof(buf));
+				if ((count != 0) && (count != -1)) {
+					sha1_update(&sha1, buf, count);
+				}
+			} while (count != 0);
+			sha1_output(&sha1, output);
+			for (j = 0; j < sizeof(output); j++) {
+				printf("%02x", output[j] & 0xff);
+			}
+			printf("  %s\n", argv[i]);
+			close(fd);
+		}
+	}
+	return 0;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_xauth/Makefile Linux-PAM-0.77/modules/pam_xauth/Makefile
--- Linux-PAM-0.77.orig/modules/pam_xauth/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_xauth/Makefile	2001-01-05 02:14:42.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# This Makefile controls a build process of $(TITLE) module for
+# Linux-PAM. You should not modify this Makefile (unless you know
+# what you are doing!).
+#
+
+include ../../Make.Rules
+
+TITLE=pam_xauth
+MAN8=pam_xauth.8
+
+include ../Simple.Rules
diff -Nur Linux-PAM-0.77.orig/modules/pam_xauth/pam_xauth.8 Linux-PAM-0.77/modules/pam_xauth/pam_xauth.8
--- Linux-PAM-0.77.orig/modules/pam_xauth/pam_xauth.8	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_xauth/pam_xauth.8	2003-07-24 22:21:50.000000000 +0300
@@ -0,0 +1,82 @@
+.\" Copyright 2001,2003 Red Hat, Inc.
+.\" Written by Nalin Dahyabhai <nalin@redhat.com>, based on the original
+.\" version by Michael K. Johnson
+.TH pam_xauth 8 2003/7/24 "Red Hat Linux" "System Administrator's Manual"
+.SH NAME
+pam_xauth \- forward xauth keys between users
+.SH SYNOPSIS
+.B session optional /lib/security/pam_xauth.so \fIarguments\fP
+.SH DESCRIPTION
+pam_xauth.so is designed to forward xauth keys (sometimes referred
+to as "cookies") between users.
+
+Without pam_xauth, when xauth is enabled and a user uses the \fBsu\fP command
+to assume another user's priviledges, that user is no longer able to access
+the original user's X display because the new user does not have the key
+needed to access the display.  pam_xauth solves the problem by forwarding the
+key from the user running su (the source user) to the user whose
+identity the source user is assuming (the target user) when the session
+is created, and destroying the key when the session is torn down.
+
+This means, for example, that when you run \fBsu\fP from an xterm sesssion,
+you will be able to run X programs without explicitly dealing with the
+xauth command or ~/.Xauthority files.
+
+pam_xauth will only forward keys if xauth can list a key connected
+to the $DISPLAY environment variable.
+
+Primitive access control is provided by \fB~/.xauth/export\fP in the invoking
+user's home directory and \fB~/.xauth/import\fP in the target user's home
+directory.
+
+If a user has a \fB~/.xauth/import\fP file, the user will only receive cookies
+from users listed in the file.  If there is no \fB~/.xauth/import\fP file,
+the user will accept cookies from any other user.
+
+If a user has a \fB.xauth/export\fP file, the user will only forward cookies
+to users listed in the file.  If there is no \fB~/.xauth/export\fP file, and
+the invoking user is not \fBroot\fP, the user will forward cookies to
+any other user.  If there is no \fB~/.xauth/export\fP file, and the invoking
+user is \fBroot\fP, the user will \fInot\fP forward cookies to other users.
+
+Both the import and export files support wildcards (such as \fI*\fP).  Both
+the import and export files can be empty, signifying that no users are allowed.
+
+.SH ARGUMENTS
+.IP debug
+Turns on debugging messages sent to syslog.
+.IP xauthpath=\fI/usr/X11R6/bin/xauth\fP
+Specify the path the xauth program (the default is /usr/X11R6/bin/xauth).
+.IP systemuser=\fInumber\fP
+Specify the highest UID which will be assumed to belong to a "system" user.
+pam_xauth will refuse to forward credentials to users with UID less than or
+equal to this number, except for root and the "targetuser", if specified.
+.IP targetuser=\fInumber\fP
+Specify a single target UID which is exempt from the systemuser check.
+.SH "IMPLEMENTATION DETAILS"
+pam_xauth will work \fIonly\fP if it is used from a setuid application
+in which the getuid() call returns the id of the user running the
+application, and for which PAM can supply the name of the account that
+the user is attempting to assume.  The typical application of this
+type is \fBsu\fP.  The application must call both pam_open_session() and
+pam_close_session() with the ruid set to the uid of the calling user
+and the euid set to root, and must have provided as the PAM_USER item
+the name of the target user.
+
+pam_xauth calls \fBxauth\fP as the source user to extract the key for
+$DISPLAY, then calls xauth as the target user to merge the key
+into the a temporary database and later remove the database.
+
+pam_xauth cannot be told not to remove the keys when the session
+is closed.
+.SH "SEE ALSO"
+\fI/usr/share/doc/pam*/html/index.html\fP
+.SH FILES
+\fI~/.xauth/import\fP
+\fI~/.xauth/export\fP
+.SH BUGS
+Let's hope not, but if you find any, please report them via the "Bug Track"
+link at http://bugzilla.redhat.com/bugzilla/
+.SH AUTHOR
+Nalin Dahyabhai <nalin@redhat.com>, based on original version by
+Michael K. Johnson <johnsonm@redhat.com>
diff -Nur Linux-PAM-0.77.orig/modules/pam_xauth/pam_xauth.c Linux-PAM-0.77/modules/pam_xauth/pam_xauth.c
--- Linux-PAM-0.77.orig/modules/pam_xauth/pam_xauth.c	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_xauth/pam_xauth.c	2003-10-22 21:58:11.000000000 +0300
@@ -0,0 +1,621 @@
+/*
+ * Copyright 2001-2003 Red Hat, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ident "$Id: pam_xauth.c,v 1.23 2003/10/22 18:58:11 nalin Exp $"
+
+#include "../../_pam_aconf.h"
+#include <sys/types.h>
+#include <sys/fsuid.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <fnmatch.h>
+#include <grp.h>
+#include <limits.h>
+#include <netdb.h>
+#include <pwd.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#include <security/pam_modules.h>
+#include <security/_pam_macros.h>
+#include <security/_pam_modutil.h>
+
+#define DATANAME "pam_xauth_cookie_file"
+#define XAUTHBIN "/usr/X11R6/bin/xauth"
+#define XAUTHENV "XAUTHORITY"
+#define HOMEENV  "HOME"
+#define XAUTHDEF ".Xauthority"
+#define XAUTHTMP ".xauthXXXXXX"
+
+/* Run a given command (with a NULL-terminated argument list), feeding it the
+ * given input on stdin, and storing any output it generates. */
+static int
+run_coprocess(const char *input, char **output,
+	      uid_t uid, gid_t gid, const char *command, ...)
+{
+	int ipipe[2], opipe[2], i;
+	char buf[LINE_MAX];
+	pid_t child;
+	char *buffer = NULL;
+	size_t buffer_size = 0;
+	va_list ap;
+
+	*output = NULL;
+
+	/* Create stdio pipery. */
+	if (pipe(ipipe) == -1) {
+		return -1;
+	}
+	if (pipe(opipe) == -1) {
+		close(ipipe[0]);
+		close(ipipe[1]);
+		return -1;
+	}
+
+	/* Fork off a child. */
+	child = fork();
+	if (child == -1) {
+		close(ipipe[0]);
+		close(ipipe[1]);
+		close(opipe[0]);
+		close(opipe[1]);
+		return -1;
+	}
+
+	if (child == 0) {
+		/* We're the child. */
+		char *args[10];
+		const char *tmp;
+		/* Drop privileges. */
+		setgid(gid);
+		setgroups(0, NULL);
+		setuid(uid);
+		/* Initialize the argument list. */
+		memset(&args, 0, sizeof(args));
+		/* Set the pipe descriptors up as stdin and stdout, and close
+		 * everything else, including the original values for the
+		 * descriptors. */
+		dup2(ipipe[0], STDIN_FILENO);
+		dup2(opipe[1], STDOUT_FILENO);
+		for (i = 0; i < sysconf(_SC_OPEN_MAX); i++) {
+			if ((i != STDIN_FILENO) && (i != STDOUT_FILENO)) {
+				close(i);
+			}
+		}
+		/* Convert the varargs list into a regular array of strings. */
+		va_start(ap, command);
+		args[0] = strdup(command);
+		for (i = 1; i < ((sizeof(args) / sizeof(args[0])) - 1); i++) {
+			tmp = va_arg(ap, const char*);
+			if (tmp == NULL) {
+				break;
+			}
+			args[i] = strdup(tmp);
+		}
+		/* Run the command. */
+		execvp(command, args);
+		/* Never reached. */
+		exit(1);
+	}
+
+	/* We're the parent, so close the other ends of the pipes. */
+	close(ipipe[0]);
+	close(opipe[1]);
+	/* Send input to the process (if we have any), then send an EOF. */
+	if (input) {
+		write(ipipe[1], input, strlen(input));
+	}
+	close(ipipe[1]);
+
+	/* Read data output until we run out of stuff to read. */
+	i = read(opipe[0], buf, sizeof(buf));
+	while ((i != 0) && (i != -1)) {
+		char *tmp;
+		/* Resize the buffer to hold the data. */
+		tmp = realloc(buffer, buffer_size + i + 1);
+		if (tmp == NULL) {
+			/* Uh-oh, bail. */
+			if (buffer != NULL) {
+				free(buffer);
+			}
+			close(opipe[0]);
+			waitpid(child, NULL, 0);
+			return -1;
+		}
+		/* Save the new buffer location, copy the newly-read data into
+		 * the buffer, and make sure the result will be
+		 * nul-terminated. */
+		buffer = tmp;
+		memcpy(buffer + buffer_size, buf, i);
+		buffer[buffer_size + i] = '\0';
+		buffer_size += i;
+		/* Try to read again. */
+		i = read(opipe[0], buf, sizeof(buf));
+	}
+	/* No more data.  Clean up and return data. */
+	close(opipe[0]);
+	*output = buffer;
+	waitpid(child, NULL, 0);
+	return 0;
+}
+
+/* Free a data item. */
+static void
+cleanup(pam_handle_t *pamh, void *data, int err)
+{
+	free(data);
+}
+
+/* Check if we want to allow export to the other user, or import from the
+ * other user. */
+static int
+check_acl(pam_handle_t *pamh,
+	  const char *sense, const char *this_user, const char *other_user,
+	  int noent_code, int debug)
+{
+	char path[PATH_MAX];
+	struct passwd *pwd;
+	FILE *fp;
+	int i;
+	uid_t euid;
+	/* Check this user's <sense> file. */
+	pwd = _pammodutil_getpwnam(pamh, this_user);
+	if (pwd == NULL) {
+		syslog(LOG_ERR, "pam_xauth: error determining "
+		       "home directory for '%s'", this_user);
+		return PAM_SESSION_ERR;
+	}
+	/* Figure out what that file is really named. */
+	i = snprintf(path, sizeof(path), "%s/.xauth/%s", pwd->pw_dir, sense);
+	if ((i >= sizeof(path)) || (i < 0)) {
+		syslog(LOG_ERR, "pam_xauth: name of user's home directory "
+		       "is too long");
+		return PAM_SESSION_ERR;
+	}
+	euid = geteuid();
+	setfsuid(pwd->pw_uid);
+	fp = fopen(path, "r");
+	setfsuid(euid);
+	if (fp != NULL) {
+		char buf[LINE_MAX], *tmp;
+		/* Scan the file for a list of specs of users to "trust". */
+		while (fgets(buf, sizeof(buf), fp) != NULL) {
+			tmp = memchr(buf, '\r', sizeof(buf));
+			if (tmp != NULL) {
+				*tmp = '\0';
+			}
+			tmp = memchr(buf, '\n', sizeof(buf));
+			if (tmp != NULL) {
+				*tmp = '\0';
+			}
+			if (fnmatch(buf, other_user, 0) == 0) {
+				if (debug) {
+					syslog(LOG_DEBUG, "pam_xauth: %s %s "
+					       "allowed by %s",
+					       other_user, sense, path);
+				}
+				fclose(fp);
+				return PAM_SUCCESS;
+			}
+		}
+		/* If there's no match in the file, we fail. */
+		if (debug) {
+			syslog(LOG_DEBUG, "pam_xauth: %s not listed in %s",
+			       other_user, path);
+		}
+		fclose(fp);
+		return PAM_PERM_DENIED;
+	} else {
+		/* Default to okay if the file doesn't exist. */
+		switch (errno) {
+		case ENOENT:
+			if (noent_code == PAM_SUCCESS) {
+				if (debug) {
+					syslog(LOG_DEBUG, "%s does not exist, "
+					       "ignoring", path);
+				}
+			} else {
+				if (debug) {
+					syslog(LOG_DEBUG, "%s does not exist, "
+					       "failing", path);
+				}
+			}
+			return noent_code;
+		default:
+			if (debug) {
+				syslog(LOG_ERR, "%s opening %s",
+				       strerror(errno), path);
+			}
+			return PAM_PERM_DENIED;
+		}
+	}
+}
+
+int
+pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	char xauthpath[] = XAUTHBIN;
+	char *cookiefile = NULL, *xauthority = NULL,
+	     *cookie = NULL, *display = NULL, *tmp = NULL;
+	const char *user, *xauth = xauthpath;
+	struct passwd *tpwd, *rpwd;
+	int fd, i, debug = 0;
+	uid_t systemuser = 499, targetuser = 0, euid;
+
+	/* Parse arguments.  We don't understand many, so no sense in breaking
+	 * this into a separate function. */
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug = 1;
+			continue;
+		}
+		if (strncmp(argv[i], "xauthpath=", 10) == 0) {
+			xauth = argv[i] + 10;
+			continue;
+		}
+		if (strncmp(argv[i], "targetuser=", 11) == 0) {
+			long l = strtol(argv[i] + 11, &tmp, 10);
+			if ((strlen(argv[i] + 11) > 0) && (*tmp == '\0')) {
+				targetuser = l;
+			} else {
+				syslog(LOG_WARNING, "pam_xauth: invalid value "
+				       "for targetuser (`%s')", argv[i] + 11);
+			}
+			continue;
+		}
+		if (strncmp(argv[i], "systemuser=", 11) == 0) {
+			long l = strtol(argv[i] + 11, &tmp, 10);
+			if ((strlen(argv[i] + 11) > 0) && (*tmp == '\0')) {
+				systemuser = l;
+			} else {
+				syslog(LOG_WARNING, "pam_xauth: invalid value "
+				       "for systemuser (`%s')", argv[i] + 11);
+			}
+			continue;
+		}
+		syslog(LOG_WARNING, "pam_xauth: unrecognized option `%s'",
+		       argv[i]);
+	}
+
+	/* If DISPLAY isn't set, we don't really care, now do we? */
+	if ((display = getenv("DISPLAY")) == NULL) {
+		if (debug) {
+			syslog(LOG_DEBUG, "pam_xauth: user has no DISPLAY,"
+			       " doing nothing");
+		}
+		return PAM_SUCCESS;
+	}
+
+	/* Read the target user's name. */
+	if (pam_get_item(pamh, PAM_USER, (const void**)&user) != PAM_SUCCESS) {
+		syslog(LOG_ERR, "pam_xauth: error determining target "
+		       "user's name");
+		return PAM_SESSION_ERR;
+	}
+	rpwd = _pammodutil_getpwuid(pamh, getuid());
+	if (rpwd == NULL) {
+		syslog(LOG_ERR, "pam_xauth: error determining invoking "
+		       "user's name");
+		return PAM_SESSION_ERR;
+	}
+
+	/* Get the target user's UID and primary GID, which we'll need to set
+	 * on the xauthority file we create later on. */
+	tpwd = _pammodutil_getpwnam(pamh, user);
+	if (tpwd == NULL) {
+		syslog(LOG_ERR, "pam_xauth: error determining target "
+		       "user's UID");
+		return PAM_SESSION_ERR;
+	}
+
+	if (debug) {
+		syslog(LOG_DEBUG, "pam_xauth: requesting user %lu/%lu, "
+		       "target user %lu/%lu",
+		       (unsigned long) rpwd->pw_uid,
+		       (unsigned long) rpwd->pw_gid,
+		       (unsigned long) tpwd->pw_uid,
+		       (unsigned long) tpwd->pw_gid);
+	}
+
+	/* If the UID is a system account (and not the superuser), forget
+	 * about forwarding keys. */
+	if ((tpwd->pw_uid != 0) &&
+	    (tpwd->pw_uid != targetuser) &&
+	    (tpwd->pw_uid <= systemuser)) {
+		if (debug) {
+			syslog(LOG_DEBUG, "pam_xauth: not forwarding cookies "
+			       "to user ID %ld", (long) tpwd->pw_uid);
+		}
+		return PAM_SESSION_ERR;
+	}
+
+	/* Check that both users are amenable to this.  By default, this
+	 * boils down to this policy:
+	 * export(ruser=root): only if <user> is listed in .xauth/export
+	 * export(ruser=*) if <user> is listed in .xauth/export, or
+	 *                 if .xauth/export does not exist
+	 * import(user=*): if <ruser> is listed in .xauth/import, or
+	 *                 if .xauth/import does not exist */
+	i = (getuid() != 0) ? PAM_SUCCESS : PAM_PERM_DENIED;
+	i = check_acl(pamh, "export", rpwd->pw_name, user, i, debug);
+	if (i != PAM_SUCCESS) {
+		return PAM_SESSION_ERR;
+	}
+	i = PAM_SUCCESS;
+	i = check_acl(pamh, "import", user, rpwd->pw_name, i, debug);
+	if (i != PAM_SUCCESS) {
+		return PAM_SESSION_ERR;
+	}
+
+	/* Figure out where the source user's .Xauthority file is. */
+	if (getenv(XAUTHENV) != NULL) {
+		cookiefile = strdup(getenv(XAUTHENV));
+	} else {
+		cookiefile = malloc(strlen(rpwd->pw_dir) + 1 +
+				    strlen(XAUTHDEF) + 1);
+		if (cookiefile == NULL) {
+			return PAM_SESSION_ERR;
+		}
+		strcpy(cookiefile, rpwd->pw_dir);
+		strcat(cookiefile, "/");
+		strcat(cookiefile, XAUTHDEF);
+	}
+	if (debug) {
+		syslog(LOG_DEBUG, "pam_xauth: reading keys from `%s'",
+		       cookiefile);
+	}
+
+	/* Read the user's .Xauthority file.  Because the current UID is
+	 * the original user's UID, this will only fail if something has
+	 * gone wrong, or we have no cookies. */
+	if (debug) {
+		syslog(LOG_DEBUG, "pam_xauth: running \"%s %s %s %s %s\" as "
+		       "%lu/%lu",
+		       xauth,
+		       "-f",
+		       cookiefile,
+		       "nlist",
+		       display,
+		       (unsigned long) getuid(),
+		       (unsigned long) getgid());
+	}
+	if (run_coprocess(NULL, &cookie,
+			  getuid(), getgid(),
+			  xauth, "-f", cookiefile, "nlist", display,
+			  NULL) == 0) {
+		/* Check that we got a cookie.  If not, we get creative. */
+		if (((cookie == NULL) || (strlen(cookie) == 0)) &&
+		    ((strncmp(display, "localhost:", 10) == 0) ||
+		     (strncmp(display, "localhost/unix:", 15) == 0))) {
+			char *t, *screen;
+			size_t tlen, slen;
+			/* Free the useless cookie string. */
+			if (cookie != NULL) {
+				free(cookie);
+				cookie = NULL;
+			}
+			/* Allocate enough space to hold an adjusted name. */
+			tlen = strlen(display) + LINE_MAX + 1;
+			t = malloc(tlen);
+			if (t != NULL) {
+				memset(t, 0, tlen);
+				if (gethostname(t, tlen - 1) != -1) {
+					/* Append the protocol and then the
+					 * screen number. */
+					if (strlen(t) < tlen - 6) {
+						strcat(t, "/unix:");
+					}
+					screen = strchr(display, ':');
+					if (screen != NULL) {
+						screen++;
+						slen = strlen(screen);
+						if (strlen(t) + slen < tlen) {
+							strcat(t, screen);
+						}
+					}
+					if (debug) {
+						syslog(LOG_DEBUG, "pam_xauth: "
+						       "no key for `%s', trying"
+						       " `%s'", display, t);
+					}
+					/* Read the cookie for this display. */
+					if (debug) {
+						syslog(LOG_DEBUG,
+						       "pam_xauth: running "
+						       "\"%s %s %s %s %s\" as "
+						       "%lu/%lu",
+						       xauth,
+						       "-f",
+						       cookiefile,
+						       "nlist",
+						       t,
+						       (unsigned long) getuid(),
+						       (unsigned long) getgid());
+					}
+					run_coprocess(NULL, &cookie,
+						      getuid(), getgid(),
+						      xauth, "-f", cookiefile,
+						      "nlist", t, NULL);
+				}
+				free(t);
+				t = NULL;
+			}
+		}
+
+		/* Check that we got a cookie, this time for real. */
+		if ((cookie == NULL) || (strlen(cookie) == 0)) {
+			if (debug) {
+				syslog(LOG_DEBUG, "pam_xauth: no key");
+			}
+			return PAM_SESSION_ERR;
+		}
+
+		/* Generate the environment variable
+		 * "XAUTHORITY=<homedir>/filename". */
+		xauthority = malloc(strlen(XAUTHENV) + 1 +
+				    strlen(tpwd->pw_dir) + 1 +
+				    strlen(XAUTHTMP) + 1);
+		if (xauthority == NULL) {
+			if (debug) {
+				syslog(LOG_DEBUG, "pam_xauth: no free memory");
+			}
+			free(cookiefile);
+			free(cookie);
+			return PAM_SESSION_ERR;
+		}
+		strcpy(xauthority, XAUTHENV);
+		strcat(xauthority, "=");
+		strcat(xauthority, tpwd->pw_dir);
+		strcat(xauthority, "/");
+		strcat(xauthority, XAUTHTMP);
+
+		/* Generate a new file to hold the data. */
+		euid = geteuid();
+		setfsuid(tpwd->pw_uid);
+		fd = mkstemp(xauthority + strlen(XAUTHENV) + 1);
+		setfsuid(euid);
+		if (fd == -1) {
+			syslog(LOG_ERR, "pam_xauth: error creating "
+			       "temporary file `%s': %s",
+			       xauthority + strlen(XAUTHENV) + 1,
+			       strerror(errno));
+			free(cookiefile);
+			free(cookie);
+			free(xauthority);
+			return PAM_SESSION_ERR;
+		}
+		/* Set permissions on the new file and dispose of the
+		 * descriptor. */
+		fchown(fd, tpwd->pw_uid, tpwd->pw_gid);
+		close(fd);
+
+		/* Get a copy of the filename to save as a data item for
+		 * removal at session-close time. */
+		free(cookiefile);
+		cookiefile = strdup(xauthority + strlen(XAUTHENV) + 1);
+
+		/* Save the filename. */
+		if (pam_set_data(pamh, DATANAME, cookiefile, cleanup) != PAM_SUCCESS) {
+			syslog(LOG_ERR, "pam_xauth: error saving name of "
+			       "temporary file `%s'", cookiefile);
+			unlink(cookiefile);
+			free(xauthority);
+			free(cookiefile);
+			free(cookie);
+			return PAM_SESSION_ERR;
+		}
+
+		/* Unset any old XAUTHORITY variable in the environment. */
+		if (getenv(XAUTHENV)) {
+			unsetenv(XAUTHENV);
+		}
+
+		/* Set the new variable in the environment. */
+		pam_putenv(pamh, xauthority);
+		putenv(xauthority); /* The environment owns this string now. */
+
+		/* Merge the cookie we read before into the new file. */
+		if (debug) {
+			syslog(LOG_DEBUG, "pam_xauth: writing key `%s' to "
+			       "temporary file `%s'", cookie, cookiefile);
+		}
+		if (debug) {
+			syslog(LOG_DEBUG,
+			       "pam_xauth: running \"%s %s %s %s %s\" as "
+			       "%lu/%lu",
+			       xauth,
+			       "-f",
+			       cookiefile,
+			       "nmerge",
+			       "-",
+			       (unsigned long) tpwd->pw_uid,
+			       (unsigned long) tpwd->pw_gid);
+		}
+		run_coprocess(cookie, &tmp,
+			      tpwd->pw_uid, tpwd->pw_gid,
+			      xauth, "-f", cookiefile, "nmerge", "-", NULL);
+
+		/* We don't need to keep a copy of these around any more. */
+		free(cookie);
+		cookie = NULL;
+	}
+	return PAM_SUCCESS;
+}
+
+int
+pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
+{
+	void *cookiefile;
+	int i, debug = 0;
+
+	/* Parse arguments.  We don't understand many, so no sense in breaking
+	 * this into a separate function. */
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "debug") == 0) {
+			debug = 1;
+			continue;
+		}
+		if (strncmp(argv[i], "xauthpath=", 10) == 0) {
+			continue;
+		}
+		if (strncmp(argv[i], "systemuser=", 11) == 0) {
+			continue;
+		}
+		if (strncmp(argv[i], "targetuser=", 11) == 0) {
+			continue;
+		}
+		syslog(LOG_WARNING, "pam_xauth: unrecognized option `%s'",
+		       argv[i]);
+	}
+
+	/* Try to retrieve the name of a file we created when the session was
+	 * opened. */
+	if (pam_get_data(pamh, DATANAME, (const void**) &cookiefile) == PAM_SUCCESS) {
+		/* We'll only try to remove the file once. */
+		if (strlen((char*)cookiefile) > 0) {
+			if (debug) {
+				syslog(LOG_DEBUG, "pam_xauth: removing `%s'",
+				       (char*)cookiefile);
+			}
+			unlink((char*)cookiefile);
+			*((char*)cookiefile) = '\0';
+		}
+	}
+	return PAM_SUCCESS;
+}
diff -Nur Linux-PAM-0.77.orig/modules/pam_xauth/README Linux-PAM-0.77/modules/pam_xauth/README
--- Linux-PAM-0.77.orig/modules/pam_xauth/README	1970-01-01 02:00:00.000000000 +0200
+++ Linux-PAM-0.77/modules/pam_xauth/README	2003-07-24 22:21:50.000000000 +0300
@@ -0,0 +1,41 @@
+pam_xauth:
+	Forward xauth cookies from user to user, normally used by su, sudo, or
+	userhelper.
+
+	Primitive access control is provided by ~/.xauth/export in the invoking
+	user's home directory and ~/.xauth/import in the target user's home
+	directory.
+
+	If a user has a ~/.xauth/import file, the user will only receive cookies
+	from users listed in the file.  If there is no ~/.xauth/import file,
+	the user will accept cookies from any other user.
+
+	If a user has a .xauth/export file, the user will only forward cookies
+	to users listed in the file.  If there is no ~/.xauth/export file, and
+	the invoking user is not "root", the user will forward cookies to
+	any other user.  If there is no ~/.xauth/export file, and the invoking
+	user is "root", the user will NOT forward cookies to other users.
+
+	Both the import and export files support wildcards (such as "*").  Both
+	the import and export files can be empty, signifying that no users are
+	allowed.
+
+RECOGNIZED ARGUMENTS:
+	debug		write debugging messages to syslog
+	xauthpath=	the path to the xauth program, by default
+			/usr/X11R6/bin/xauth
+	systemuser=	highest user id assigned to system users, defaults
+			to 499 (pam_xauth will refuse to forward creds to
+			target users with id equal to or below this number,
+			except for root and possibly another specified user)
+	targetuser=	a target user id which is excepted from the systemuser
+			checks
+
+
+MODULE SERVICES PROVIDED:
+	session         open session copies xauth cookie to new user
+			close session deletes copied xauth cookie
+
+AUTHOR:
+	Nalin Dahyabhai <nalin@redhat.com>, based on original version by
+	Michael K. Johnson <johnsonm@redhat.com>
