diff -Nru parted-1.6.19/AUTHORS parted-1.6.19-hfs-16/AUTHORS
--- parted-1.6.19/AUTHORS	2004-06-13 08:35:11.000000000 +0200
+++ parted-1.6.19-hfs-16/AUTHORS	2004-12-03 15:26:11.345635000 +0100
@@ -149,3 +149,6 @@
 Giuseppe Sacco <eppesuig@debian.org>
 	* Italian translations
 
+Guillaume Knispel <k_guillaume@libertysurf.fr>
+	* nearly all hfs and hfs+ code (libparted/fs_hfs)
+	* hfs+ support for mac partitions (libparted/disk_mac.c)
diff -Nru parted-1.6.19/config.h.in parted-1.6.19-hfs-16/config.h.in
--- parted-1.6.19/config.h.in	2004-11-28 10:53:53.000000000 +0100
+++ parted-1.6.19-hfs-16/config.h.in	2004-11-28 10:53:53.000000000 +0100
@@ -96,6 +96,10 @@
 /* Define to 1 if you have the <wctype.h> header file. */
 #undef HAVE_WCTYPE_H
 
+/* Extract low level special HFS(+) files for debugging purposes when using
+   the "check" command (NOT FOR PACKAGING) */
+#undef HFS_EXTRACT_FS
+
 /* Name of package */
 #undef PACKAGE
 
diff -Nru parted-1.6.19/configure parted-1.6.19-hfs-16/configure
--- parted-1.6.19/configure	2004-11-28 10:53:38.000000000 +0100
+++ parted-1.6.19-hfs-16/configure	2004-11-28 10:53:38.000000000 +0100
@@ -1034,6 +1034,7 @@
   --enable-part-static     build partially static binaries default=no
   --enable-pc98          build with pc98 support default=yes
   --enable-Werror         build with gcc -Werror default=yes
+  --enable-hfs-extract-fs Extract special HFS files for debugging default=no
   --disable-dependency-tracking Speeds up one-time builds
   --enable-dependency-tracking  Do not reject slow dependency extractors
   --disable-largefile     omit support for large files
@@ -1167,7 +1168,7 @@
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -2157,6 +2158,22 @@
 
 fi;
 
+# Check whether --enable-hfs-extract-fs or --disable-hfs-extract-fs was given.
+if test "${enable_hfs_extract_fs+set}" = set; then
+  enableval="$enable_hfs_extract_fs"
+
+else
+  enable_hfs_extract_fs=no
+
+fi;
+if test "$enable_hfs_extract_fs" = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HFS_EXTRACT_FS 1
+_ACEOF
+
+fi
+
 CFLAGS="$CFLAGS -D_REENTRANT"
 
 rm -f .deps 2>/dev/null
@@ -2800,7 +2817,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2858,7 +2876,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2974,7 +2993,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3028,7 +3048,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3073,7 +3094,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3117,7 +3139,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3265,7 +3288,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3663,7 +3687,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3721,7 +3746,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3837,7 +3863,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3891,7 +3918,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3936,7 +3964,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3980,7 +4009,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4439,7 +4469,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4468,7 +4499,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4538,7 +4570,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4590,7 +4623,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4661,7 +4695,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4713,7 +4748,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4786,7 +4822,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4853,7 +4890,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4898,7 +4936,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4959,7 +4998,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5004,7 +5044,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5073,7 +5114,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5104,8 +5146,10 @@
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -5749,7 +5793,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 5752 "configure"' > conftest.$ac_ext
+  echo '#line 5796 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -5869,7 +5913,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -5943,7 +5988,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6113,7 +6159,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6180,7 +6227,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6440,7 +6488,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6498,7 +6547,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6569,7 +6619,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6613,7 +6664,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7038,7 +7090,7 @@
 
 
 # Provide some information about the compiler.
-echo "$as_me:7041:" \
+echo "$as_me:7093:" \
      "checking for Fortran 77 compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
@@ -7084,7 +7136,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7133,7 +7186,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8070,11 +8124,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8073: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8127: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8077: \$? = $ac_status" >&5
+   echo "$as_me:8131: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -8303,11 +8357,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8306: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8360: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8310: \$? = $ac_status" >&5
+   echo "$as_me:8364: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -8363,11 +8417,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8366: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8420: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8370: \$? = $ac_status" >&5
+   echo "$as_me:8424: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -8755,7 +8809,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8815,7 +8870,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10018,7 +10074,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10121,7 +10178,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10186,7 +10244,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10279,7 +10338,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10344,7 +10404,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10410,7 +10471,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10476,7 +10538,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10551,7 +10614,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 10554 "configure"
+#line 10617 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10649,7 +10712,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 10652 "configure"
+#line 10715 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11721,7 +11784,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -11782,7 +11846,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -12826,11 +12891,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:12829: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:12894: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:12833: \$? = $ac_status" >&5
+   echo "$as_me:12898: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -12886,11 +12951,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:12889: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:12954: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:12893: \$? = $ac_status" >&5
+   echo "$as_me:12958: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -13722,7 +13787,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13825,7 +13891,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13890,7 +13957,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -13983,7 +14051,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14048,7 +14117,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14114,7 +14184,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14180,7 +14251,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -14255,7 +14327,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 14258 "configure"
+#line 14330 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -14353,7 +14425,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 14356 "configure"
+#line 14428 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15180,11 +15252,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15183: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15255: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:15187: \$? = $ac_status" >&5
+   echo "$as_me:15259: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -15240,11 +15312,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15243: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15315: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:15247: \$? = $ac_status" >&5
+   echo "$as_me:15319: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -15622,7 +15694,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -15672,7 +15745,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_f77_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_f77_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -17285,11 +17359,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17288: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17362: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17292: \$? = $ac_status" >&5
+   echo "$as_me:17366: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -17518,11 +17592,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17521: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17595: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17525: \$? = $ac_status" >&5
+   echo "$as_me:17599: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
@@ -17578,11 +17652,11 @@
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17581: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17655: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17585: \$? = $ac_status" >&5
+   echo "$as_me:17659: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -17970,7 +18044,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -18030,7 +18105,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19233,7 +19309,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19336,7 +19413,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19401,7 +19479,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19494,7 +19573,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19559,7 +19639,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19625,7 +19706,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19691,7 +19773,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -19766,7 +19849,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 19769 "configure"
+#line 19852 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -19864,7 +19947,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 19867 "configure"
+#line 19950 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -21807,7 +21890,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21898,7 +21982,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -21948,7 +22033,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22414,7 +22500,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22468,7 +22555,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22661,7 +22749,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22744,7 +22833,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22838,7 +22928,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22903,7 +22994,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -22976,7 +23068,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23058,7 +23151,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23112,7 +23206,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23211,7 +23306,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23309,7 +23405,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23391,7 +23488,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23465,7 +23563,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23541,7 +23640,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23703,7 +23803,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23850,7 +23951,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -23996,7 +24098,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24167,7 +24270,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24318,7 +24422,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24486,7 +24591,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24528,7 +24634,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24585,7 +24692,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24751,7 +24859,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -24857,7 +24966,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -25805,6 +25915,11 @@
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -25843,12 +25958,6 @@
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
diff -Nru parted-1.6.19/configure.in parted-1.6.19-hfs-16/configure.in
--- parted-1.6.19/configure.in	2004-11-28 10:53:21.000000000 +0100
+++ parted-1.6.19-hfs-16/configure.in	2004-11-28 10:53:21.000000000 +0100
@@ -152,6 +152,16 @@
 	enable_Werror=yes
 )
 
+AC_ARG_ENABLE(hfs-extract-fs,
+	[  --enable-hfs-extract-fs Extract special HFS files for debugging [default=no]], ,
+	enable_hfs_extract_fs=no
+)
+if test "$enable_hfs_extract_fs" = yes; then
+       AC_DEFINE(HFS_EXTRACT_FS, 1,
+                 [Extract low level special HFS(+) files for debugging purposes
+                  when using the "check" command (NOT FOR PACKAGING)])
+fi
+
 dnl make libc threadsafe (not required for us, but useful other users of
 dnl libparted)
 CFLAGS="$CFLAGS -D_REENTRANT"
diff -Nru parted-1.6.19/debug/test/test parted-1.6.19-hfs-16/debug/test/test
--- parted-1.6.19/debug/test/test	2004-06-13 08:35:11.000000000 +0200
+++ parted-1.6.19-hfs-16/debug/test/test	2004-12-03 15:29:12.996020000 +0100
@@ -135,7 +135,7 @@
 			return 0
 		fi
 
-		if ( echo >> test_out ; $post_command 2>&1 >> test_out ); then
+		if ( echo >> test_out ; ( eval $post_command ) 2>&1 >> test_out ); then
 			return 1
 		else
 			return 0
diff -Nru parted-1.6.19/debug/test/test_fs_hfs parted-1.6.19-hfs-16/debug/test/test_fs_hfs
--- parted-1.6.19/debug/test/test_fs_hfs	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/debug/test/test_fs_hfs	2004-12-03 15:29:27.132871000 +0100
@@ -0,0 +1,91 @@
+#!/bin/bash
+# fsck_hfs seems to be broken : it doesn't even succeed in scanning a freshly
+# created by newfs_hfs partition.
+
+do_diff()
+{
+	mount "${TEST_DRIVE}1" $TEST_MOUNT_POINT -t $FILE_SYSTEM > /dev/null
+
+	if diff -rq $1 $2 --exclude lost+found >> test_log; then
+		ped_test_ok
+	else
+		ped_test_failed
+	fi
+
+	umount $TEST_MOUNT_POINT 2>&1 > /dev/null
+}
+
+do_test_diff()
+{
+	ped_testing "$1"
+	if ped_test_get_val "$4" "$5" "$6"; then
+		ped_test_failed
+		return 1
+	fi
+	do_diff "$2" "$3"
+}
+
+
+test_newfs_hfs()
+{
+# -h option for newfs_hfs makes it use legacy HFS (not Plus)
+# -dfn for fsck_hfs means Debug, Force, No
+# Debug => print more informations
+# Force => force check even if clean bit is set
+# No => don't modify the F.S.
+	ped_test "mkpart && newfs_hfs && fsck_hfs"\
+		"mklabel $TEST_FS_USE_DISK_LABEL\
+		 mkpart primary $FILE_SYSTEM 1 $DEFAULT_END"\
+		"newfs_hfs -h -v \"PED HFS TEST\" ${TEST_DRIVE}1"
+# &&\
+#		 fsck_hfs -dfn ${TEST_DRIVE}1"
+}
+
+prepare_resize_tests()
+{
+	part_num=1
+	part=$TEST_DRIVE$part_num
+	hole_parent=`echo $TEST_DATA_HOLE | sed -e "s/[-_.a-zA-Z0-9]+\///g"`
+	
+	umount $TEST_MOUNT_POINT 2>&1 > /dev/null
+	
+	mount $part $TEST_MOUNT_POINT -t $FILE_SYSTEM \
+	&& cp $TEST_DATA/* $TEST_MOUNT_POINT -r \
+	&& cp -r $TEST_DATA $TEST_MOUNT_POINT/tmp_copy \
+	&& rm -rf $TEST_MOUNT_POINT/$TEST_DATA_HOLE \
+	&& mv $TEST_MOUNT_POINT/tmp_copy/$TEST_DATA_HOLE \
+	      $TEST_MOUNT_POINT/$hole_parent \
+	&& rm -rf $TEST_MOUNT_POINT/tmp_copy
+
+	umount $TEST_MOUNT_POINT 2>&1 > /dev/null
+}
+
+test_resize_move_end_backward()
+{
+# -dfn for fsck_hfs means Debug, Force, No
+# Debug => print more informations
+# Force => force check even if clean bit is set
+# No => don't modify the F.S.
+	do_test_diff "resize: move end backward"\
+		$TEST_DATA $TEST_MOUNT_POINT \
+		"resize 1 1 $RESIZE_END"\
+		""
+#fsck_hfs -dfn ${TEST_DRIVE}1 2>&1"
+}
+
+main()
+{
+	export DEFAULT_END=250
+	export RESIZE_END=200
+	export FILE_SYSTEM=hfs
+
+	if ! test_newfs_hfs; then
+		return 1
+	fi
+	
+	prepare_resize_tests
+	test_resize_move_end_backward
+}
+
+main
+
diff -Nru parted-1.6.19/debug/test/test_fs_hfsplus parted-1.6.19-hfs-16/debug/test/test_fs_hfsplus
--- parted-1.6.19/debug/test/test_fs_hfsplus	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/debug/test/test_fs_hfsplus	2004-12-03 15:29:27.133871000 +0100
@@ -0,0 +1,95 @@
+#!/bin/bash
+# fsck_hfs seems to be broken : it doesn't even succeed in scanning a freshly
+# created by newfs_hfs partition.
+# update : retry with my newfs_hfs that round file system size down to 4 ko
+
+do_diff()
+{
+	mount "${TEST_DRIVE}1" $TEST_MOUNT_POINT -t $FILE_SYSTEM > /dev/null
+
+	if diff -rq $1 $2 --exclude lost+found >> test_log; then
+		ped_test_ok
+	else
+		ped_test_failed
+	fi
+
+	umount $TEST_MOUNT_POINT 2>&1 > /dev/null
+}
+
+do_test_diff()
+{
+	ped_testing "$1"
+	if ped_test_get_val "$4" "$5" "$6"; then
+		ped_test_failed
+		return 1
+	fi
+	do_diff "$2" "$3"
+}
+
+
+test_newfs_hfs()
+{
+# -w option for newfs_hfs adds an HFS wrapper around the HFS+ F.S.
+# update : don't use -w yet because it doesn't works well
+# it seems that the wrapper bad block file is stored differently by 
+# newfs_hfs than by mac os X install format program
+# -dfn for fsck_hfs means Debug, Force, No
+# Debug => print more informations
+# Force => force check even if clean bit is set
+# No => don't modify the F.S.
+	ped_test "mkpart && newfs_hfs && fsck_hfs"\
+		"mklabel $TEST_FS_USE_DISK_LABEL\
+		 mkpart primary $FILE_SYSTEM 1 $DEFAULT_END"\
+		"newfs_hfs -v \"PED HFS TEST\" ${TEST_DRIVE}1"
+# &&\
+#		 fsck_hfs -dfn ${TEST_DRIVE}1"
+}
+
+prepare_resize_tests()
+{
+	part_num=1
+	part=$TEST_DRIVE$part_num
+	hole_parent=`echo $TEST_DATA_HOLE | sed -e "s/[-_.a-zA-Z0-9]+\///g"`
+	
+	umount $TEST_MOUNT_POINT 2>&1 > /dev/null
+	
+	mount $part $TEST_MOUNT_POINT -t $FILE_SYSTEM \
+	&& cp $TEST_DATA/* $TEST_MOUNT_POINT -r \
+	&& cp -r $TEST_DATA $TEST_MOUNT_POINT/tmp_copy \
+	&& rm -rf $TEST_MOUNT_POINT/$TEST_DATA_HOLE \
+	&& mv $TEST_MOUNT_POINT/tmp_copy/$TEST_DATA_HOLE \
+	      $TEST_MOUNT_POINT/$hole_parent \
+	&& rm -rf $TEST_MOUNT_POINT/tmp_copy
+
+	umount $TEST_MOUNT_POINT 2>&1 > /dev/null
+}
+
+test_resize_move_end_backward()
+{
+# -dfn for fsck_hfs means Debug, Force, No
+# Debug => print more informations
+# Force => force check even if clean bit is set
+# No => don't modify the F.S.
+	do_test_diff "resize: move end backward"\
+		$TEST_DATA $TEST_MOUNT_POINT \
+		"resize 1 1 $RESIZE_END"\
+		""
+#fsck_hfs -dfn ${TEST_DRIVE}1 2>&1"
+}
+
+main()
+{
+	export DEFAULT_END=250
+	export RESIZE_END=200
+	export FILE_SYSTEM=hfsplus
+
+	if ! test_newfs_hfs; then
+		return 1
+	fi
+	
+	prepare_resize_tests
+	test_resize_move_end_backward
+}
+
+main
+
diff -Nru parted-1.6.19/libparted/disk_mac.c parted-1.6.19-hfs-16/libparted/disk_mac.c
--- parted-1.6.19/libparted/disk_mac.c	2004-11-20 08:09:52.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/disk_mac.c	2004-12-03 15:54:52.347003000 +0100
@@ -46,7 +46,8 @@
  *	Apple_Driver		device driver
  *	Apple_Driver43		SCSI Manager 4.3 device driver
  *	Apple_MFS		original Macintosh File System 
- *	Apple_HFS		Hierarchical File System
+ *	Apple_HFS		Hierarchical File System (and +)
+ *	Apple_HFSX		HFS+ with case sensitivity and more
  *	Apple_UNIX_SVR2		UNIX file system (UFS?)
  *	Apple_PRODOS		ProDOS file system 
  *	Apple_Free		unused space
@@ -1076,7 +1077,8 @@
 		return 1;
 	}
 
-	if (fs_type && !strcmp (fs_type->name, "hfs")) {
+	if (fs_type && (!strcmp (fs_type->name, "hfs")
+			|| !strcmp (fs_type->name, "hfs+"))) {
 		strcpy (mac_data->system_name, "Apple_HFS");
 		mac_data->status |= 0x7f;
 	} else {
diff -Nru parted-1.6.19/libparted/fs_hfs/advfs.c parted-1.6.19-hfs-16/libparted/fs_hfs/advfs.c
--- parted-1.6.19/libparted/fs_hfs/advfs.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/advfs.c	2004-12-03 15:31:45.144890000 +0100
@@ -0,0 +1,331 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+#include "file.h"
+
+#include "advfs.h"
+
+/* - if a < b, 0 if a == b, + if a > b */
+/* Comparaison is done in the following order : */
+/* CNID, then fork type, then start block */
+/* Note that HFS implementation in linux has a bug */
+/* in this function */
+static int
+hfs_extent_key_cmp(HfsPrivateGenericKey* a, HfsPrivateGenericKey* b)
+{
+	HfsExtentKey* key1 = (HfsExtentKey*) a;
+	HfsExtentKey* key2 = (HfsExtentKey*) b;
+
+	/* do NOT use a substraction, because */
+	/* 0xFFFFFFFF - 1 = 0xFFFFFFFE so this */
+	/* would return -2, despite the fact */
+	/* 0xFFFFFFFF > 1 !!! (this is the 2.4 bug) */
+	if (key1->file_ID != key2->file_ID)
+		return PED_BE32_TO_CPU(key1->file_ID) <
+		       PED_BE32_TO_CPU(key2->file_ID) ? 
+		       		-1 : +1;
+
+	if (key1->type != key2->type)
+		return (int)(key1->type - key2->type);
+
+	if (key1->start == key2->start)
+		return 0;
+	/* the whole thing wont work with 16 bits ints */
+	/* anyway */
+	return (int)( PED_BE16_TO_CPU(key1->start) - 
+	              PED_BE16_TO_CPU(key2->start) );
+}
+
+/* do a B-Tree lookup */
+/* read the first record immediatly inferior or egal to the given key */
+/* return 0 on error */
+/* record_out _must_ be large enough to receive record_size bytes */
+/* WARNING : the compare function called only handle Extents BTree */
+/*	     so modify this function if you want to do lookup in */
+/* 	     other BTrees has well */
+int
+hfs_btree_search (HfsPrivateFile* b_tree_file, HfsPrivateGenericKey* key,
+		  void *record_out, unsigned int record_size,
+		  HfsCPrivateLeafRec* record_ref)
+{
+	uint8_t			node[PED_SECTOR_SIZE];
+	HfsHeaderRecord*	header;
+	HfsNodeDescriptor*	desc = (HfsNodeDescriptor*) node;
+	HfsPrivateGenericKey*	record_key = NULL;
+	unsigned int		node_number, record_number;
+	int			i;
+	
+	/* Read the header node */
+	if (!hfs_file_read_sector(b_tree_file, node, 0))
+		return 0;
+	header = ((HfsHeaderRecord*) (node + PED_BE16_TO_CPU(*((uint16_t *)
+						(node+(PED_SECTOR_SIZE-2))))));
+
+	/* Get the node number of the root */
+	node_number = PED_BE32_TO_CPU(header->root_node);
+	if (!node_number)
+		return 0;
+	
+	/* Read the root node */
+	if (!hfs_file_read_sector(b_tree_file, node, node_number))
+		return 0;
+
+	/* Follow the white rabbit */
+	while (1) {
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = record_number; i; i--) {
+			record_key = (HfsPrivateGenericKey*)
+				(node + PED_BE16_TO_CPU(*((uint16_t *)
+					    (node+(PED_SECTOR_SIZE - 2*i)))));
+			/* check for obvious error in FS */
+			if (((uint8_t*)record_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)record_key - node
+			        >= PED_SECTOR_SIZE 
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				return 0;
+			}
+			if (hfs_extent_key_cmp(record_key, key) <= 0)
+				break;
+		}
+		if (!i) return 0;
+		if (desc->type == HFS_IDX_NODE) {
+			unsigned int 	skip;
+			
+			skip = (1 + record_key->key_length + 1) & ~1;
+			node_number = PED_BE32_TO_CPU (*((uint32_t *)
+					(((uint8_t *) record_key) + skip)));
+			if (!hfs_file_read_sector(b_tree_file, node,
+						  node_number))
+				return 0;
+		} else 
+			break;
+	}
+	
+	/* copy the result if needed */
+	if (record_size)
+		memcpy (record_out, record_key, record_size);
+	
+	/* send record reference if needed */
+	if (record_ref) {
+		record_ref->node_size = 1;	/* in sectors */
+		record_ref->node_number = node_number;
+		record_ref->record_pos = (uint8_t*)record_key - node;
+		record_ref->record_number = i;
+	}
+	
+	/* success */
+	return 1;
+}
+
+
+/* free the bad blocks linked list */
+void
+hfs_free_bad_blocks_list(HfsPrivateLinkExtent* first)
+{
+	HfsPrivateLinkExtent*	next;
+	
+	while (first) {
+		next = first->next;
+		ped_free (first);
+		first = next;
+	}
+}
+
+/* This function reads bad blocks extents in the extents file
+   and store it in f.s. specific data of fs */
+int
+hfs_read_bad_blocks (const PedFileSystem *fs)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+
+	if (priv_data->bad_blocks_loaded)
+		return 1;
+	
+	{
+	uint8_t			record[sizeof (HfsExtentKey) 
+					       + sizeof (HfsExtDataRec)];
+	HfsExtentKey		search;
+	HfsExtentKey*		ret_key = (HfsExtentKey*) record;
+	HfsExtDescriptor*	ret_cache = (HfsExtDescriptor*)
+					     (record + sizeof (HfsExtentKey));
+	unsigned int		block, last_start, first_pass = 1;
+
+	search.key_length = sizeof (HfsExtentKey) - 1;
+	search.type = HFS_DATA_FORK;
+	search.file_ID = PED_CPU_TO_BE32 (HFS_BAD_BLOCK_ID);
+
+	last_start = -1; block = 0;
+	while (1) {
+		int i;
+
+		search.start = PED_CPU_TO_BE16 (block);
+		if (!hfs_btree_search (priv_data->extent_file,
+				       (HfsPrivateGenericKey*) &search,
+				       record, sizeof (record), NULL)
+		    || ret_key->file_ID != search.file_ID
+		    || ret_key->type != search.type) {
+			if (first_pass)
+				break;
+			else
+				goto errbb;
+		}
+		if (PED_BE16_TO_CPU (ret_key->start) == last_start)
+		    break;
+
+		last_start = PED_BE16_TO_CPU (ret_key->start);
+		for (i = 0; i < HFS_EXT_NB; i++) {
+			if (ret_cache[i].block_count) {
+				HfsPrivateLinkExtent*	new_xt =
+				   (HfsPrivateLinkExtent*) ped_malloc (
+					sizeof (HfsPrivateLinkExtent));
+				if (!new_xt)
+					goto errbb;
+				new_xt->next = priv_data->bad_blocks_xtent_list;
+				memcpy(&(new_xt->extent), ret_cache+i,
+					sizeof (HfsExtDescriptor));
+				priv_data->bad_blocks_xtent_list = new_xt;
+				priv_data->bad_blocks_xtent_nb++;
+				block += PED_BE16_TO_CPU (
+						ret_cache[i].block_count);
+			}
+		}
+		first_pass = 0;
+	}
+
+	priv_data->bad_blocks_loaded = 1;
+	return 1;}
+
+errbb:	hfs_free_bad_blocks_list(priv_data->bad_blocks_xtent_list);
+	priv_data->bad_blocks_xtent_list=NULL;
+	priv_data->bad_blocks_xtent_nb=0;
+	return 0;
+}
+
+/* This function check if fblock is a bad block */
+int
+hfs_is_bad_block (const PedFileSystem *fs, unsigned int fblock)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsPrivateLinkExtent*	walk;
+	
+	for (walk = priv_data->bad_blocks_xtent_list; walk; walk = walk->next) {
+		/* Won't compile without the strange cast ! gcc bug ? */
+		/* or maybe C subtilties... */
+		if ((fblock >= PED_BE16_TO_CPU (walk->extent.start_block)) && 
+		    (fblock <  (unsigned int) (PED_BE16_TO_CPU (
+						    walk->extent.start_block)
+					       + PED_BE16_TO_CPU (
+						    walk->extent.block_count))))
+			return 1;
+	}
+	
+	return 0;
+}
+
+/* This function returns the first sector of the last free block of an
+   HFS volume we can get after a hfs_pack_free_space_from_block call */
+/* On error this function returns 0 */
+PedSector
+hfs_get_empty_end (const PedFileSystem *fs)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsMasterDirectoryBlock* mdb = priv_data->mdb;
+	HfsPrivateLinkExtent*	link;
+	unsigned int		block, last_bad, end_free_blocks;
+
+	/* find the next block to the last bad block of the volume */
+	if (!hfs_read_bad_blocks (fs))
+		return 0;
+
+	last_bad = 0;
+	for (link = priv_data->bad_blocks_xtent_list; link; link = link->next) {
+		if ((unsigned int) PED_BE16_TO_CPU (link->extent.start_block)
+		    + PED_BE16_TO_CPU (link->extent.block_count) > last_bad)
+			last_bad = PED_BE16_TO_CPU (link->extent.start_block)
+			           + PED_BE16_TO_CPU (link->extent.block_count);
+	}
+
+	/* Count the free blocks from last_bad to the end of the volume */
+	end_free_blocks = 0;
+	for (block = last_bad;
+	     block < PED_BE16_TO_CPU (mdb->total_blocks);
+	     block++) {
+		if (!TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+			end_free_blocks++;
+	}
+
+	/* Calculate the block that will by the first free at the
+	   end of the volume */
+	block = PED_BE16_TO_CPU (mdb->total_blocks) - end_free_blocks;
+
+	return (PedSector) PED_BE16_TO_CPU (mdb->start_block)
+		+ (PedSector) block * (PED_BE32_TO_CPU (mdb->block_size)
+				       / PED_SECTOR_SIZE);
+}
+
+/* return the block which should be used to pack data to have at
+   least free fblock blocks at the end of the volume */
+unsigned int
+hfs_find_start_pack (const PedFileSystem *fs, unsigned int fblock)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	unsigned int		block;
+
+	for (block = PED_BE16_TO_CPU (priv_data->mdb->total_blocks) - 1;
+	     block && fblock;
+	     block--) {
+		if (!TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+			fblock--;
+	}
+
+	while (block && !TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+		block--;
+	if (TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+		block++;
+
+	return block;
+}
+
+#endif /* !DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/advfs.h parted-1.6.19-hfs-16/libparted/fs_hfs/advfs.h
--- parted-1.6.19/libparted/fs_hfs/advfs.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/advfs.h	2004-12-03 15:31:45.145890000 +0100
@@ -0,0 +1,49 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _ADVFS_H
+#define _ADVFS_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+int
+hfs_btree_search (HfsPrivateFile* b_tree_file, HfsPrivateGenericKey* key,
+		  void *record_out, unsigned int record_size,
+		  HfsCPrivateLeafRec* record_ref);
+
+void
+hfs_free_bad_blocks_list(HfsPrivateLinkExtent* first);
+
+int
+hfs_read_bad_blocks (const PedFileSystem *fs);
+
+int
+hfs_is_bad_block (const PedFileSystem *fs, unsigned int fblock);
+
+PedSector
+hfs_get_empty_end (const PedFileSystem *fs);
+
+unsigned int
+hfs_find_start_pack (const PedFileSystem *fs, unsigned int fblock);
+
+#endif /* _ADVFS_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/advfs_plus.c parted-1.6.19-hfs-16/libparted/fs_hfs/advfs_plus.c
--- parted-1.6.19/libparted/fs_hfs/advfs_plus.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/advfs_plus.c	2004-12-03 15:31:45.146890000 +0100
@@ -0,0 +1,385 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+#include "advfs.h"
+#include "file_plus.h"
+
+#include "advfs_plus.h"
+
+/* - if a < b, 0 if a == b, + if a > b */
+/* Comparaison is done in the following order : */
+/* CNID, then fork type, then start block */
+static int
+hfsplus_extent_key_cmp(HfsPPrivateGenericKey* a, HfsPPrivateGenericKey* b)
+{
+	HfsPExtentKey* key1 = (HfsPExtentKey*) a;
+	HfsPExtentKey* key2 = (HfsPExtentKey*) b;
+
+	if (key1->file_ID != key2->file_ID)
+		return PED_BE32_TO_CPU(key1->file_ID) <
+		       PED_BE32_TO_CPU(key2->file_ID) ? 
+		       		-1 : +1;
+
+	if (key1->type != key2->type)
+		return (int)(key1->type - key2->type);
+
+	if (key1->start == key2->start)
+		return 0;
+	return PED_BE32_TO_CPU(key1->start) < 
+	       PED_BE32_TO_CPU(key2->start) ?
+	       		-1 : +1;
+}
+
+/* do a B-Tree lookup */
+/* read the first record immediatly inferior or egal to the given key */
+/* return 0 on error */
+/* record_out _must_ be large enough to receive the whole record (key + data) */
+/* WARNING : the search function called only handle Extents BTree */
+/*	     so modify this function if you want to do lookup in */
+/* 	     other BTrees has well */
+int
+hfsplus_btree_search (HfsPPrivateFile* b_tree_file, HfsPPrivateGenericKey* key,
+		      void *record_out, unsigned int record_size,
+		      HfsCPrivateLeafRec* record_ref)
+{
+	uint8_t			node_1[PED_SECTOR_SIZE];
+	uint8_t*		node;
+	HfsPHeaderRecord*	header;
+	HfsPNodeDescriptor*	desc = (HfsPNodeDescriptor*) node_1;
+	HfsPPrivateGenericKey*	record_key = NULL;
+	unsigned int		node_number, record_number, size, bsize;
+	int			i;
+	
+	/* Read the header node */
+	if (!hfsplus_file_read_sector(b_tree_file, node_1, 0))
+		return 0;
+	header = (HfsPHeaderRecord*) (node_1 + HFS_FIRST_REC);
+
+	/* Get the node number of the root */
+	node_number = PED_BE32_TO_CPU (header->root_node);
+	if (!node_number)
+		return 0;
+	
+	/* Get the size of a node in sectors and allocate buffer */
+	size = (bsize = PED_BE16_TO_CPU (header->node_size)) / PED_SECTOR_SIZE;
+	node = (uint8_t*) ped_malloc (bsize);
+	if (!node)
+		return 0;
+	desc = (HfsPNodeDescriptor*) node;
+	
+	/* Read the root node */
+	if (!hfsplus_file_read (b_tree_file, node,
+				(PedSector) node_number * size, size))
+		return 0;
+
+	/* Follow the white rabbit */
+	while (1) {
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = record_number; i; i--) {
+			record_key = (HfsPPrivateGenericKey*)
+			    (node + PED_BE16_TO_CPU(*((uint16_t *)
+					(node+(bsize - 2*i)))));
+			/* check for obvious error in FS */
+			if (((uint8_t*)record_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)record_key - node
+				>= (signed)bsize
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				ped_free (node);
+				return 0;
+			}
+			if (hfsplus_extent_key_cmp(record_key, key) <= 0)
+				break;
+		}
+		if (!i) { ped_free (node); return 0; }
+		if (desc->type == HFS_IDX_NODE) {
+			unsigned int 	skip;
+			
+			skip = ( 2 + PED_BE16_TO_CPU (record_key->key_length)
+			         + 1 ) & ~1;
+			node_number = PED_BE32_TO_CPU (*((uint32_t *)
+					(((uint8_t *) record_key) + skip)));
+			if (!hfsplus_file_read(b_tree_file, node,
+					       (PedSector) node_number * size,
+					       size)) {
+				ped_free (node);
+				return 0;
+			}
+		} else 
+			break;
+	}
+	
+	/* copy the result if needed */
+	if (record_size)
+		memcpy (record_out, record_key, record_size);
+	
+	/* send record reference if needed */
+	if (record_ref) {
+		record_ref->node_size = size;	/* in sectors */
+		record_ref->node_number = node_number;
+		record_ref->record_pos = (uint8_t*)record_key - node;
+		record_ref->record_number = i;
+	}
+
+	/* success */
+	ped_free (node);
+	return 1;
+}
+
+/* free the bad blocks linked list */
+void
+hfsplus_free_bad_blocks_list(HfsPPrivateLinkExtent* first)
+{
+	HfsPPrivateLinkExtent*	next;
+	
+	while (first) {
+		next = first->next;
+		ped_free (first);
+		first = next;
+	}
+}
+
+/* This function reads bad blocks extents in the extents file
+   and store it in f.s. specific data of fs */
+int
+hfsplus_read_bad_blocks (const PedFileSystem *fs)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						    fs->type_specific;
+
+	if (priv_data->bad_blocks_loaded)
+		return 1;
+
+	{
+	uint8_t			record[sizeof (HfsPExtentKey)
+				       + sizeof (HfsPExtDataRec)];
+	HfsPExtentKey		search;
+	HfsPExtentKey*		ret_key = (HfsPExtentKey*) record;
+	HfsPExtDescriptor*	ret_cache = (HfsPExtDescriptor*)
+				    (record + sizeof (HfsPExtentKey));
+	int			block, first_pass = 1;
+	unsigned int		last_start;
+
+	search.key_length = sizeof (HfsExtentKey) - 2;
+	search.type = HFS_DATA_FORK;
+	search.pad = 0;
+	search.file_ID = PED_CPU_TO_BE32 (HFS_BAD_BLOCK_ID);
+
+	last_start = -1; block = 0;
+	while (1) {
+		int i;
+
+		search.start = PED_CPU_TO_BE32 (block);
+		if (!hfsplus_btree_search (priv_data->extents_file,
+					   (HfsPPrivateGenericKey*) &search,
+					   record, sizeof (record), NULL)
+		    || ret_key->file_ID != search.file_ID
+		    || ret_key->type != search.type) {
+			if (first_pass)
+				break;
+			else
+				goto errbbp;
+		}
+		if (PED_BE32_TO_CPU (ret_key->start) == last_start)
+			break;
+
+		last_start = PED_BE32_TO_CPU (ret_key->start);
+		for (i = 0; i < HFSP_EXT_NB; i++) {
+			if (ret_cache[i].block_count) {
+				HfsPPrivateLinkExtent*	new_xt =
+				  (HfsPPrivateLinkExtent*) ped_malloc (
+				    sizeof (HfsPPrivateLinkExtent));
+				if (!new_xt)
+					goto errbbp;
+				new_xt->next = priv_data->bad_blocks_xtent_list;
+				memcpy (&(new_xt->extent), ret_cache+i,
+					sizeof (HfsPExtDescriptor));
+				priv_data->bad_blocks_xtent_list = new_xt;
+				priv_data->bad_blocks_xtent_nb++;
+				block += PED_BE32_TO_CPU (
+						ret_cache[i].block_count);
+			}
+		}
+		first_pass = 0;
+	}
+
+	priv_data->bad_blocks_loaded = 1;
+	return 1;}
+
+errbbp: hfsplus_free_bad_blocks_list(priv_data->bad_blocks_xtent_list);
+	priv_data->bad_blocks_xtent_list=NULL;
+	priv_data->bad_blocks_xtent_nb=0;
+	return 0;
+}
+
+/* This function check if fblock is a bad block */
+int
+hfsplus_is_bad_block (const PedFileSystem *fs, unsigned int fblock)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPPrivateLinkExtent*	walk;
+	
+	for (walk = priv_data->bad_blocks_xtent_list; walk; walk = walk->next) {
+		/* Won't compile without the strange cast ! gcc bug ? */
+		/* or maybe C subtilties... */
+		if ((fblock >= PED_BE32_TO_CPU (walk->extent.start_block)) && 
+		    (fblock <  (unsigned int)(PED_BE32_TO_CPU (
+						walk->extent.start_block)
+			       + PED_BE32_TO_CPU (walk->extent.block_count))))
+			return 1;
+	}
+	
+	return 0;
+}
+
+/* This function returns the first sector of the last free block of
+   an HFS+ volume we can get after a hfsplus_pack_free_space_from_block call */
+PedSector
+hfsplus_get_empty_end (const PedFileSystem *fs)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						    fs->type_specific;
+	HfsPVolumeHeader* 	vh = priv_data->vh;
+	HfsPPrivateLinkExtent*	link;
+	unsigned int		block, last_bad, end_free_blocks;
+
+	/* find the next block to the last bad block of the volume */
+	if (!hfsplus_read_bad_blocks (fs)) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Bad blocks could not be read."));
+		return 0;
+	}
+
+	last_bad = 0;
+	for (link = priv_data->bad_blocks_xtent_list; link; link = link->next) {
+		if ((unsigned int) PED_BE32_TO_CPU (link->extent.start_block)
+		    + PED_BE32_TO_CPU (link->extent.block_count) > last_bad)
+			last_bad = PED_BE32_TO_CPU (link->extent.start_block)
+			           + PED_BE32_TO_CPU (link->extent.block_count);
+	}
+
+	/* Count the free blocks from last_bad to the end of the volume */
+	end_free_blocks = 0;
+	for (block = last_bad;
+	     block < PED_BE32_TO_CPU (vh->total_blocks);
+	     block++) {
+		if (!TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+			end_free_blocks++;
+	}
+
+	/* Calculate the block that will by the first free at
+	   the end of the volume */
+	block = PED_BE32_TO_CPU (vh->total_blocks) - end_free_blocks;
+
+	return (PedSector) block * ( PED_BE32_TO_CPU (vh->block_size)
+				     / PED_SECTOR_SIZE );
+}
+
+/* On error, returns 0 */
+PedSector
+hfsplus_get_min_size (const PedFileSystem *fs)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	PedSector		min_size;
+
+	/* don't need to add anything because every sector
+	   can be part of allocation blocks in HFS+, and
+	   the last block _must_ be reserved */
+	min_size = hfsplus_get_empty_end(fs);
+	if (!min_size) return 0;
+
+	if (priv_data->wrapper) {
+		HfsPrivateFSData* 	hfs_priv_data = (HfsPrivateFSData*)
+					    priv_data->wrapper->type_specific;
+		unsigned int		hfs_sect_block;
+		PedSector		hgee;
+		hfs_sect_block =
+		    PED_BE32_TO_CPU (hfs_priv_data->mdb->block_size)
+		    / PED_SECTOR_SIZE;
+		/* 
+		 * if hfs+ is embedded in an hfs wrapper then the new size is :
+		 * the new size of the hfs+ volume rounded up to the size 
+		 *     of hfs blocks
+		 * + the minimum size of the hfs wrapper without any hfs+
+		 *     modification
+		 * - the current size of the hfs+ volume in the hfs wrapper
+		 */
+		hgee = hfs_get_empty_end(priv_data->wrapper);
+		if (!hgee) return 0;
+		min_size = ((min_size + hfs_sect_block - 1) / hfs_sect_block)
+			   * hfs_sect_block
+			 + hgee + 2
+			 - (PedSector) PED_BE16_TO_CPU ( hfs_priv_data->mdb
+							->old_new.embedded
+							.location.block_count )
+			   * hfs_sect_block;
+	}
+	
+	return min_size;
+}
+
+/* return the block which should be used to pack data to have
+   at least free fblock blocks at the end of the volume */
+unsigned int
+hfsplus_find_start_pack (const PedFileSystem *fs, unsigned int fblock)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	unsigned int		block;
+
+	for (block = PED_BE32_TO_CPU (priv_data->vh->total_blocks) - 1;
+	     block && fblock;
+	     block--) {
+		if (!TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+			fblock--;
+	}
+
+	while (block && !TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+		block--;
+	if (TST_BLOC_OCCUPATION(priv_data->alloc_map,block))
+		block++;
+
+	return block;
+}
+
+#endif /* !DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/advfs_plus.h parted-1.6.19-hfs-16/libparted/fs_hfs/advfs_plus.h
--- parted-1.6.19/libparted/fs_hfs/advfs_plus.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/advfs_plus.h	2004-12-03 15:31:45.146890000 +0100
@@ -0,0 +1,52 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _ADVFS_PLUS_H
+#define _ADVFS_PLUS_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+int
+hfsplus_btree_search (HfsPPrivateFile* b_tree_file, HfsPPrivateGenericKey* key,
+		      void *record_out, unsigned int record_size,
+		      HfsCPrivateLeafRec* record_ref);
+
+void
+hfsplus_free_bad_blocks_list(HfsPPrivateLinkExtent* first);
+
+int
+hfsplus_read_bad_blocks (const PedFileSystem *fs);
+
+int
+hfsplus_is_bad_block (const PedFileSystem *fs, unsigned int fblock);
+
+PedSector
+hfsplus_get_empty_end (const PedFileSystem *fs);
+
+PedSector
+hfsplus_get_min_size (const PedFileSystem *fs);
+
+unsigned int
+hfsplus_find_start_pack (const PedFileSystem *fs, unsigned int fblock);
+
+#endif /* _ADVFS_PLUS_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/cache.c parted-1.6.19-hfs-16/libparted/fs_hfs/cache.c
--- parted-1.6.19/libparted/fs_hfs/cache.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/cache.c	2004-12-03 15:31:45.147890000 +0100
@@ -0,0 +1,237 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+
+#include "cache.h"
+
+static HfsCPrivateCacheTable*
+hfsc_new_cachetable(unsigned int size)
+{
+	HfsCPrivateCacheTable* ret;
+
+	ret = (HfsCPrivateCacheTable*) ped_malloc(sizeof(*ret));
+	if (!ret) return NULL;
+
+	ret->next_cache = NULL;
+	ret->table_size = size;
+	ret->table_first_free = 0;
+
+	ret->table = ped_malloc(sizeof(*ret->table)*size);
+	if (!ret->table) { ped_free(ret); return NULL; }
+	memset(ret->table, 0, sizeof(*ret->table)*size);
+
+	return ret;
+}
+
+HfsCPrivateCache*
+hfsc_new_cache(unsigned int block_number, unsigned int file_number)
+{
+	unsigned int		cachetable_size, i;
+	HfsCPrivateCache*	ret;
+
+	ret = (HfsCPrivateCache*) ped_malloc(sizeof(*ret));
+	if (!ret) return NULL;
+	ret->block_number = block_number;
+	/* following code avoid integer overflow */
+	ret->linked_ref_size = block_number > block_number + ((1<<CR_SHIFT)-1) ?
+				( block_number >> CR_SHIFT ) + 1 :
+				( block_number + ((1<<CR_SHIFT)-1) ) >> CR_SHIFT
+			     ;
+
+	ret->linked_ref = (HfsCPrivateExtent**)
+			   ped_malloc( sizeof(*ret->linked_ref)
+			   		* ret->linked_ref_size );
+	if (!ret->linked_ref) { ped_free(ret); return NULL; }
+
+	cachetable_size = file_number + file_number / CR_OVER_DIV + CR_ADD_CST;
+	if (cachetable_size < file_number) cachetable_size = (unsigned) -1;
+	ret->first_cachetable_size = cachetable_size;
+	ret->table_list = hfsc_new_cachetable(cachetable_size);
+	if (!ret->table_list) {
+		ped_free(ret->linked_ref);
+		ped_free(ret);
+		return NULL;
+	}
+	ret->last_table = ret->table_list;
+
+	for (i = 0; i < ret->linked_ref_size; ++i)
+		ret->linked_ref[i] = NULL;
+
+	ret->needed_alloc_size = 0;
+
+	return ret;
+}
+
+static void
+hfsc_delete_cachetable(HfsCPrivateCacheTable* list)
+{
+	HfsCPrivateCacheTable* next;
+
+	while (list) {
+		ped_free (list->table);
+		next = list->next_cache;
+		ped_free (list);
+		list = next;
+	}
+}
+
+void
+hfsc_delete_cache(HfsCPrivateCache* cache)
+{
+	hfsc_delete_cachetable(cache->table_list);
+	ped_free(cache->linked_ref);
+	ped_free(cache);
+}
+
+HfsCPrivateExtent*
+hfsc_cache_add_extent(HfsCPrivateCache* cache, uint32_t start, uint32_t length,
+		      uint32_t block, uint16_t offset, uint8_t sbb,
+		      uint8_t where, uint8_t index)
+{
+	HfsCPrivateExtent*	ext;
+	unsigned int		idx = start >> CR_SHIFT;
+
+	PED_ASSERT(idx < cache->linked_ref_size, return NULL);
+
+	for (ext = cache->linked_ref[idx];
+	     ext && start != ext->ext_start;
+	     ext = ext->next);
+
+	if (ext) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+		      _("Trying to register an extent starting at block 0x%X, "\
+		        "but an other one already exists at this position. "\
+			"You should check the filesystem !"), start);
+		return NULL;
+	}
+
+	if ( cache->last_table->table_first_free 
+	     == cache->last_table->table_size ) {
+		cache->last_table->next_cache = 
+			hfsc_new_cachetable( ( cache->first_cachetable_size
+					       / CR_NEW_ALLOC_DIV )
+					     + CR_ADD_CST );
+		if (!cache->last_table->next_cache)
+			return NULL;
+		cache->last_table = cache->last_table->next_cache;
+	}
+
+	ext = cache->last_table->table+(cache->last_table->table_first_free++);
+
+	ext->ext_start = start;
+	ext->ext_length = length;
+	ext->ref_block = block;
+	ext->ref_offset = offset;
+	ext->sect_by_block = sbb;
+	ext->where = where;
+	ext->ref_index = index;
+
+	ext->next = cache->linked_ref[idx];
+	cache->linked_ref[idx] = ext;
+
+	cache->needed_alloc_size = cache->needed_alloc_size >
+				   (unsigned) PED_SECTOR_SIZE * sbb ?
+				   cache->needed_alloc_size :
+				   (unsigned) PED_SECTOR_SIZE * sbb;
+
+	return ext;
+}
+
+HfsCPrivateExtent*
+hfsc_cache_search_extent(HfsCPrivateCache* cache, uint32_t start)
+{
+	HfsCPrivateExtent*	ret;
+	unsigned int	idx = start >> CR_SHIFT;
+
+	PED_ASSERT(idx < cache->linked_ref_size, return NULL);
+
+	for (ret = cache->linked_ref[idx];
+	     ret && start != ret->ext_start;
+	     ret = ret->next);
+
+	return ret;
+}
+
+/* Can't fail if extent begining at old_start exists */
+/* Returns 0 if no such extent, or on error */
+HfsCPrivateExtent*
+hfsc_cache_move_extent(HfsCPrivateCache* cache, uint32_t old_start,
+			uint32_t new_start)
+{
+	HfsCPrivateExtent**	ppext;
+	HfsCPrivateExtent*	pext;
+
+	unsigned int 		idx1 = old_start >> CR_SHIFT;
+	unsigned int		idx2 = new_start >> CR_SHIFT;
+
+	PED_ASSERT(idx1 < cache->linked_ref_size, return NULL);
+	PED_ASSERT(idx2 < cache->linked_ref_size, return NULL);
+
+	for (pext = cache->linked_ref[idx2];
+	     pext && new_start != pext->ext_start;
+	     pext = pext->next);
+
+	if (pext) {
+		ped_exception_throw (PED_EXCEPTION_BUG,
+		     PED_EXCEPTION_CANCEL,
+		   _("Trying to move an extent from block Ox%X to block Ox%X, "\
+		     "but an other one already exists at this position. "\
+		     "This should not happen !"), old_start, new_start);
+		return NULL;
+	}
+
+	for (ppext = &(cache->linked_ref[idx1]);
+	     (*ppext) && old_start != (*ppext)->ext_start;
+	     ppext = &((*ppext)->next));
+
+	if (!(*ppext)) return NULL;
+
+	/* removing the extent from the cache */
+	pext = *ppext;
+	(*ppext) = pext->next;
+
+	/* change ext_start and insert the extent again */
+	pext->ext_start = new_start;
+	pext->next = cache->linked_ref[idx2];
+	cache->linked_ref[idx2] = pext;
+
+	return pext;
+}
+
+#endif /* DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/cache.h parted-1.6.19-hfs-16/libparted/fs_hfs/cache.h
--- parted-1.6.19/libparted/fs_hfs/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/cache.h	2004-12-03 15:31:45.147890000 +0100
@@ -0,0 +1,117 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _CACHE_H
+#define _CACHE_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+/* CR => CACHE REF */
+#define CR_NULL			 0 /* reserved */
+#define CR_PRIM_CAT		 1
+#define CR_PRIM_EXT		 2
+#define CR_PRIM_ATTR		 3
+#define CR_PRIM_ALLOC		 4
+#define CR_PRIM_START		 5
+#define CR_BTREE_CAT		 6
+#define CR_BTREE_ATTR		 7
+#define CR_BTREE_EXT_0		 8
+#define CR_BTREE_EXT_CAT	 9
+#define CR_BTREE_EXT_EXT	10 /* should not happen ! */
+#define CR_BTREE_EXT_ATTR	11
+#define CR_BTREE_EXT_ALLOC	12 /* unneeded in current code */
+#define CR_BTREE_EXT_START	13 /* unneeded in current code */
+/* 14 15 */			   /* reserved */
+/* 16 -> 31 || high order bit */   /* reserved */
+
+/* tuning */
+#define CR_SHIFT		 8 /* number of bits to shift start_block by */
+				   /* to get the index of the linked list */
+#define CR_OVER_DIV		16 /* alloc a table for (1+1/CR_OVER_DIV) * 
+				      file_number + CR_ADD_CST */
+#define CR_ADD_CST		16
+#define CR_NEW_ALLOC_DIV	 4 /* divide the size of the first alloc table 
+				      by this value to allocate next tables */
+
+/* See DOC for an explaination of this structure */
+/* Access read only from outside cache.c */
+struct _HfsCPrivateExtent {
+	struct _HfsCPrivateExtent*	next;
+	uint32_t			ext_start;
+	uint32_t			ext_length;
+	uint32_t			ref_block;
+	uint16_t			ref_offset;
+	uint8_t				sect_by_block;
+	unsigned			where : 5;
+	unsigned			ref_index : 3; /* 0 -> 7 */
+};
+typedef struct _HfsCPrivateExtent HfsCPrivateExtent;
+
+/* Internaly used by cache.c for custom memory managment only */
+struct _HfsCPrivateCacheTable {
+	struct _HfsCPrivateCacheTable*	next_cache;
+	HfsCPrivateExtent*		table;
+	unsigned int			table_size;
+	unsigned int			table_first_free;
+	/* first_elemt ? */
+};
+typedef struct _HfsCPrivateCacheTable HfsCPrivateCacheTable;
+
+/* Internaly used by cache.c for custom memory managment 
+   and cache handling only */
+struct _HfsCPrivateCache {
+	HfsCPrivateCacheTable*		table_list;
+	HfsCPrivateCacheTable*		last_table;
+	HfsCPrivateExtent**		linked_ref;
+	unsigned int			linked_ref_size;
+	unsigned int			block_number;
+	unsigned int			first_cachetable_size;
+	unsigned int			needed_alloc_size;
+};
+typedef struct _HfsCPrivateCache HfsCPrivateCache;
+
+HfsCPrivateCache*
+hfsc_new_cache(unsigned int block_number, unsigned int file_number);
+
+void
+hfsc_delete_cache(HfsCPrivateCache* cache);
+
+HfsCPrivateExtent*
+hfsc_cache_add_extent(HfsCPrivateCache* cache, uint32_t start, uint32_t length,
+		      uint32_t block, uint16_t offset, uint8_t sbb,
+		      uint8_t where, uint8_t index);
+
+HfsCPrivateExtent*
+hfsc_cache_search_extent(HfsCPrivateCache* cache, uint32_t start);
+
+HfsCPrivateExtent*
+hfsc_cache_move_extent(HfsCPrivateCache* cache, uint32_t old_start,
+			uint32_t new_start);
+
+static __inline__ unsigned int
+hfsc_cache_needed_buffer(HfsCPrivateCache* cache)
+{
+	return cache->needed_alloc_size;
+}
+
+#endif /* _CACHE_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/DOC parted-1.6.19-hfs-16/libparted/fs_hfs/DOC
--- parted-1.6.19/libparted/fs_hfs/DOC	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/DOC	2004-12-03 15:32:08.808293000 +0100
@@ -0,0 +1,86 @@
+WARNING : Both HFS and HFS+ implementations of Linux 2.4 are buggy, at
+least when used before or after this implementation. Some workarounds
+are used in this implementation, but there can still be incompatibilities.
+Try Linux 2.6 if you want to play with HFS(+) resizing (though some bugs
+might also be there in 2.6, there is of course no warranty)
+
+---
+
+    Technical doc about Apple HFS and HFS+ file systems is available at : 
+    * For HFS, section "Data Organization on Volumes",
+                       "Chapter 2 - File Manager"
+           of the book "Inside Macintosh: Files"
+     http://developer.apple.com/documentation/mac/Files/Files-99.html
+    * For HFS+, "Technical Note TN1150", "HFS Plus Volume Format"
+     http://developer.apple.com/technotes/tn/tn1150.html
+
+    Some useful HFS precisions concerning alignement, bit ordering, and
+    order of fields for extent key comparaisons are only in the HFS+ TN
+    
+    These Apple Creator Codes are reserved for us :
+    Shnk traP GP16 GnuP PH+x Xpnd Resz GP17 GP18 GP19 GP20
+
+---
+
+* Cache design *
+
+Versions before HFS Patch 15 were very slow when data relocation was needed,
+because every extent to relocate involved scanning the whole file system,
+looking for a reference to its physical position on the volume (this was a 
+dummy algorithm, I know :)
+
+HFS Patch 16 introduced a cache that allows to efficiently retrieve the place 
+of the reference in the file system given the physical position of an extent.
+The cache is designed for : - efficiency
+			    - scaling
+			    - simplicity
+			    - avoiding memory allocation while resizing
+
+This cache involves quite big worst cases memory consumption, but without it
+the time needed to complete the operation in theses worst cases would be huge
+anyway (maybe several years...) so this isn't really an issue. The cache size
+is near proportional to the number of files you have, or if you have very few
+files to the size of your volume, so worst cases situations occure when you
+fill a drive with millions of < 4 ko files :p For this very special usage you
+will just need a very special amount of RAM (on typical systems about
+(FS size) / 256 )... On a more "normal" volume it's about
+(# of files) * 20 bytes. With very few files it's about (FS Size) / 1024 / 256.
+
+At the beginning of the resize process, the cache is filed by scanning the FS.
+The position of each extent is cut into 2 parts : high order is used as 
+an index into a table of pointer to a linked list which contains :
+- the next ptr				(sizeof struct *)
+- the extent start			(4 bytes)
+- the extent size			(4 bytes) /* should I keep this ? */
+- number of BTree block or 0 if in prim (4 bytes)
+- offset of the extent start reference 
+  from the block beginning              (2 bytes)
+- sectors by BTree block, or 
+  1 for VH/MDB				(1 byte)
+- FS special file / primary structure
+  where the extent reference is stored  (1 byte)
+  (3 bits for the extent index, 5 for
+   the actual ref)
+  0 : dont exists				-- reserved
+  1 : mdb / vh : catalog			--
+  2 : mdb / vh : extent				--
+  3 :       vh : attributes			X+
+  4 :       vh : allocation			X+
+  5 :       vh : startup			X+
+  6 :            catalog			--
+  7 :            attributes			X+
+  8 :            extent (nothing to update)	--
+  9 :            extent (update catalog)	--
+ 10 :            extent (update extent !?!)	-- should not exist
+ 11 :            extent (update attributes)	X+
+ 12 :            extent (update allocation)	X+ reserved
+ 13 :            extent (update startup)	X+ reserved
+ 14 :						-- reserved
+ 15 :						-- reserved
+ 16 - 31 :					-- reserved
+  
+Large amount of memory is allocated at once (first enough memory to fit
+every files if there isn't any fragmentation +6.25%, then this value / 4,
+if this wasn't enough). On a typical FS, the first allocation should be enough.
+
+---
diff -Nru parted-1.6.19/libparted/fs_hfs/file.c parted-1.6.19-hfs-16/libparted/fs_hfs/file.c
--- parted-1.6.19/libparted/fs_hfs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/file.c	2004-12-03 15:31:45.148889000 +0100
@@ -0,0 +1,226 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+#include "advfs.h"
+
+#include "file.h"
+
+/* Open the data fork of a file with its first three extents and its CNID */
+HfsPrivateFile*
+hfs_file_open (PedFileSystem *fs, uint32_t CNID,
+	       HfsExtDataRec ext_desc, PedSector sect_nb)
+{
+	HfsPrivateFile* file;
+
+	file = (HfsPrivateFile*) ped_malloc (sizeof (HfsPrivateFile));
+	if (!file) return NULL;
+
+	file->fs = fs;
+	file->sect_nb = sect_nb;
+	file->CNID = CNID;
+	memcpy(file->first, ext_desc, sizeof (HfsExtDataRec));
+/*	memcpy(file->cache, ext_desc, sizeof (HfsExtDataRec));*/
+	file->start_cache = 0;
+	
+	return file;
+}
+
+/* Close an HFS file */
+void
+hfs_file_close (HfsPrivateFile* file)
+{
+	ped_free (file);
+}
+
+/* warning : only works on data forks */
+static int
+hfs_get_extent_containing (HfsPrivateFile* file, unsigned int block,
+			   HfsExtDataRec cache, uint16_t* ptr_start_cache)
+{
+	uint8_t			record[sizeof (HfsExtentKey)
+				       + sizeof (HfsExtDataRec)];
+	HfsExtentKey		search;
+	HfsExtentKey*		ret_key = (HfsExtentKey*) record;
+	HfsExtDescriptor*	ret_cache = (HfsExtDescriptor*)
+					      (record + sizeof (HfsExtentKey));
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+					      file->fs->type_specific;
+	
+	
+	search.key_length = sizeof (HfsExtentKey) - 1;
+	search.type = HFS_DATA_FORK;
+	search.file_ID = file->CNID;
+	search.start = PED_CPU_TO_BE16 (block);
+
+	if (!hfs_btree_search (priv_data->extent_file, 
+			       (HfsPrivateGenericKey*) &search,
+			       record, sizeof (record), NULL))
+		return 0;
+
+	if (ret_key->file_ID != search.file_ID || ret_key->type != search.type)
+		return 0;
+
+	memcpy (cache, ret_cache, sizeof(HfsExtDataRec));
+	*ptr_start_cache = PED_BE16_TO_CPU (ret_key->start);
+	
+	return 1;
+}
+
+/* find and return the nth sector of a file */
+/* return 0 on error */
+static PedSector
+hfs_file_find_sector (HfsPrivateFile* file, PedSector sector)
+{
+	HfsPrivateFSData* priv_data = (HfsPrivateFSData*)
+				      file->fs->type_specific;
+	unsigned int 	sect_by_block = PED_BE32_TO_CPU (
+					    priv_data->mdb->block_size)
+					/ PED_SECTOR_SIZE;
+	unsigned int 	i, s, vol_block;
+	unsigned int 	block  = sector / sect_by_block;
+	unsigned int	offset = sector % sect_by_block;
+	
+	/* in the three first extent */
+	for (s = 0, i = 0; i < HFS_EXT_NB; i++) {
+			if ((block >= s) && ( block < s + PED_BE16_TO_CPU (
+						file->first[i].block_count))) {
+			vol_block = (block - s) + PED_BE16_TO_CPU (
+						    file->first[i].start_block);
+			goto sector_found;
+		}
+		s += PED_BE16_TO_CPU (file->first[i].block_count);
+	}
+	
+	/* in the three cached extent */
+	if (file->start_cache && block >= file->start_cache)
+	for (s = file->start_cache, i = 0; i < HFS_EXT_NB; i++) {
+		if ((block >= s) && (block < s + PED_BE16_TO_CPU (
+						file->cache[i].block_count))) {
+			vol_block = (block - s) + PED_BE16_TO_CPU (
+						    file->cache[i].start_block);
+			goto sector_found;
+		}
+		s += PED_BE16_TO_CPU (file->cache[i].block_count);
+	}
+	
+	/* update cache */
+	if (!hfs_get_extent_containing (file, block, file->cache,
+					&(file->start_cache))) {
+		ped_exception_throw (PED_EXCEPTION_WARNING,
+		      PED_EXCEPTION_CANCEL,
+		      _("Could not update the extent cache for %s "\
+		      "file with CNID %X."),
+		      "HFS", PED_BE32_TO_CPU(file->CNID));
+		return 0;
+	}
+
+	/* in the three cached extent */
+	PED_ASSERT(file->start_cache && block >= file->start_cache, return 0);
+	for (s = file->start_cache, i = 0; i < HFS_EXT_NB; i++) {
+		if ((block >= s) && (block < s + PED_BE16_TO_CPU (
+						file->cache[i].block_count))) {
+			vol_block = (block - s) + PED_BE16_TO_CPU (
+						    file->cache[i].start_block);
+			goto sector_found;
+		}
+		s += PED_BE16_TO_CPU (file->cache[i].block_count);
+	}
+	
+	return 0;
+	
+    sector_found:
+	return (PedSector) PED_BE16_TO_CPU (priv_data->mdb->start_block)
+		+ (PedSector) vol_block * sect_by_block
+		+ offset;
+}
+
+/* Read the nth sector of a file */
+/* return 0 on error */
+int
+hfs_file_read_sector (HfsPrivateFile* file, void *buf, PedSector sector)
+{
+	PedSector	abs_sector;
+
+	if (sector >= file->sect_nb) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Trying to read %s file with CNID %X behind EOF."),
+		      "HFS", PED_BE32_TO_CPU(file->CNID));
+		return 0;
+	}
+	
+	abs_sector = hfs_file_find_sector (file, sector);
+	if (!abs_sector) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Could not find sector %lli of %s file with CNID %X."),
+		      sector, "HFS", PED_BE32_TO_CPU(file->CNID));
+		return 0;
+	}
+	
+	return ped_geometry_read (file->fs->geom, buf, abs_sector, 1);
+}
+
+/* Write the nth sector of a file */
+/* return 0 on error */
+int
+hfs_file_write_sector (HfsPrivateFile* file, void *buf, PedSector sector)
+{
+	PedSector	abs_sector;
+
+	if (sector >= file->sect_nb) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Trying to write %s file with CNID %X behind EOF."),
+		      "HFS", PED_BE32_TO_CPU(file->CNID));		
+		return 0;
+	}
+
+	abs_sector = hfs_file_find_sector (file, sector);
+	if (!abs_sector) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Could not find sector %lli of %s file with CNID %X."),
+		      sector, "HFS", PED_BE32_TO_CPU(file->CNID));
+		return 0;
+	}
+	
+	return ped_geometry_write (file->fs->geom, buf, abs_sector, 1);
+}
+
+#endif /* !DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/file.h parted-1.6.19-hfs-16/libparted/fs_hfs/file.h
--- parted-1.6.19/libparted/fs_hfs/file.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/file.h	2004-12-03 15:31:45.148889000 +0100
@@ -0,0 +1,42 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _FILE_H
+#define _FILE_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+HfsPrivateFile*
+hfs_file_open (PedFileSystem *fs, uint32_t CNID,
+	       HfsExtDataRec ext_desc, PedSector sect_nb);
+
+void
+hfs_file_close (HfsPrivateFile* file);
+
+int
+hfs_file_read_sector (HfsPrivateFile* file, void *buf, PedSector sector);
+
+int
+hfs_file_write_sector (HfsPrivateFile* file, void *buf, PedSector sector);
+
+#endif /* _FILE_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/file_plus.c parted-1.6.19-hfs-16/libparted/fs_hfs/file_plus.c
--- parted-1.6.19/libparted/fs_hfs/file_plus.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/file_plus.c	2004-12-03 15:31:45.149889000 +0100
@@ -0,0 +1,271 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+#include "advfs_plus.h"
+
+#include "file_plus.h"
+
+/* Open the data fork of a file with its first eight extents and its CNID */
+/* CNID and ext_desc must be in disc order, sect_nb in CPU order */
+/* return null on failure */
+HfsPPrivateFile*
+hfsplus_file_open (PedFileSystem *fs, HfsPNodeID CNID,
+		   HfsPExtDataRec ext_desc, PedSector sect_nb)
+{
+	HfsPPrivateFile* file;
+
+	file = (HfsPPrivateFile*) ped_malloc (sizeof (HfsPPrivateFile));
+	if (!file) return NULL;
+
+	file->fs = fs;
+	file->sect_nb = sect_nb;
+	file->CNID = CNID;
+	memcpy(file->first, ext_desc, sizeof (HfsPExtDataRec));
+/*	memcpy(file->cache, ext_desc, sizeof (HfsPExtDataRec));*/
+	file->start_cache = 0;
+	
+	return file;
+}
+
+/* Close an HFS+ file */
+void
+hfsplus_file_close (HfsPPrivateFile* file)
+{
+	ped_free (file);
+}
+
+/* warning : only works on data forks */
+static int
+hfsplus_get_extent_containing (HfsPPrivateFile* file, unsigned int block,
+			       HfsPExtDataRec cache, uint32_t* ptr_start_cache)
+{
+	uint8_t			record[sizeof (HfsPExtentKey)
+				       + sizeof (HfsPExtDataRec)];
+	HfsPExtentKey		search;
+	HfsPExtentKey*		ret_key = (HfsPExtentKey*) record;
+	HfsPExtDescriptor*	ret_cache = (HfsPExtDescriptor*)
+					      (record + sizeof (HfsPExtentKey));
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						file->fs->type_specific;
+	
+	
+	search.key_length = PED_CPU_TO_BE16 (sizeof (HfsPExtentKey) - 2);
+	search.type = HFS_DATA_FORK;
+	search.pad = 0;
+	search.file_ID = file->CNID;
+	search.start = PED_CPU_TO_BE32 (block);
+
+	if (!hfsplus_btree_search (priv_data->extents_file,
+				   (HfsPPrivateGenericKey*) &search,
+				   record, sizeof (record), NULL))
+		return 0;
+
+	if (ret_key->file_ID != search.file_ID || ret_key->type != search.type)
+		return 0;
+
+	memcpy (cache, ret_cache, sizeof(HfsPExtDataRec));
+	*ptr_start_cache = PED_BE32_TO_CPU (ret_key->start);
+	
+	return 1;
+}
+
+/* find a sub extent contained in the desired area */
+/* and with the same starting point */
+/* return 0 in sector_count on error, or the physical area */
+/* on the volume corresponding to the logical area in the file */
+static HfsPPrivateExtent
+hfsplus_file_find_extent (HfsPPrivateFile* file, PedSector sector,
+			  unsigned int nb)
+{
+	HfsPPrivateExtent ret = {0,0};
+	HfsPPrivateFSData* priv_data = (HfsPPrivateFSData*)
+					file->fs->type_specific;
+	unsigned int	sect_by_block = PED_BE32_TO_CPU (
+					    priv_data->vh->block_size)
+					/ PED_SECTOR_SIZE;
+	unsigned int	i, s, vol_block, size;
+	PedSector	sect_size;
+	unsigned int	block  = sector / sect_by_block;
+	unsigned int	offset = sector % sect_by_block;
+
+	/* in the 8 first extent */
+	for (s = 0, i = 0; i < HFSP_EXT_NB; i++) {
+		if ((block >= s) && (block < s + PED_BE32_TO_CPU (
+						file->first[i].block_count))) {
+			vol_block = (block - s)
+				    + PED_BE32_TO_CPU (file->first[i]
+						       .start_block);
+			size = PED_BE32_TO_CPU (file->first[i].block_count)
+				+ s - block;
+			goto plus_sector_found;
+		}
+		s += PED_BE32_TO_CPU (file->first[i].block_count);
+	}
+
+	/* in the 8 cached extent */
+	if (file->start_cache && block >= file->start_cache)
+	for (s = file->start_cache, i = 0; i < HFSP_EXT_NB; i++) {
+		if ((block >= s) && (block < s + PED_BE32_TO_CPU (
+						file->cache[i].block_count))) {
+			vol_block = (block - s)
+				    + PED_BE32_TO_CPU (file->cache[i]
+						       .start_block);
+			size = PED_BE32_TO_CPU (file->cache[i].block_count)
+				+ s - block;
+			goto plus_sector_found;
+		}
+		s += PED_BE32_TO_CPU (file->cache[i].block_count);
+	}
+	
+	/* update cache */
+	if (!hfsplus_get_extent_containing (file, block, file->cache,
+					    &(file->start_cache))) {
+		ped_exception_throw (PED_EXCEPTION_WARNING,
+		      PED_EXCEPTION_CANCEL,
+		      _("Could not update the extent cache for %s "\
+		      "file with CNID %X."),
+		      "HFS+", PED_BE32_TO_CPU(file->CNID));
+		return ret; /* ret == {0,0} */
+	}
+
+	/* ret == {0,0} */
+	PED_ASSERT(file->start_cache && block >= file->start_cache, return ret);
+
+	for (s = file->start_cache, i = 0; i < HFSP_EXT_NB; i++) {
+		if ((block >= s) && (block < s + PED_BE32_TO_CPU (
+						file->cache[i].block_count))) {
+			vol_block = (block - s)
+				    + PED_BE32_TO_CPU (file->cache[i]
+						       .start_block);
+			size = PED_BE32_TO_CPU (file->cache[i].block_count)
+				+ s - block;
+			goto plus_sector_found;
+		}
+		s += PED_BE32_TO_CPU (file->cache[i].block_count);
+	}
+
+	return ret;
+
+plus_sector_found:
+	sect_size = (PedSector) size * sect_by_block - offset;
+	ret.start_sector = vol_block * sect_by_block + offset;
+	ret.sector_count = (sect_size < nb) ? sect_size : nb;
+	return ret;
+}
+
+int
+hfsplus_file_read(HfsPPrivateFile* file, void *buf, PedSector sector,
+		  unsigned int nb)
+{
+	HfsPPrivateExtent phy_area;
+	HfsPPrivateFSData* priv_data = (HfsPPrivateFSData*)
+					file->fs->type_specific;
+
+	if (sector+nb < sector /* detect overflow */
+	    || sector+nb > file->sect_nb) /* out of file */ {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Trying to read %s file with CNID %X behind EOF."),
+		      "HFS+", PED_BE32_TO_CPU(file->CNID));
+		return 0;
+	}
+
+	while (nb) {
+		phy_area = hfsplus_file_find_extent(file, sector, nb);
+		if (phy_area.sector_count == 0) {
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			      PED_EXCEPTION_CANCEL,
+			      _("Could not find sector %lli of %s file with "\
+			      "CNID %X."), sector, "HFS+", 
+			      PED_BE32_TO_CPU(file->CNID));
+			return 0;
+		}
+		if (!ped_geometry_read(priv_data->plus_geom, buf,
+				       phy_area.start_sector,
+				       phy_area.sector_count))
+			return 0;
+
+		nb -= phy_area.sector_count; /* < nb anyway ... */
+		sector += phy_area.sector_count;
+		buf += phy_area.sector_count * PED_SECTOR_SIZE;
+	}
+	
+	return 1;
+}
+
+int
+hfsplus_file_write(HfsPPrivateFile* file, void *buf, PedSector sector,
+		  unsigned int nb)
+{
+	HfsPPrivateExtent phy_area;
+	HfsPPrivateFSData* priv_data = (HfsPPrivateFSData*)
+					file->fs->type_specific;
+
+	if (sector+nb < sector /* detect overflow */
+	    || sector+nb > file->sect_nb) /* out of file */ {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Trying to write %s file with CNID %X behind EOF."),
+		      "HFS+", PED_BE32_TO_CPU(file->CNID));
+		return 0;
+	}
+
+	while (nb) {
+		phy_area = hfsplus_file_find_extent(file, sector, nb);
+		if (phy_area.sector_count == 0) {
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			      PED_EXCEPTION_CANCEL,
+			      _("Could not find sector %lli of %s file with "\
+			      "CNID %X."), sector, "HFS+", 
+			      PED_BE32_TO_CPU(file->CNID));
+			return 0;
+		}
+		if (!ped_geometry_write(priv_data->plus_geom, buf,
+				       phy_area.start_sector,
+				       phy_area.sector_count))
+			return 0;
+
+		nb -= phy_area.sector_count; /* < nb anyway ... */
+		sector += phy_area.sector_count;
+		buf += phy_area.sector_count * PED_SECTOR_SIZE;
+	}
+	
+	return 1;
+}
+
+#endif /* !DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/file_plus.h parted-1.6.19-hfs-16/libparted/fs_hfs/file_plus.h
--- parted-1.6.19/libparted/fs_hfs/file_plus.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/file_plus.h	2004-12-03 15:31:45.149889000 +0100
@@ -0,0 +1,61 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _FILE_PLUS_H
+#define _FILE_PLUS_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+HfsPPrivateFile*
+hfsplus_file_open (PedFileSystem *fs, HfsPNodeID CNID,
+		   HfsPExtDataRec ext_desc, PedSector sect_nb);
+
+void
+hfsplus_file_close (HfsPPrivateFile* file);
+
+int
+hfsplus_file_read(HfsPPrivateFile* file, void *buf,
+		  PedSector sector, unsigned int nb);
+
+int
+hfsplus_file_write(HfsPPrivateFile* file, void *buf,
+		  PedSector sector, unsigned int nb);
+
+/* Read the nth sector of a file */
+/* return 0 on error */
+static __inline__ int
+hfsplus_file_read_sector (HfsPPrivateFile* file, void *buf, PedSector sector)
+{
+	return hfsplus_file_read(file, buf, sector, 1);
+}
+
+/* Write the nth sector of a file */
+/* return 0 on error */
+static __inline__ int
+hfsplus_file_write_sector (HfsPPrivateFile* file, void *buf, PedSector sector)
+{
+	return hfsplus_file_write(file, buf, sector, 1);
+}
+
+
+#endif /* _FILE_PLUS_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/hfs.c parted-1.6.19-hfs-16/libparted/fs_hfs/hfs.c
--- parted-1.6.19/libparted/fs_hfs/hfs.c	2004-06-13 08:35:11.000000000 +0200
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/hfs.c	2004-12-03 15:31:45.150889000 +0100
@@ -1,6 +1,6 @@
 /*
     libparted - a library for manipulating disk partitions
-    Copyright (C) 2000 Free Software Foundation, Inc.
+    Copyright (C) 2000, 2003, 2004 Free Software Foundation, Inc.
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -17,10 +17,19 @@
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+/* 
+   Author : Guillaume Knispel <k_guillaume@libertysurf.fr> 
+   Report bug to <bug-parted@gnu.org>
+*/
+
 #include "config.h"
 
+#include <stdlib.h>
+#include <string.h>
 #include <parted/parted.h>
 #include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
 
 #if ENABLE_NLS
 #  include <libintl.h>
@@ -29,44 +38,1117 @@
 #  define _(String) (String)
 #endif /* ENABLE_NLS */
 
-#include <string.h>
+#include "hfs.h"
+#include "probe.h"
+
+uint8_t* hfs_block = NULL;
+uint8_t* hfsp_block = NULL;
+
+#ifndef DISCOVER_ONLY
+#include "file.h"
+#include "reloc.h"
+#include "advfs.h"
 
-#define HFS_SIGNATURE	0x4244
+/* ----- HFS ----- */
+
+/* This is a very unundoable operation */
+/* Maybe I shouldn't touch the alternate MDB ? */
+/* Anyway clobber is call before other fs creation */
+/* So this is a non-issue */
+static int
+hfs_clobber (PedGeometry* geom)
+{
+	uint8_t	buf[PED_SECTOR_SIZE];
+
+	memset (buf, 0, PED_SECTOR_SIZE);
+	
+	/* destroy boot blocks, mdb, alternate mdb ... */
+	return	ped_geometry_write (geom, buf, 0, 1) &
+		ped_geometry_write (geom, buf, 1, 1) &
+		ped_geometry_write (geom, buf, 2, 1) &
+		ped_geometry_write (geom, buf, geom->length - 2, 1) &
+		ped_geometry_write (geom, buf, geom->length - 1, 1);
+}
 
-static PedGeometry*
-hfs_probe (PedGeometry* geom)
+static PedFileSystem*
+hfs_open (PedGeometry* geom)
 {
-	char	buf[512];
+	uint8_t			buf[PED_SECTOR_SIZE];
+	PedFileSystem*		fs;
+	HfsMasterDirectoryBlock* mdb;
+	HfsPrivateFSData* 	priv_data;
+	
+	/* Read MDB */
+	if (!ped_geometry_read (geom, buf, 2, 1))
+		return NULL;
+		
+	/* Allocate memory */
+	fs = (PedFileSystem*) ped_malloc (sizeof (PedFileSystem));
+	if (!fs) goto ho;
+	mdb = (HfsMasterDirectoryBlock*)
+		ped_malloc (sizeof (HfsMasterDirectoryBlock));
+	if (!mdb) goto ho_fs;
+	priv_data = (HfsPrivateFSData*)
+		ped_malloc (sizeof (HfsPrivateFSData));
+	if (!priv_data) goto ho_mdb;
+
+	memcpy (mdb, buf, sizeof (HfsMasterDirectoryBlock));
+
+	/* init structures */
+	priv_data->mdb = mdb;
+	priv_data->bad_blocks_loaded = 0;
+	priv_data->bad_blocks_xtent_nb = 0;
+	priv_data->bad_blocks_xtent_list = NULL;
+	priv_data->extent_file =
+	    hfs_file_open (fs, PED_CPU_TO_BE32 (HFS_XTENT_ID),
+			   mdb->extents_file_rec,
+			   PED_CPU_TO_BE32 (mdb->extents_file_size)
+			   / PED_SECTOR_SIZE);
+	if (!priv_data->extent_file) goto ho_pd;
+	priv_data->catalog_file =
+	    hfs_file_open (fs, PED_CPU_TO_BE32 (HFS_CATALOG_ID),
+			   mdb->catalog_file_rec,
+			   PED_CPU_TO_BE32 (mdb->catalog_file_size)
+			   / PED_SECTOR_SIZE);
+	if (!priv_data->catalog_file) goto ho_ce;
+	/* Read allocation blocks */
+	if (!ped_geometry_read(geom, priv_data->alloc_map,
+			       PED_BE16_TO_CPU (mdb->volume_bitmap_block),
+			       ( PED_BE16_TO_CPU (mdb->total_blocks)
+			         + PED_SECTOR_SIZE * 8 - 1 )
+			       / (PED_SECTOR_SIZE * 8) ) )
+		goto ho_cf;
+
+	fs->type = &hfs_type;
+	fs->geom = ped_geometry_duplicate (geom);
+	if (!fs->geom) goto ho_cf;
+	fs->type_specific = (void*) priv_data;
+	fs->checked = ( PED_BE16_TO_CPU (mdb->volume_attributes)
+			>> HFS_UNMOUNTED ) & 1;
+	
+	return fs;
+
+/*--- clean error handling ---*/
+ho_cf:	hfs_file_close(priv_data->catalog_file);
+ho_ce:	hfs_file_close(priv_data->extent_file);
+ho_pd:	ped_free(priv_data);
+ho_mdb: ped_free(mdb);
+ho_fs:	ped_free(fs);
+ho:	return NULL;
+}
+
+static int
+hfs_close (PedFileSystem *fs)
+{
+	HfsPrivateFSData* priv_data = (HfsPrivateFSData*) fs->type_specific;
+
+	hfs_file_close (priv_data->extent_file);
+	hfs_file_close (priv_data->catalog_file);
+	if (priv_data->bad_blocks_loaded)
+		hfs_free_bad_blocks_list (priv_data->bad_blocks_xtent_list);
+	ped_free (priv_data->mdb);
+	ped_free (priv_data);
+	ped_geometry_destroy (fs->geom);
+	ped_free (fs);
+	
+	return 1;
+}
 
-	if (geom->length < 2)
+static PedConstraint* 
+hfs_get_resize_constraint (const PedFileSystem *fs)
+{
+	PedDevice*	dev = fs->geom->dev;
+	PedAlignment	start_align;
+	PedGeometry	start_sector;
+	PedGeometry	full_dev;
+	PedSector	min_size;
+
+	if (!ped_alignment_init (&start_align, fs->geom->start, 0))
+		return NULL;
+	if (!ped_geometry_init (&start_sector, dev, fs->geom->start, 1))
+		return NULL;
+	if (!ped_geometry_init (&full_dev, dev, 0, dev->length - 1))
+		return NULL;
+	/* 2 = last two sectors (alternate MDB and unused sector) */
+	min_size = hfs_get_empty_end(fs) + 2;
+	if (min_size == 2) return NULL;
+	
+	return ped_constraint_new (&start_align, ped_alignment_any,
+				   &start_sector, &full_dev, min_size,
+				   fs->geom->length);
+}
+
+static int
+hfs_resize (PedFileSystem* fs, PedGeometry* geom, PedTimer* timer)
+{
+	uint8_t			buf[PED_SECTOR_SIZE];
+	unsigned int		nblock, nfree;
+	unsigned int		block, to_free;
+	HfsPrivateFSData* 	priv_data;
+	HfsMasterDirectoryBlock* mdb;
+	int			resize = 1;
+	unsigned int		hfs_sect_block;
+	PedSector		hgee;
+
+
+	/* check preconditions */
+	PED_ASSERT (fs != NULL, return 0);
+	PED_ASSERT (fs->geom != NULL, return 0);
+	PED_ASSERT (geom != NULL, return 0);
+	PED_ASSERT (fs->geom->dev == geom->dev, return 0);
+	PED_ASSERT ((hgee = hfs_get_empty_end(fs)) != 0, return 0);
+	
+	priv_data = (HfsPrivateFSData*) fs->type_specific;
+	mdb = priv_data->mdb;
+	hfs_sect_block = (PED_BE32_TO_CPU (mdb->block_size) / PED_SECTOR_SIZE);
+	
+	if (fs->geom->start != geom->start
+	    || geom->length > fs->geom->length
+	    || geom->length < hgee + 2)
+	{
+		ped_exception_throw (PED_EXCEPTION_NO_FEATURE,
+		      PED_EXCEPTION_CANCEL,
+		      _("Sorry, HFS cannot be resized that way yet."));
+		return 0;
+	}
+
+	/* Clear the unmounted bit */
+	mdb->volume_attributes &= PED_CPU_TO_BE16 (~( 1 << HFS_UNMOUNTED ));
+	if (!ped_geometry_read (fs->geom, buf, 2, 1))
+		return 0;
+	memcpy (buf, mdb, sizeof (HfsMasterDirectoryBlock));
+	if (   !ped_geometry_write (fs->geom, buf, 2, 1)
+	    || !ped_geometry_sync  (fs->geom))
 		return 0;
+
+	ped_timer_reset (timer);
+	ped_timer_set_state_name(timer, _("shrinking"));
+	ped_timer_update(timer, 0.0);
+	/* relocate data */
+	to_free = ( fs->geom->length - geom->length
+		    + hfs_sect_block - 1 )
+		  / hfs_sect_block ;
+	block = hfs_find_start_pack (fs, to_free);
+	if (!hfs_pack_free_space_from_block (fs, block,	timer, to_free)) {
+		resize = 0;
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Data relocation has failed."));
+		goto write_MDB;
+	}
+
+	/* Calculate new block number and other MDB field */
+	nblock = ( geom->length - (PED_BE16_TO_CPU (mdb->start_block) + 2) )
+		 / hfs_sect_block;
+	nfree = PED_BE16_TO_CPU (mdb->free_blocks)
+		- ( PED_BE16_TO_CPU (mdb->total_blocks) - nblock );
+
+	/* Check that all block after future end are really free */
+	for (block = nblock;
+	     block < PED_BE16_TO_CPU (mdb->total_blocks);
+	     block++) {
+		if (TST_BLOC_OCCUPATION(priv_data->alloc_map,block)) {
+			resize = 0;
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			      PED_EXCEPTION_CANCEL,
+			      _("Data relocation left some data in the end of"\
+			      " the volume."));
+			goto write_MDB;
+		}
+	}
+
+	/* Mark out of volume blocks as used
+	(broken implementations compatibility) */
+	for ( block = nblock; block < (1 << 16); ++block)
+		SET_BLOC_OCCUPATION(priv_data->alloc_map,block);
+
+	/* save the allocation map
+	I do not write until start of allocation blocks 
+	but only until pre-resize end of bitmap blocks
+	because the specifications do _not_ assert that everything
+	until allocation blocks is boot, mdb and alloc */
+	ped_geometry_write(fs->geom, priv_data->alloc_map,
+		PED_BE16_TO_CPU (priv_data->mdb->volume_bitmap_block),
+		( PED_BE16_TO_CPU (priv_data->mdb->total_blocks)
+		  + PED_SECTOR_SIZE * 8 - 1)
+		/ (PED_SECTOR_SIZE * 8));
+
+	/* Update geometry */
+	if (resize) {
+		/* update in fs structure */
+		if (PED_BE16_TO_CPU (mdb->next_allocation) >= nblock)
+			mdb->next_allocation = PED_CPU_TO_BE16 (0);
+		mdb->total_blocks = PED_CPU_TO_BE16 (nblock);
+		mdb->free_blocks = PED_CPU_TO_BE16 (nfree);
+		/* update parted structure */
+		fs->geom->length = geom->length;
+		fs->geom->end = fs->geom->start + geom->length - 1;
+	}
+
+	/* Set the unmounted bit */
+	mdb->volume_attributes |= PED_CPU_TO_BE16 ( 1 << HFS_UNMOUNTED );
+
+	/* Effective write */
+    write_MDB:
+	ped_timer_set_state_name(timer,_("writing HFS Master Directory Block"));
+	if (!hfs_update_mdb(fs)) return 0;
+	ped_timer_update(timer, 1.0);
+
+	return (resize);
+}
+
+/* ----- HFS+ ----- */
+
+#include "file_plus.h"
+#include "advfs_plus.h"
+#include "reloc_plus.h"
+
+static int
+hfsplus_clobber (PedGeometry* geom)
+{
+	unsigned int i = 1;
+	uint8_t				buf[PED_SECTOR_SIZE];
+	HfsMasterDirectoryBlock		*mdb;
+		
+	mdb = (HfsMasterDirectoryBlock *) buf;
+	
 	if (!ped_geometry_read (geom, buf, 2, 1))
 		return 0;
 
-	if (PED_BE16_TO_CPU (*(uint16_t*) buf) == HFS_SIGNATURE)
-		return ped_geometry_duplicate (geom);
-	else
+
+	if (PED_BE16_TO_CPU (mdb->signature) == HFS_SIGNATURE) {
+		/* embedded hfs+ */
+		PedGeometry	*embedded;
+		
+		i = (PED_BE32_TO_CPU(mdb->block_size) / PED_SECTOR_SIZE);
+		embedded = ped_geometry_new (
+		    geom->dev,
+		    (PedSector) geom->start
+		     + PED_BE16_TO_CPU (mdb->start_block)
+		     + (PedSector) PED_BE16_TO_CPU (
+			mdb->old_new.embedded.location.start_block ) * i, 
+		    (PedSector) PED_BE16_TO_CPU (
+			mdb->old_new.embedded.location.block_count ) * i );
+		if (!embedded) i = 0;
+		else {
+			i = hfs_clobber (embedded);
+			ped_geometry_destroy (embedded);
+		}
+	}
+
+	/* non-embedded or envelop destroy as hfs */
+	return ( hfs_clobber (geom) && i );
+}
+
+static int
+hfsplus_close (PedFileSystem *fs)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+
+	if (priv_data->bad_blocks_loaded)
+		hfsplus_free_bad_blocks_list(priv_data->bad_blocks_xtent_list);
+	ped_free(priv_data->alloc_map);
+	hfsplus_file_close (priv_data->extents_file);
+	hfsplus_file_close (priv_data->catalog_file);
+	hfsplus_file_close (priv_data->attributes_file);
+	if (priv_data->free_geom) ped_geometry_destroy (priv_data->plus_geom);
+	if (priv_data->wrapper) hfs_close(priv_data->wrapper);
+	ped_geometry_destroy (fs->geom);
+	ped_free(priv_data->vh);
+	ped_free(priv_data);
+	ped_free(fs);
+
+	return 1;
+}
+
+static PedFileSystem*
+hfsplus_open (PedGeometry* geom)
+{
+	uint8_t			buf[PED_SECTOR_SIZE];
+	PedFileSystem*		fs;
+	HfsPVolumeHeader*	vh;
+	HfsPPrivateFSData* 	priv_data;
+	PedGeometry*		wrapper_geom;
+	HfsPPrivateFile*	allocation_file;
+	unsigned int		map_sectors;
+	
+	fs = (PedFileSystem*) ped_malloc (sizeof (PedFileSystem));
+	if (!fs) goto hpo;
+	vh = (HfsPVolumeHeader*) ped_malloc (sizeof (HfsPVolumeHeader));
+	if (!vh) goto hpo_fs;
+	priv_data = (HfsPPrivateFSData*)ped_malloc (sizeof (HfsPPrivateFSData));
+	if (!priv_data) goto hpo_vh;
+
+	fs->geom = ped_geometry_duplicate (geom);
+	if (!fs->geom) goto hpo_pd;
+	fs->type_specific = (void*) priv_data;
+
+	if ((wrapper_geom = hfs_and_wrapper_probe (geom))) {
+		HfsPrivateFSData* 	hfs_priv_data;
+		PedSector		abs_sect, length;
+		unsigned int		bs;
+
+		ped_geometry_destroy (wrapper_geom);
+		priv_data->wrapper = hfs_open(geom);
+		if (!priv_data->wrapper) goto hpo_gm;
+		hfs_priv_data = (HfsPrivateFSData*)
+			priv_data->wrapper->type_specific;
+		bs = PED_BE32_TO_CPU (hfs_priv_data->mdb->block_size)
+		     / PED_SECTOR_SIZE;
+		abs_sect = (PedSector) geom->start
+			   + (PedSector) PED_BE16_TO_CPU (
+					    hfs_priv_data->mdb->start_block)
+			   + (PedSector) PED_BE16_TO_CPU (
+					    hfs_priv_data->mdb->old_new
+					    .embedded.location.start_block )
+			                 * bs;
+		length = (PedSector) PED_BE16_TO_CPU (
+					    hfs_priv_data->mdb->old_new
+					    .embedded.location.block_count)
+				     * bs;
+		priv_data->plus_geom = ped_geometry_new (geom->dev, abs_sect,
+							 length);
+		if (!priv_data->plus_geom) goto hpo_wr;
+		priv_data->free_geom = 1;
+	} else {
+		priv_data->wrapper = NULL;
+		priv_data->plus_geom = fs->geom;
+		priv_data->free_geom = 0;
+	}
+	
+	if (!ped_geometry_read (priv_data->plus_geom, buf, 2, 1)) goto hpo_pg;
+	memcpy (vh, buf, sizeof (HfsPVolumeHeader));
+
+	if (vh->version != PED_CPU_TO_BE16(HFSP_VERSION)) {
+		if (ped_exception_throw (PED_EXCEPTION_NO_FEATURE,
+		      PED_EXCEPTION_IGNORE_CANCEL,
+		      _("Version %d of HFS+ isn't supported."),
+		      PED_BE16_TO_CPU(vh->version))
+		    != PED_EXCEPTION_IGNORE)
+			goto hpo_pg;
+	}
+
+	if (vh->attributes & PED_CPU_TO_BE32(1<<HFSP_JOURNALED)) {
+		if (ped_exception_throw (PED_EXCEPTION_NO_FEATURE,
+		      PED_EXCEPTION_IGNORE_CANCEL,
+		      _("Journaled HFS+ volumes aren't supported, "\
+		        "you should desactivate the journal "\
+			"before trying any operation on them."))
+		    != PED_EXCEPTION_IGNORE)
+			goto hpo_pg;
+	}
+
+	priv_data->vh = vh;
+	priv_data->bad_blocks_loaded = 0;
+	priv_data->bad_blocks_xtent_nb = 0;
+	priv_data->bad_blocks_xtent_list = NULL;
+	priv_data->extents_file =
+		hfsplus_file_open (fs, PED_CPU_TO_BE32 (HFS_XTENT_ID),
+				   vh->extents_file.extents,
+				   PED_BE64_TO_CPU (
+					vh->extents_file.logical_size )
+				   / PED_SECTOR_SIZE);
+	if (!priv_data->extents_file) goto hpo_pg;
+	priv_data->catalog_file =
+		hfsplus_file_open (fs, PED_CPU_TO_BE32 (HFS_CATALOG_ID),
+				   vh->catalog_file.extents,
+				   PED_BE64_TO_CPU (
+					vh->catalog_file.logical_size )
+				   / PED_SECTOR_SIZE);
+	if (!priv_data->catalog_file) goto hpo_ce;
+	priv_data->attributes_file =
+		hfsplus_file_open (fs, PED_CPU_TO_BE32 (HFSP_ATTRIB_ID),
+				   vh->attributes_file.extents,
+				   PED_BE64_TO_CPU (
+					vh->attributes_file.logical_size)
+				   / PED_SECTOR_SIZE);
+	if (!priv_data->attributes_file) goto hpo_cc;
+
+	/* The code related to attributes file has never been tested
+	   before : warn the user and ask him to report me bugs */
+	if (priv_data->attributes_file->sect_nb != 0) {
+		if (ped_exception_throw (PED_EXCEPTION_WARNING,
+		      PED_EXCEPTION_IGNORE_CANCEL,
+		      _("You have an HFS+ file system that has a feature that "\
+		      "I haven't seen used anywhere. Parted can theoretically "\
+		      "handle it, but the corresponding code has never been "\
+		      "tested, so this might be risky. Please email me so I "\
+		      "can see how it works! <xilun666@libertysurf.fr>"))
+		    != PED_EXCEPTION_IGNORE)
+			goto hpo_cl;
+	}
+
+	map_sectors = ( PED_BE32_TO_CPU (vh->total_blocks) 
+	                + PED_SECTOR_SIZE * 8 - 1 ) / (PED_SECTOR_SIZE * 8);
+	priv_data->alloc_map = (uint8_t*)
+		ped_malloc (map_sectors * PED_SECTOR_SIZE);
+	if (!priv_data->alloc_map) goto hpo_cl;
+	
+	allocation_file =
+		hfsplus_file_open (fs, PED_CPU_TO_BE32 (HFSP_ALLOC_ID),
+				   vh->allocation_file.extents,
+				   PED_BE64_TO_CPU (
+					vh->allocation_file.logical_size)
+				   / PED_SECTOR_SIZE);
+	if (!allocation_file)
+		goto hpo_cl;
+	if (!hfsplus_file_read (allocation_file, priv_data->alloc_map, 0,
+				map_sectors)) {
+		hfsplus_file_close (allocation_file);
+		hfsplus_close(fs);
 		return NULL;
+	}
+	hfsplus_file_close (allocation_file);
+
+	fs->type = &hfsplus_type;
+	fs->checked = ((PED_BE32_TO_CPU (vh->attributes) >> HFS_UNMOUNTED) & 1)
+	      && !((PED_BE32_TO_CPU (vh->attributes) >> HFSP_INCONSISTENT) & 1);
+	
+	return fs;
+
+/*--- clean error handling ---*/
+hpo_cl: hfsplus_file_close (priv_data->attributes_file);
+hpo_cc:	hfsplus_file_close (priv_data->catalog_file);
+hpo_ce:	hfsplus_file_close (priv_data->extents_file);
+hpo_pg: if (priv_data->free_geom) ped_geometry_destroy (priv_data->plus_geom);
+hpo_wr: if (priv_data->wrapper) hfs_close(priv_data->wrapper);
+hpo_gm: ped_geometry_destroy (fs->geom);
+hpo_pd: ped_free(priv_data);
+hpo_vh: ped_free(vh);
+hpo_fs: ped_free(fs);
+hpo:	return NULL;
+}
+
+
+static PedConstraint* 
+hfsplus_get_resize_constraint (const PedFileSystem *fs)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	PedDevice*	dev = fs->geom->dev;
+	PedAlignment	start_align;
+	PedGeometry	start_sector;
+	PedGeometry	full_dev;
+	PedSector	min_size;
+
+	if (!ped_alignment_init (&start_align, fs->geom->start, 0))
+		return NULL;
+	if (!ped_geometry_init (&start_sector, dev, fs->geom->start, 1))
+		return NULL;
+	if (!ped_geometry_init (&full_dev, dev, 0, dev->length - 1))
+		return NULL;
+
+	min_size = hfsplus_get_min_size (fs);
+	if (!min_size) return NULL;
+
+	return ped_constraint_new (&start_align, ped_alignment_any,
+				   &start_sector, &full_dev, min_size,
+				   fs->geom->length);
 }
 
-#ifndef DISCOVER_ONLY
 static int
-hfs_clobber (PedGeometry* geom)
+hfsplus_volume_resize (PedFileSystem* fs, PedGeometry* geom, PedTimer* timer)
 {
-	char	buf[512];
+	uint8_t			buf[PED_SECTOR_SIZE];
+	unsigned int		nblock, nfree, mblock;
+	unsigned int		block, to_free, old_blocks;
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPVolumeHeader* 	vh = priv_data->vh;
+	int			resize = 1;
+	unsigned int		hfsp_sect_block =
+				    ( PED_BE32_TO_CPU (vh->block_size)
+				      / PED_SECTOR_SIZE );
+	HfsPPrivateFile*	allocation_file;
+	unsigned int		map_sectors;
+
+	old_blocks = PED_BE32_TO_CPU (vh->total_blocks);
+
+	/* Clear the unmounted bit */
+	/* and set the implementation code (Apple Creator Code) */
+	vh->attributes &= PED_CPU_TO_BE32 (~( 1 << HFS_UNMOUNTED ));
+	vh->last_mounted_version = PED_CPU_TO_BE32(HFSP_IMPL_Shnk);
+	if (!ped_geometry_read (priv_data->plus_geom, buf, 2, 1))
+		return 0;
+	memcpy (buf, vh, sizeof (HfsPVolumeHeader));
+	if (   !ped_geometry_write (priv_data->plus_geom, buf, 2, 1)
+	    || !ped_geometry_sync (priv_data->plus_geom))
+		return 0;
+
+	ped_timer_reset (timer);
+	ped_timer_set_state_name(timer, _("shrinking"));
+	ped_timer_update(timer, 0.0);
+	/* relocate data */
+	to_free = ( priv_data->plus_geom->length 
+	          - geom->length + hfsp_sect_block
+		  - 1 ) / hfsp_sect_block;
+	block = hfsplus_find_start_pack (fs, to_free);
+	if (!hfsplus_pack_free_space_from_block (fs, block, timer, to_free)) {
+		resize = 0;
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Data relocation has failed."));
+		goto write_VH;
+	}
 
-	memset (buf, 0, 512);
-	return ped_geometry_write (geom, buf, 2, 1);
+	/* Calculate new block number and other VH field */
+	/* nblock must be rounded _down_ */
+	nblock = geom->length / hfsp_sect_block;
+	nfree = PED_BE32_TO_CPU (vh->free_blocks) 
+		- (old_blocks - nblock);
+	/* free block readjustement is only needed when incorrect nblock
+	   was used by my previous implementation, so detect the case */
+	if (priv_data->plus_geom->length < old_blocks
+					   * ( PED_BE32_TO_CPU (vh->block_size)
+					       / PED_SECTOR_SIZE) ) {
+		if (priv_data->plus_geom->length % hfsp_sect_block == 1)
+			nfree++;
+	}
+
+	/* Check that all block after future end are really free */
+	mblock = ( priv_data->plus_geom->length - 2 )
+		 / hfsp_sect_block;
+	if (mblock > old_blocks - 1)
+		mblock = old_blocks - 1;
+	for ( block = nblock;
+	      block < mblock;
+	      block++ ) {
+		if (TST_BLOC_OCCUPATION(priv_data->alloc_map,block)) {
+			resize = 0;
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			      PED_EXCEPTION_CANCEL,
+			      _("Data relocation left some data in the end of"\
+			      " the volume."));
+			goto write_VH;
+		}
+	}
+	
+	/* Mark out of volume blocks as used */
+	map_sectors = ( ( old_blocks + PED_SECTOR_SIZE * 8 - 1 )
+	                / (PED_SECTOR_SIZE * 8) )
+		      * (PED_SECTOR_SIZE * 8);
+	for ( block = nblock; block < map_sectors; ++block)
+		SET_BLOC_OCCUPATION(priv_data->alloc_map, block);
+
+	/* Update geometry */
+	if (resize) {
+		/* update in fs structure */
+		if (PED_BE32_TO_CPU (vh->next_allocation) >= nblock)
+			vh->next_allocation = PED_CPU_TO_BE32 (0);
+		vh->total_blocks = PED_CPU_TO_BE32 (nblock);
+		vh->free_blocks = PED_CPU_TO_BE32 (nfree);
+		/* update parted structure */
+		priv_data->plus_geom->length = geom->length;
+		priv_data->plus_geom->end = priv_data->plus_geom->start
+					    + geom->length - 1;
+	}
+
+	/* Effective write */
+    write_VH:
+    	/* lasts two sectors are allocated by the alternate VH
+	   and a reserved sector, and last block is always reserved */
+	block = (priv_data->plus_geom->length - 1) / hfsp_sect_block;
+	if (block < PED_BE32_TO_CPU (vh->total_blocks))
+		SET_BLOC_OCCUPATION(priv_data->alloc_map, block);
+	block = (priv_data->plus_geom->length - 2) / hfsp_sect_block;
+	if (block < PED_BE32_TO_CPU (vh->total_blocks))
+		SET_BLOC_OCCUPATION(priv_data->alloc_map, block);
+	SET_BLOC_OCCUPATION(priv_data->alloc_map,
+			    PED_BE32_TO_CPU (vh->total_blocks) - 1);
+
+	/* Write the _old_ area to set out of volume blocks as used */
+	map_sectors = ( old_blocks + PED_SECTOR_SIZE * 8 - 1 )
+	              / (PED_SECTOR_SIZE * 8);
+	allocation_file =
+	    hfsplus_file_open ( fs, PED_CPU_TO_BE32 (HFSP_ALLOC_ID),
+			        vh->allocation_file.extents,
+			        PED_BE64_TO_CPU (
+			    	    vh->allocation_file.logical_size )
+			        / PED_SECTOR_SIZE );
+	if (!allocation_file ||
+	    !hfsplus_file_write (allocation_file, priv_data->alloc_map,
+				 0, map_sectors)) {
+		resize = 0;
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Error while writing the allocation file."));
+	} else {
+	/* Write remaining part of allocation bitmap */
+	/* This is necessary to handle pre patch-11 and third party */
+	/* implementations */
+		memset(buf, 0xFF, PED_SECTOR_SIZE);
+		for (block = map_sectors;
+		     block < allocation_file->sect_nb;
+		     ++block) {
+			if (!hfsplus_file_write_sector(allocation_file, buf,
+							block)) {
+				ped_exception_throw (PED_EXCEPTION_WARNING,
+				      PED_EXCEPTION_IGNORE,
+				      _("Error while writing the compatibility "\
+				      "part of the allocation file."));
+				break;
+			}
+		}
+	}
+	if (allocation_file) hfsplus_file_close (allocation_file);
+	ped_geometry_sync (priv_data->plus_geom);
+
+	if (resize) {
+		/* Set the unmounted bit and clear the inconsistent bit */
+		vh->attributes |= PED_CPU_TO_BE32 ( 1 << HFS_UNMOUNTED );
+		vh->attributes &= ~ PED_CPU_TO_BE32 ( 1 << HFSP_INCONSISTENT );
+	}
+	
+	ped_timer_set_state_name(timer, _("writing HFS+ Volume Header"));
+	if (!hfsplus_update_vh(fs))
+		return 0;
+	ped_timer_update(timer, 1.0);
+
+	return (resize);
 }
+
+/* Update the HFS wrapper mdb and bad blocks file to reflect
+   the new geometry of the embedded HFS+ volume */
+static int
+hfsplus_wrapper_update (PedFileSystem* fs)
+{
+	uint8_t			node[PED_SECTOR_SIZE];
+	HfsCPrivateLeafRec	ref;
+	HfsExtentKey		key;
+	HfsNodeDescriptor*	node_desc = (HfsNodeDescriptor*) node;
+	HfsExtentKey*		ret_key;
+	HfsExtDescriptor*	ret_data;
+	unsigned int		i, j;
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPrivateFSData* 	hfs_priv_data = (HfsPrivateFSData*)
+					    priv_data->wrapper->type_specific;
+	unsigned int		hfs_sect_block =
+			PED_BE32_TO_CPU (hfs_priv_data->mdb->block_size)
+			/ PED_SECTOR_SIZE ;
+	PedSector		hfsplus_sect = (PedSector)
+			PED_BE32_TO_CPU (priv_data->vh->total_blocks)
+			* ( PED_BE32_TO_CPU (priv_data->vh->block_size)
+			    / PED_SECTOR_SIZE );
+	unsigned int		hfs_blocks_embedded =
+				    (hfsplus_sect + hfs_sect_block - 1)
+				    / hfs_sect_block;
+	unsigned int		hfs_blocks_embedded_old;
+
+	/* update HFS wrapper MDB */
+	hfs_blocks_embedded_old = PED_BE16_TO_CPU (
+					hfs_priv_data->mdb->old_new
+					.embedded.location.block_count );
+	hfs_priv_data->mdb->old_new.embedded.location.block_count =
+		PED_CPU_TO_BE16 (hfs_blocks_embedded);
+	/* maybe macOS will boot with this */
+	/* update : yes it does \o/ :) */
+	hfs_priv_data->mdb->free_blocks =
+	    PED_CPU_TO_BE16 ( PED_BE16_TO_CPU (hfs_priv_data->mdb->free_blocks)
+	                    + hfs_blocks_embedded_old
+			    - hfs_blocks_embedded );
+	
+	if (!hfs_update_mdb(priv_data->wrapper))
+		return 0;
+
+	/* force reload bad block list */
+	if (hfs_priv_data->bad_blocks_loaded) {
+		hfs_free_bad_blocks_list (hfs_priv_data->bad_blocks_xtent_list);
+		hfs_priv_data->bad_blocks_xtent_list = NULL;
+		hfs_priv_data->bad_blocks_xtent_nb = 0;
+		hfs_priv_data->bad_blocks_loaded = 0;
+	}
+	
+	/* clean HFS wrapper allocation map */
+	for (i = PED_BE16_TO_CPU (
+			hfs_priv_data->mdb->old_new.embedded
+			.location.start_block )
+		 + hfs_blocks_embedded;
+	     i < PED_BE16_TO_CPU (
+	    		hfs_priv_data->mdb->old_new.embedded
+			.location.start_block )
+		 + hfs_blocks_embedded_old;
+	     i++ ) {
+		CLR_BLOC_OCCUPATION(hfs_priv_data->alloc_map, i);
+	}
+	/* and save it */
+	if (!ped_geometry_write (fs->geom, hfs_priv_data->alloc_map,
+				 PED_BE16_TO_CPU (
+				      hfs_priv_data->mdb->volume_bitmap_block ),
+				 ( PED_BE16_TO_CPU (
+				        hfs_priv_data->mdb->total_blocks ) 
+				   + PED_SECTOR_SIZE * 8 - 1 )
+				 / (PED_SECTOR_SIZE * 8)))
+		return 0;
+	if (!ped_geometry_sync (fs->geom))
+		return 0;
+
+
+	/* search and update the bad blocks file */
+	key.key_length = sizeof(key) - 1;
+	key.type = HFS_DATA_FORK;
+	key.file_ID = PED_CPU_TO_BE32 (HFS_BAD_BLOCK_ID);
+	key.start = 0;
+	if (!hfs_btree_search (hfs_priv_data->extent_file,
+			       (HfsPrivateGenericKey*) &key, NULL, 0, &ref)) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("An error occured while looking for the mandatory "\
+		        "bad blocs file."));
+		return 0;
+	}
+	if (!hfs_file_read_sector (hfs_priv_data->extent_file, node,
+				   ref.node_number))
+		return 0;
+	ret_key = (HfsExtentKey*) (node + ref.record_pos);
+	ret_data = (HfsExtDescriptor*) ( node + ref.record_pos
+					 + sizeof (HfsExtentKey) );
+	
+	while (ret_key->type == key.type && ret_key->file_ID == key.file_ID) {
+		for (i = 0; i < HFS_EXT_NB; i++) {
+			if ( ret_data[i].start_block 
+			     == hfs_priv_data->mdb->old_new
+			        .embedded.location.start_block) {
+				ret_data[i].block_count =
+				    hfs_priv_data->mdb->old_new
+				    .embedded.location.block_count;
+				/* found ! : update */
+				if (!hfs_file_write_sector (
+					  hfs_priv_data->extent_file,
+					  node, ref.node_number)
+				    || !ped_geometry_sync(fs->geom))
+					return 0;
+				return 1;
+			}
+		}
+		
+		if (ref.record_number < PED_BE16_TO_CPU (node_desc->rec_nb)) {
+			ref.record_number++;
+		} else {
+			ref.node_number = PED_BE32_TO_CPU (node_desc->next);
+			if (!ref.node_number
+			    || !hfs_file_read_sector(hfs_priv_data->extent_file,
+						     node, ref.node_number))
+				goto bb_not_found;
+			ref.record_number = 1;
+		}
+
+		ref.record_pos = PED_BE16_TO_CPU (*((uint16_t *)
+			    (node+(PED_SECTOR_SIZE - 2*ref.record_number))));
+		ret_key = (HfsExtentKey*) (node + ref.record_pos);
+		ret_data = (HfsExtDescriptor*) ( node + ref.record_pos
+						 + sizeof (HfsExtentKey) );
+	}
+
+bb_not_found:
+	/* not found : not a valid hfs+ wrapper : failure */
+	ped_exception_throw (PED_EXCEPTION_ERROR,
+	      PED_EXCEPTION_CANCEL,
+	      _("It seems there is an error in the HFS wrapper : "\
+	      "the bad blocs file doesn't contain the embedded HFS+ volume."));
+	return 0;
+}
+
+static int
+hfsplus_resize (PedFileSystem* fs, PedGeometry* geom, PedTimer* timer)
+{
+	HfsPPrivateFSData* 	priv_data;
+	PedTimer*		timer_plus;
+	PedGeometry*		embedded_geom;
+	PedSector		hgms;
+
+	/* check preconditions */
+	PED_ASSERT (fs != NULL, return 0);
+	PED_ASSERT (fs->geom != NULL, return 0); 
+	PED_ASSERT (geom != NULL, return 0);
+	PED_ASSERT (fs->geom->dev == geom->dev, return 0);
+	PED_ASSERT ((hgms = hfsplus_get_min_size (fs)) != 0, return 0);
+	
+	priv_data = (HfsPPrivateFSData*) fs->type_specific;
+	
+	if (fs->geom->start != geom->start
+	    || geom->length > fs->geom->length
+	    || geom->length < hgms) {
+		ped_exception_throw (PED_EXCEPTION_NO_FEATURE,
+		      PED_EXCEPTION_CANCEL,
+		      _("Sorry, HFS cannot be resized that way yet."));
+		return 0;
+	}
+
+	if (priv_data->wrapper) {
+		PedSector		red, hgee;
+		HfsPrivateFSData* 	hfs_priv_data = (HfsPrivateFSData*)
+					    priv_data->wrapper->type_specific;
+		unsigned int		hfs_sect_block =
+			    PED_BE32_TO_CPU (hfs_priv_data->mdb->block_size)
+			    / PED_SECTOR_SIZE;
+		
+		/* There is a wrapper so we must calculate the new geometry
+		   of the embedded HFS+ volume */
+		red = ( (fs->geom->length - geom->length + hfs_sect_block - 1)
+			/ hfs_sect_block ) * hfs_sect_block;
+		/* Can't we shrink the hfs+ volume by the desired size ? */
+		hgee = hfsplus_get_empty_end (fs);
+		if (!hgee) return 0;
+		if (red > priv_data->plus_geom->length - hgee) {
+			/* No, shrink hfs+ by the greatest possible value */
+			hgee = ((hgee + hfs_sect_block - 1) / hfs_sect_block)
+			       * hfs_sect_block;
+			red = priv_data->plus_geom->length - hgee;
+		}
+		embedded_geom = ped_geometry_new (geom->dev,
+						  priv_data->plus_geom->start,
+						  priv_data->plus_geom->length
+						  - red);
+		
+		/* There is a wrapper so the resize process is a two stages
+		   process (embedded resizing then wrapper resizing) :
+		   we create a sub timer */
+		ped_timer_reset (timer);
+		ped_timer_set_state_name (timer,
+					  _("shrinking embedded HFS+ volume"));
+		ped_timer_update(timer, 0.0);
+		timer_plus = ped_timer_new_nested (timer, 0.98);
+	} else {
+		/* No wrapper : the desired geometry is the desired
+		   HFS+ volume geometry */
+		embedded_geom = geom;
+		timer_plus = timer;
+	}
+		
+	/* Resize the HFS+ volume */
+	if (!hfsplus_volume_resize (fs, embedded_geom, timer_plus)) {
+		if (timer_plus != timer) ped_timer_destroy_nested (timer_plus);
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Resizing the HFS+ volume has failed."));
+		return 0;
+	}
+
+	if (priv_data->wrapper) {
+		ped_geometry_destroy (embedded_geom);
+		ped_timer_destroy_nested (timer_plus);
+		ped_timer_set_state_name(timer, _("shrinking HFS wrapper"));
+		timer_plus = ped_timer_new_nested (timer, 0.02);
+		/* There's a wrapper : second stage = resizing it */
+		if (!hfsplus_wrapper_update (fs)
+		    || !hfs_resize (priv_data->wrapper, geom, timer_plus)) {
+			ped_timer_destroy_nested (timer_plus);
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			      PED_EXCEPTION_CANCEL,
+			      _("Updating the HFS wrapper has failed."));
+			return 0;
+		}
+		ped_timer_destroy_nested (timer_plus);
+	}
+	ped_timer_update(timer, 1.0);
+
+	return 1;
+}
+
+#ifdef HFS_EXTRACT_FS
+/* The following is for debugging purpose only, NOT for packaging */
+
+#include <stdio.h>
+
+uint8_t* extract_buffer = NULL;
+
+static int
+hfs_extract_file(const char* filename, HfsPrivateFile* hfs_file)
+{
+	FILE*		fout;
+	PedSector	sect;
+
+	fout = fopen(filename, "w");
+	if (!fout) return 0;
+
+	for (sect = 0; sect < hfs_file->sect_nb; ++sect) {
+		if (!hfs_file_read_sector(hfs_file, extract_buffer, sect))
+			return 0;
+		if (!fwrite(extract_buffer, PED_SECTOR_SIZE, 1, fout))
+			return 0;
+	}
+
+	fclose(fout);
+	return 1;
+}
+
+static int
+hfs_extract_bitmap(const char* filename, PedFileSystem* fs)
+{
+	HfsPrivateFSData*		priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsMasterDirectoryBlock*	mdb = priv_data->mdb;
+	unsigned int 	count;
+	FILE*		fout;
+	PedSector	sect;
+	
+	fout = fopen(filename, "w");
+	if (!fout) return 0;
+
+	for (sect = PED_BE16_TO_CPU(mdb->volume_bitmap_block);
+	     sect < PED_BE16_TO_CPU(mdb->start_block);
+	     sect += count) {
+		count = (PED_BE16_TO_CPU(mdb->start_block)-sect) < MAX_BUFF ?
+			(PED_BE16_TO_CPU(mdb->start_block)-sect) : MAX_BUFF;
+		if (!ped_geometry_read(fs->geom, extract_buffer, sect, count))
+			return 0;
+		if (!fwrite(extract_buffer, count * PED_SECTOR_SIZE, 1, fout))
+			return 0;
+	}
+
+	fclose(fout);
+	return 1;
+}
+
+static int
+hfs_extract (PedFileSystem* fs, PedTimer* timer)
+{
+	HfsPrivateFSData*	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+
+	ped_exception_throw (PED_EXCEPTION_INFORMATION, PED_EXCEPTION_OK,
+		_("This is not a real %s check. This is going to extract "\
+		   "special low level files for debugging purposes."), "HFS");
+
+	extract_buffer = ped_malloc(MAX_BUFF * PED_SECTOR_SIZE);
+	if (!extract_buffer) return 0;
+
+	hfs_extract_file(HFS_CATALOG_FILENAME, priv_data->catalog_file);
+	hfs_extract_file(HFS_EXTENTS_FILENAME, priv_data->extent_file);
+	hfs_extract_bitmap(HFS_BITMAP_FILENAME, fs);
+
+	ped_free(extract_buffer); extract_buffer = NULL;
+	return 0; /* nothing has been fixed by us ! */
+}
+
+static int
+hfsplus_extract_file(const char* filename, HfsPPrivateFile* hfsp_file)
+{
+	FILE*		fout;
+	unsigned int	cp_sect;
+	PedSector	rem_sect;
+
+	fout = fopen(filename, "w");
+	if (!fout) return 0;
+
+	for (rem_sect = hfsp_file->sect_nb; rem_sect; rem_sect -= cp_sect) {
+		cp_sect = rem_sect < MAX_BUFF ? rem_sect : MAX_BUFF;
+		if (!hfsplus_file_read(hfsp_file, extract_buffer, 
+				       hfsp_file->sect_nb - rem_sect, cp_sect))
+			return 0;
+		if (!fwrite(extract_buffer, cp_sect * PED_SECTOR_SIZE, 1, fout))
+			return 0;
+	}
+	
+	fclose(fout);
+	return 1;
+}
+
+/* TODO : use the timer to report what is happening */
+/* TODO : use exceptions to report errors */
+static int
+hfsplus_extract (PedFileSystem* fs, PedTimer* timer)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPVolumeHeader*	vh = priv_data->vh;
+	HfsPPrivateFile*	bitmap_file;
+	HfsPPrivateFile*	startup_file;
+
+	if (priv_data->wrapper) {
+		/* TODO : create nested timer */
+		hfs_extract (priv_data->wrapper, timer);
+	}
+
+	ped_exception_throw (PED_EXCEPTION_INFORMATION, PED_EXCEPTION_OK,
+		_("This is not a real %s check. This is going to extract "\
+		  "special low level files for debugging purposes."), "HFS+");
+
+	extract_buffer = ped_malloc(MAX_BUFF * PED_SECTOR_SIZE);
+	if (!extract_buffer) return 0;
+
+	hfsplus_extract_file(HFSP_CATALOG_FILENAME, priv_data->catalog_file);
+	hfsplus_extract_file(HFSP_EXTENTS_FILENAME, priv_data->extents_file);
+	hfsplus_extract_file(HFSP_ATTRIB_FILENAME, priv_data->attributes_file);
+	bitmap_file = hfsplus_file_open(fs, PED_CPU_TO_BE32(HFSP_ALLOC_ID),
+					vh->allocation_file.extents,
+					PED_BE64_TO_CPU (
+					   vh->allocation_file.logical_size)
+					/ PED_SECTOR_SIZE);
+	if (bitmap_file) {
+		hfsplus_extract_file(HFSP_BITMAP_FILENAME, bitmap_file);
+		hfsplus_file_close(bitmap_file); bitmap_file = NULL;
+	}
+
+	startup_file = hfsplus_file_open(fs, PED_CPU_TO_BE32(HFSP_STARTUP_ID),
+					vh->startup_file.extents,
+					PED_BE64_TO_CPU (
+					   vh->startup_file.logical_size)
+					/ PED_SECTOR_SIZE);
+	if (startup_file) {
+		hfsplus_extract_file(HFSP_STARTUP_FILENAME, startup_file);
+		hfsplus_file_close(startup_file); startup_file = NULL;
+	}
+
+	ped_free(extract_buffer); extract_buffer = NULL;
+	return 0; /* nothing has been fixed by us ! */
+}
+#endif /* HFS_EXTRACT_FS */
+
 #endif /* !DISCOVER_ONLY */
 
 static PedFileSystemOps hfs_ops = {
 	probe:		hfs_probe,
 #ifndef DISCOVER_ONLY
 	clobber:	hfs_clobber,
+	open:		hfs_open,
+	create:		NULL,
+	close:		hfs_close,
+#ifndef HFS_EXTRACT_FS
+	check:		NULL,
 #else
+	check:		hfs_extract,
+#endif
+	copy:		NULL,
+	resize:		hfs_resize,
+	get_create_constraint:	NULL,
+	get_resize_constraint:	hfs_get_resize_constraint,
+	get_copy_constraint:	NULL,
+#else /* DISCOVER_ONLY */
 	clobber:	NULL,
+	open:		NULL,
+	create:		NULL,
+	close:		NULL,
+	check:		NULL,
+	copy:		NULL,
+	resize:		NULL,
+	get_create_constraint:	NULL,
+	get_resize_constraint:	NULL,
+	get_copy_constraint:	NULL,
+#endif /* DISCOVER_ONLY */
+};
+
+static PedFileSystemOps hfsplus_ops = {
+	probe:		hfsplus_probe,
+#ifndef DISCOVER_ONLY
+	clobber:	hfsplus_clobber,
+	open:		hfsplus_open,
+	create:		NULL,
+	close:		hfsplus_close,
+#ifndef HFS_EXTRACT_FS
+	check:		NULL,
+#else
+	check:		hfsplus_extract,
 #endif
+	copy:		NULL,
+	resize:		hfsplus_resize,
+	get_create_constraint:	NULL,
+	get_resize_constraint:	hfsplus_get_resize_constraint,
+	get_copy_constraint:	NULL,
+#else /* DISCOVER_ONLY */
+	clobber:	NULL,
 	open:		NULL,
 	create:		NULL,
 	close:		NULL,
@@ -76,23 +1158,32 @@
 	get_create_constraint:	NULL,
 	get_resize_constraint:	NULL,
 	get_copy_constraint:	NULL,
+#endif /* DISCOVER_ONLY */
 };
 
+
 static PedFileSystemType hfs_type = {
 	next:	NULL,
 	ops:	&hfs_ops,
 	name:	"hfs"
 };
 
+static PedFileSystemType hfsplus_type = {
+	next:	NULL,
+	ops:	&hfsplus_ops,
+	name:	"hfs+"
+};
+
 void
 ped_file_system_hfs_init ()
 {
 	ped_file_system_type_register (&hfs_type);
+	ped_file_system_type_register (&hfsplus_type);
 }
 
 void
 ped_file_system_hfs_done ()
 {
 	ped_file_system_type_unregister (&hfs_type);
+	ped_file_system_type_unregister (&hfsplus_type);
 }
-
diff -Nru parted-1.6.19/libparted/fs_hfs/hfs.h parted-1.6.19-hfs-16/libparted/fs_hfs/hfs.h
--- parted-1.6.19/libparted/fs_hfs/hfs.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/hfs.h	2004-12-03 15:31:45.151889000 +0100
@@ -0,0 +1,589 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _HFS_H
+#define _HFS_H
+
+/* WARNING : bn is used 2 times in theses macro */
+/* so _never_ use side effect operators when using them */
+#define TST_BLOC_OCCUPATION(tab,bn) \
+	(((tab)[(bn)/8])  &  (1<<(7-((bn)&7))))
+#define SET_BLOC_OCCUPATION(tab,bn) \
+	(((tab)[(bn)/8]) |=  (1<<(7-((bn)&7))))
+#define CLR_BLOC_OCCUPATION(tab,bn) \
+	(((tab)[(bn)/8]) &= ~(1<<(7-((bn)&7))))
+
+/* Size of the copy buffers */
+#define MAX_BUFF 256 /* in blocks */
+
+/* Apple Creator Codes follow */
+#define HFSP_IMPL_Shnk	0x53686e6b
+#define HFSP_IMPL_Xpnd	0x58706e64
+#define HFSP_IMPL_Resz	0x5265737a
+#define HFSP_IMPL_PHpx	0x50482b78
+#define HFSP_IMPL_traP  0x74726150
+#define HFSP_IMPL_GnuP  0x476e7550
+
+#define HFS_SIGNATURE	0x4244
+#define HFSP_SIGNATURE	0x482B
+#define HFSX_SIGNATURE  0x4858
+
+#define HFSP_VERSION	 4
+#define HFSX_VERSION	 5
+
+#define HFS_HARD_LOCK	 7
+#define HFS_UNMOUNTED	 8
+#define HFS_BAD_SPARED	 9
+#define HFS_SOFT_LOCK	15
+#define HFSP_NO_CACHE	10
+#define HFSP_INCONSISTENT 11
+#define HFSP_REUSE_CNID	12
+#define HFSP_JOURNALED	13
+
+#define HFS_IDX_NODE	0x00
+#define HFS_HDR_NODE	0x01
+#define HFS_MAP_NODE	0x02
+#define HFS_LEAF_NODE	0xFF
+
+#define HFS_FIRST_REC	0x0E
+#define HFS_NSD_HD_REC	0x78
+#define HFS_MAP_REC	0xF8
+
+#define HFS_DATA_FORK	0x00
+#define HFS_RES_FORK	0xFF
+
+#define HFS_CAT_DIR	0x01
+#define HFS_CAT_FILE	0x02
+#define HFS_CAT_DIR_TH	0x03
+#define HFS_CAT_FILE_TH	0x04
+
+#define HFSP_ATTR_INLINE	0x10
+#define HFSP_ATTR_FORK		0x20
+#define HFSP_ATTR_EXTENTS	0x30
+
+#define HFS_ROOT_PAR_ID		0x01
+#define HFS_ROOT_DIR_ID		0x02
+#define HFS_XTENT_ID		0x03
+#define HFS_CATALOG_ID		0x04
+#define HFS_BAD_BLOCK_ID	0x05
+#define HFSP_ALLOC_ID		0x06
+#define HFSP_STARTUP_ID		0x07
+#define HFSP_ATTRIB_ID		0x08
+#define HFSP_BOGUS_ID		0x0F
+#define HFSP_FIRST_AV_ID	0x10
+
+#define HFS_EXT_NB	3
+#define HFSP_EXT_NB	8
+
+/* Define the filenames used by the FS extractor */
+#ifdef HFS_EXTRACT_FS
+
+/* TODO : extract the mdb and store in a file */
+#define HFS_CATALOG_FILENAME	"catalog.hfs"
+#define HFS_EXTENTS_FILENAME	"extents.hfs"
+#define HFS_BITMAP_FILENAME	"bitmap.hfs"
+
+/* TODO : extract the vh and store in a file */
+#define HFSP_CATALOG_FILENAME	"catalog.hfsplus"
+#define HFSP_EXTENTS_FILENAME	"extents.hfsplus"
+#define HFSP_BITMAP_FILENAME	"bitmap.hfsplus"
+#define HFSP_ATTRIB_FILENAME	"attributes.hfsplus"
+#define HFSP_STARTUP_FILENAME	"startup.hfsplus"
+
+#endif /* HFS_EXTRACT_FS */
+
+static PedFileSystemType hfs_type;
+static PedFileSystemType hfsplus_type;
+
+
+
+/* ----------------------------------- */
+/* --      HFS DATA STRUCTURES      -- */
+/* ----------------------------------- */
+
+/* Extent descriptor */
+struct __attribute__ ((packed)) _HfsExtDescriptor {
+	uint16_t	start_block;
+	uint16_t	block_count;
+};
+typedef struct _HfsExtDescriptor HfsExtDescriptor;
+typedef HfsExtDescriptor HfsExtDataRec[HFS_EXT_NB];
+
+/* Volume header */
+struct __attribute__ ((packed)) _HfsMasterDirectoryBlock {
+	uint16_t	signature;
+	uint32_t	create_date;
+	uint32_t	modify_date;
+	uint16_t	volume_attributes;
+	uint16_t	files_in_root;
+	uint16_t	volume_bitmap_block;	/* in sectors */
+	uint16_t	next_allocation;
+	uint16_t	total_blocks;
+	uint32_t	block_size;		/* in bytes */
+	uint32_t	def_clump_size;		/* in bytes */
+	uint16_t	start_block;		/* in sectors */
+	uint32_t	next_free_node;
+	uint16_t	free_blocks;
+	uint8_t		name_length;
+	char		name[27];
+	uint32_t	backup_date;
+	uint16_t	backup_number;
+	uint32_t	write_count;
+	uint32_t	extents_clump;
+	uint32_t	catalog_clump;
+	uint16_t	dirs_in_root;
+	uint32_t	file_count;
+	uint32_t	dir_count;
+	uint32_t	finder_info[8];
+	union __attribute__ ((packed)) {
+		struct __attribute__ ((packed)) {
+			uint16_t	volume_cache_size;	/* in blocks */
+			uint16_t	bitmap_cache_size;	/* in blocks */
+			uint16_t	common_cache_size;	/* in blocks */
+		}		legacy;
+		struct __attribute__ ((packed)) {
+			uint16_t	signature;
+			HfsExtDescriptor location;
+		}		embedded;
+	}		old_new;
+	uint32_t	extents_file_size;  /* in bytes, block size multiple */
+	HfsExtDataRec	extents_file_rec;
+	uint32_t	catalog_file_size;  /* in bytes, block size multiple */
+	HfsExtDataRec	catalog_file_rec;
+};
+typedef struct _HfsMasterDirectoryBlock HfsMasterDirectoryBlock;
+
+/* B*-Tree Node Descriptor */
+struct __attribute__ ((packed)) _HfsNodeDescriptor {
+	uint32_t	next;
+	uint32_t	previous;
+	int8_t		type;
+	uint8_t		height;
+	uint16_t	rec_nb;
+	uint16_t	reserved;
+};
+typedef struct _HfsNodeDescriptor HfsNodeDescriptor;
+
+/* Header record of a whole B*-Tree */
+struct __attribute__ ((packed)) _HfsHeaderRecord {
+	uint16_t	depth;
+	uint32_t	root_node;
+	uint32_t	leaf_records;
+	uint32_t	first_leaf_node;
+	uint32_t	last_leaf_node;
+	uint16_t	node_size;
+	uint16_t	max_key_len;
+	uint32_t	total_nodes;
+	uint32_t	free_nodes;
+	int8_t		reserved[76];
+};
+typedef struct _HfsHeaderRecord HfsHeaderRecord;
+
+/* Catalog key for B*-Tree lookup in the catalog file */
+struct __attribute__ ((packed)) _HfsCatalogKey {
+	uint8_t		key_length; /* length of the key without key_length */
+	uint8_t		reserved;
+	uint32_t	parent_ID;
+	uint8_t		name_length;
+	char		name[31];   /* in fact physicaly 1 upto 31 */
+};
+typedef struct _HfsCatalogKey HfsCatalogKey;
+
+/* Extents overflow key for B*-Tree lookup */
+struct __attribute__ ((packed)) _HfsExtentKey {
+	uint8_t		key_length; /* length of the key without key_length */
+	uint8_t		type;	    /* data or ressource fork */
+	uint32_t	file_ID;
+	uint16_t	start;
+};
+typedef struct _HfsExtentKey HfsExtentKey;
+
+/* Catalog subdata case directory */
+struct __attribute__ ((packed)) _HfsDir {
+	uint16_t	flags;
+	uint16_t	valence;	/* number of files in this directory */
+	uint32_t	dir_ID;
+	uint32_t	create_date;
+	uint32_t	modify_date;
+	uint32_t	backup_date;
+	int8_t		DInfo[16];	/* used by Finder, handle as reserved */
+	int8_t		DXInfo[16];	/* used by Finder, handle as reserved */
+	uint32_t	reserved[4];
+};
+typedef struct _HfsDir HfsDir;
+
+/* Catalog subdata case file */
+struct __attribute__ ((packed)) _HfsFile {
+	int8_t		flags;
+	int8_t		type;		/* should be 0 */
+	int8_t		FInfo[16];	/* used by Finder, handle as reserved */
+	uint32_t	file_ID;
+	uint16_t	data_start_block;
+	uint32_t	data_sz_byte;
+	uint32_t	data_sz_block;
+	uint16_t	res_start_block;
+	uint32_t	res_sz_byte;
+	uint32_t	res_sz_block;
+	uint32_t	create_date;
+	uint32_t	modify_date;
+	uint32_t	backup_date;
+	int8_t		FXInfo[16];	/* used by Finder, handle as reserved */
+	uint16_t	clump_size;
+	HfsExtDataRec	extents_data;
+	HfsExtDataRec	extents_res;
+	uint32_t	reserved;
+};
+typedef struct _HfsFile HfsFile;
+
+/* Catalog subdata case directory thread */
+struct __attribute__ ((packed)) _HfsDirTh {
+	uint32_t	reserved[2];
+	uint32_t	parent_ID;
+	int8_t		name_length;
+	char		name[31];
+};
+typedef struct _HfsDirTh HfsDirTh;
+
+/* Catalog subdata case file thread */
+typedef struct _HfsDirTh HfsFileTh;	/* same as directory thread */
+
+/* Catalog data */
+struct __attribute__ ((packed)) _HfsCatalog {
+	int8_t		type;
+	int8_t		reserved;
+	union {
+		HfsDir		dir;
+		HfsFile		file;
+		HfsDirTh	dir_th;
+		HfsFileTh	file_th;
+	} 		sel;
+};
+typedef struct _HfsCatalog HfsCatalog;
+
+
+
+/* ------------------------------------ */
+/* --      HFS+ DATA STRUCTURES      -- */
+/* ------------------------------------ */
+
+/* documented since 2004 in tn1150 */
+struct __attribute__ ((packed)) _HfsPPerms {
+	uint32_t	owner_ID;
+	uint32_t	group_ID;
+	uint32_t	permissions;
+	uint32_t	special_devices;
+};
+typedef struct _HfsPPerms HfsPPerms;
+
+/* HFS+ extent descriptor*/
+struct __attribute__ ((packed)) _HfsPExtDescriptor {
+	uint32_t	start_block;
+	uint32_t	block_count;
+};
+typedef struct _HfsPExtDescriptor HfsPExtDescriptor;
+typedef HfsPExtDescriptor HfsPExtDataRec[HFSP_EXT_NB];
+
+/* HFS+ fork data structure */
+struct __attribute__ ((packed)) _HfsPForkData {
+	uint64_t	logical_size;
+	uint32_t	clump_size;
+	uint32_t	total_blocks;
+	HfsPExtDataRec	extents;
+};
+typedef struct _HfsPForkData HfsPForkData;
+
+/* HFS+ catalog node ID */
+typedef uint32_t HfsPNodeID;
+
+/* HFS+ file names */
+typedef uint16_t unichar;
+struct __attribute__ ((packed)) _HfsPUniStr255 {
+	uint16_t	length;
+	unichar		unicode[255];	/* 1 upto 255 */
+};
+typedef struct _HfsPUniStr255 HfsPUniStr255;
+
+/* HFS+ volume header */
+struct __attribute__ ((packed)) _HfsPVolumeHeader {
+	uint16_t	signature;
+	uint16_t	version;
+	uint32_t	attributes;
+	uint32_t	last_mounted_version;
+	uint32_t	reserved;
+	
+	uint32_t	create_date;
+	uint32_t	modify_date;
+	uint32_t	backup_date;
+	uint32_t	checked_date;
+	
+	uint32_t	file_count;
+	uint32_t	dir_count;
+	
+	uint32_t	block_size;
+	uint32_t	total_blocks;
+	uint32_t	free_blocks;
+	
+	uint32_t	next_allocation;
+	uint32_t	res_clump_size;
+	uint32_t	data_clump_size;
+	HfsPNodeID	next_catalog_ID;
+	
+	uint32_t	write_count;
+	uint64_t	encodings_bitmap;
+	
+	uint8_t		finder_info[32];
+	
+	HfsPForkData	allocation_file;
+	HfsPForkData	extents_file;
+	HfsPForkData	catalog_file;
+	HfsPForkData	attributes_file;
+	HfsPForkData	startup_file;
+};
+typedef struct _HfsPVolumeHeader HfsPVolumeHeader;
+
+/* HFS+ B-Tree Node Descriptor */ /* same as HFS btree */
+struct __attribute__ ((packed)) _HfsPNodeDescriptor {
+	uint32_t	next;
+	uint32_t	previous;
+	int8_t		type;
+	uint8_t		height;
+	uint16_t	rec_nb;
+	uint16_t	reserved;
+};
+typedef struct _HfsPNodeDescriptor HfsPNodeDescriptor;
+
+/* Header record of a whole HFS+ B-Tree */
+struct __attribute__ ((packed)) _HfsPHeaderRecord {
+	uint16_t	depth;
+	uint32_t	root_node;
+	uint32_t	leaf_records;
+	uint32_t	first_leaf_node;
+	uint32_t	last_leaf_node;
+	uint16_t	node_size;
+	uint16_t	max_key_len;
+	uint32_t	total_nodes;
+	uint32_t	free_nodes;	/* same as hfs btree until here */
+	uint16_t	reserved1;
+	
+	uint32_t	clump_size;
+	uint8_t		btree_type;	/* must be 0 for HFS+ B-Tree */
+	uint8_t		reserved2;
+	uint32_t	attributes;
+	uint32_t	reserved3[16];
+};
+typedef struct _HfsPHeaderRecord HfsPHeaderRecord;
+
+/* Catalog key for B-Tree lookup in the HFS+ catalog file */
+struct __attribute__ ((packed)) _HfsPCatalogKey {
+	uint16_t	key_length;
+	HfsPNodeID	parent_ID;
+	HfsPUniStr255	node_name;
+};
+typedef struct _HfsPCatalogKey HfsPCatalogKey;
+
+/* HFS+ catalog subdata case dir */
+struct __attribute__ ((packed)) _HfsPDir {
+	uint16_t	flags;
+	uint32_t	valence;
+	HfsPNodeID	dir_ID;
+	uint32_t	create_date;
+	uint32_t	modify_date;
+	uint32_t	attrib_mod_date;
+	uint32_t	access_date;
+	uint32_t	backup_date;
+	HfsPPerms	permissions;
+	int8_t		DInfo[16];	/* used by Finder, handle as reserved */
+	int8_t		DXInfo[16];	/* used by Finder, handle as reserved */
+	uint32_t	text_encoding;
+	uint32_t	reserved;
+};
+typedef struct _HfsPDir HfsPDir;
+
+/* HFS+ catalog subdata case file */
+struct __attribute__ ((packed)) _HfsPFile {
+	uint16_t	flags;
+	uint32_t	reserved1;
+	HfsPNodeID	file_ID;
+	uint32_t	create_date;
+	uint32_t	modify_date;
+	uint32_t	attrib_mod_date;
+	uint32_t	access_date;
+	uint32_t	backup_date;
+	HfsPPerms	permissions;
+	int8_t		FInfo[16];	/* used by Finder, handle as reserved */
+	int8_t		FXInfo[16];	/* used by Finder, handle as reserved */
+	uint32_t	text_encoding;
+	uint32_t	reserved2;
+	
+	HfsPForkData	data_fork;
+	HfsPForkData	res_fork;
+};
+typedef struct _HfsPFile HfsPFile;
+
+/* HFS+ catalog subdata case thread */
+struct __attribute__ ((packed)) _HfsPThread {
+	int16_t		reserved;
+	HfsPNodeID	parent_ID;
+	HfsPUniStr255	node_name;
+};
+typedef struct _HfsPThread HfsPDirTh;
+typedef struct _HfsPThread HfsPFileTh;
+
+/* HFS+ Catalog leaf data */
+struct __attribute__ ((packed)) _HfsPCatalog {
+	int16_t		type;
+	union {
+		HfsPDir		dir;
+		HfsPFile	file;
+		HfsPDirTh	dir_th;
+		HfsPFileTh	file_th;
+	}		sel;
+};
+typedef struct _HfsPCatalog HfsPCatalog;
+
+/* HFS+ extents file key */
+struct __attribute__ ((packed)) _HfsPExtentKey {
+	uint16_t	key_length;
+	uint8_t		type;
+	uint8_t		pad;
+	HfsPNodeID	file_ID;
+	uint32_t	start;
+};
+typedef struct _HfsPExtentKey HfsPExtentKey;
+
+/* extent file data is HfsPExtDataRec */
+
+/* Fork data attribute file */
+struct __attribute__ ((packed)) _HfsPForkDataAttr {
+	uint32_t	record_type;
+	uint32_t	reserved;
+	union __attribute__ ((packed)) {
+		HfsPForkData	fork;
+		HfsPExtDataRec	extents;
+	}		fork_res;
+};
+typedef struct _HfsPForkDataAttr HfsPForkDataAttr;
+
+
+
+/* ---------------------------------------- */
+/* --      INTERNAL DATA STRUCTURES      -- */
+/* ---------------------------------------- */
+
+/* Data of an opened HFS file */
+struct _HfsPrivateFile {
+	PedSector		sect_nb;
+	PedFileSystem*		fs;
+	uint32_t		CNID;		/* disk order (BE) */
+	HfsExtDataRec		first;		/* disk order (BE) */
+	HfsExtDataRec		cache;		/* disk order (BE) */
+	uint16_t		start_cache;	/* CPU order */
+};
+typedef struct _HfsPrivateFile HfsPrivateFile;
+
+/* To store bad block list */
+struct _HfsPrivateLinkExtent {
+	HfsExtDescriptor		extent;
+	struct _HfsPrivateLinkExtent*	next;
+};
+typedef struct _HfsPrivateLinkExtent HfsPrivateLinkExtent;
+
+/* HFS Filesystem specific data */
+struct _HfsPrivateFSData {
+	uint8_t			alloc_map[(1<<16) / 8];
+	HfsMasterDirectoryBlock* mdb;
+	HfsPrivateFile*		extent_file;
+	HfsPrivateFile*		catalog_file;
+	char			bad_blocks_loaded;
+	unsigned int 		bad_blocks_xtent_nb;
+	HfsPrivateLinkExtent*	bad_blocks_xtent_list;
+};
+typedef struct _HfsPrivateFSData HfsPrivateFSData;
+
+/* Generic btree key */
+struct __attribute__ ((packed)) _HfsPrivateGenericKey {
+	uint8_t		key_length;
+	uint8_t		key_content[1];		/* we use 1 as a minimum size */
+};
+typedef struct _HfsPrivateGenericKey HfsPrivateGenericKey;
+
+/* ----- HFS+ ----- */
+
+/* Data of an opened HFS file */
+struct _HfsPPrivateFile {
+	PedSector		sect_nb;
+	PedFileSystem*		fs;
+	HfsPNodeID		CNID;		/* disk order (BE) */
+	HfsPExtDataRec		first;		/* disk order (BE) */
+	HfsPExtDataRec		cache;		/* disk order (BE) */
+	uint32_t		start_cache;	/* CPU order */
+};
+typedef struct _HfsPPrivateFile HfsPPrivateFile;
+
+struct _HfsPPrivateExtent {
+	PedSector		start_sector;
+	PedSector		sector_count;
+};
+typedef struct _HfsPPrivateExtent HfsPPrivateExtent;
+
+/* To store bad block list */
+struct _HfsPPrivateLinkExtent {
+	HfsPExtDescriptor		extent;
+	struct _HfsPPrivateLinkExtent*	next;
+};
+typedef struct _HfsPPrivateLinkExtent HfsPPrivateLinkExtent;
+
+/* HFS+ filesystem specific data */
+struct _HfsPPrivateFSData {
+	PedFileSystem*		wrapper;      /* NULL if hfs+ is not embedded */
+	PedGeometry*		plus_geom;    /* Geometry of HFS+ _volume_ */
+	char			free_geom;    /* 1 = plus_geom must be freed */
+	uint8_t*		alloc_map;
+	HfsPVolumeHeader*	vh;
+	HfsPPrivateFile*	extents_file;
+	HfsPPrivateFile*	catalog_file;
+	HfsPPrivateFile*	attributes_file;
+	char			bad_blocks_loaded;
+	unsigned int 		bad_blocks_xtent_nb;
+	HfsPPrivateLinkExtent*	bad_blocks_xtent_list;
+};
+typedef struct _HfsPPrivateFSData HfsPPrivateFSData;
+
+/* Generic + btree key */
+struct __attribute__ ((packed)) _HfsPPrivateGenericKey {
+	uint16_t	key_length;
+	uint8_t		key_content[1];		/* we use 1 as a minimum size */
+};
+typedef struct _HfsPPrivateGenericKey HfsPPrivateGenericKey;
+
+/* ---- common ---- */
+
+/* node and lead record reference for a BTree search */
+struct _HfsCPrivateLeafRec {
+	unsigned int	node_size;	/* in sectors */
+	unsigned int	node_number;
+	unsigned int	record_pos;
+	unsigned int	record_number;
+};
+typedef struct _HfsCPrivateLeafRec HfsCPrivateLeafRec;
+
+extern uint8_t* hfs_block;
+extern uint8_t* hfsp_block;
+
+#endif /* _HFS_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/HISTORY parted-1.6.19-hfs-16/libparted/fs_hfs/HISTORY
--- parted-1.6.19/libparted/fs_hfs/HISTORY	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/HISTORY	2004-12-03 15:32:08.809292000 +0100
@@ -0,0 +1,112 @@
+## modifications						dd-mm-yyyy
+---------------------- PATCH FOR PARTED 1.6.5 ----------------------------
+ 1 initial revision						07-04-2003
+ 2 one pass resizing, removal of debug info			08-04-2003
+ 3 safe abort if resize failed, code cleanups, timer,		10-04-2003
+   source file split, won't resize if not unmounted,
+   only relocate data if needed, minimize disk operations
+ 4 memory leaks removal, code cleanups, resize hfs+ code,	17-04-2003
+   more checks, minor hfs resize bugfix, probe code
+   returns real geometry
+ 5 hfs+ resize bugfixes :					19-04-2003
+   * fragmented fs could be corrupted
+   * VH wasn't written on error during alloc map writing
+   * attributes file could be corrupted
+ 6 Use PedSector to be able to use 2To+ HD			23-04-2003
+   Minor probe bugfix, Cleanups, HFS+ Timer tuning,
+ 7 80 columns indentation					23-04-2003
+ 8 Bugfix free blocks calculation in wrapper
+   (makes Mac OS boot !)					28-04-2003
+---------------------- PATCH FOR PARTED 1.6.6 ----------------------------
+ 9 Don't destroy the file being worked on in case of
+   interruption of Parted					28-10-2003
+---------------------- PATCH FOR PARTED 1.6.10 ---------------------------
+10 Regression tests, URL correction, In effect_move_extent :
+   corrected memory leak & corrected a bug in precondition checks
+   Added error messages, Check ped_alloc results
+   Use macro for test / set / clear in the allocation bitmap
+   Light probe correction, Check return value of get_empty_end
+   Moved dynamic memory allocation out of effect_move_extent
+   Check HFS+ version, Set implementation creator code
+   Check journal absence, Corrected a bug in HFS+ block number
+   calculation							24-04-2004
+--------------------- PATCH FOR PARTED 1.6.11 ----------------------------
+11-Some pointer dereference moved after non nul assertion
+  -Error messages for HFS(+) file IO
+  -Memory leak correction in hfs(plus)_read_bad_blocks
+  -Mark out of volume blocks as used
+    (improve compatibility with broken HFS+ Linux
+    implementation)
+   WARNING : this fix is not 100% tn1150 compatible : 
+   "The allocation file may be larger than the minimum
+   number of bits required for the given volume size.
+   Any unused bits in the bitmap must be set to _zero_."
+   Anyway neither is the Linux implementation, nor was my
+   previous implementations
+   Maybe I should ask Apple to change the specifications
+  -HISTORY, DOC and TODO files					29-04-2004
+12 Corrected a bug in hfsplus_volume_resize : size of alloc 
+   bitmap could be miscalculated				29-04-2004
+--------------------- PATCH FOR PARTED 1.6.12 ----------------------------
+13-Finally partial rewrite of *_search_move_*
+   Easier to maintain and prepare for extent search and 
+   relocation algorithm changes for better ones.
+  -"An extent has not been relocated!" message now only when
+   relocation requested
+  -Slightly better and simpler relocation algorithm
+  -Update of Makefile.in and Makefile.am in fs_hfs
+  -Sign correction for some 8bits HFS integers
+  -Added the option --enable-hfs-extract-fs in 'configure'
+  -Added every ped_geometry_sync where needed
+  -Bugfix : "A root node does not need to exist
+  		(if the tree is empty)."
+	    - now handled correctly in btree_search
+  -Bugfix : failure wasn't detected in some cases
+	    during 2 pass relocation (*_search_move_*)
+  -Bugfix : The extent key comparaison was done in a wrong order
+	    and a pad field was used during the comparaison
+  -Bugfix : in hfs_file_find_sector and hfsplus_file_find_sector
+            the absolute position of a file sector could be
+	    miscalculated in case of fragmentation, resulting
+	    in potential data corruption, or various errors
+  -Bugfix : The end of the HFS bitmap compatibility block was
+	    miscalculated ( (1<<16)/8 instead of (1<<16) )
+	    in hfs_resize
+								07-09-2004
+--------------------- PATCH FOR PARTED 1.6.14 ----------------------------
+14 Port of Patch 13 for Parted 1.6.14 (update timestamps)
+								08-09-2004
+--------------------- PATCH FOR PARTED 1.6.15 ----------------------------
+15-hfsplus_open : added a warning message if the "attributes"
+   special file exists
+  -hfsplus_open : added a test to check if the "allocation"
+   special file has been correctly opened
+  -optimisation of hfs+ block access : don't recalculate
+   the address of each sector, and avoid checking the cache if
+   obviously not useful
+   ( hfsplus_file_read && hfsplus_file_write
+     && hfsplus_file_find_extent && hfs_file_find_sector)
+  -cut the "hfs.c" file in several parts
+  -Bugfix: in hfsplus_do_move_primary, hfs_effect_move_extent
+   was called instead of hfsplus_effect_move_extent !!!
+   This could not produce data corruption, because of a welcome
+   ASSERT in *_effect_move_extent that would detect the bug :)
+  -Bugfix: in hfs_effect_move_extent, do
+   	PED_ASSERT(*ptr_to_fblock <= *ptr_fblock, return -1);
+   instead of
+      	PED_ASSERT(*ptr_to_fblock < *ptr_fblock, return -1);
+   and added that assertion to hfsplus_effect_move_extent
+  -Bugfix: bugs introduced in rewrite of hfsplus_file_read
+   && hfsplus_file_write : last sector was incorrectly detected
+   as out of file.
+  -Cache the extent references (speed improvement ?)
+								23-09-2004
+16-Bugfix: in hfsplus_do_move (reloc_plus.c), case CR_BTREE_EXT_ATTR
+   incorrectly updated the cached part of priv_data->catalog_file
+   instead of priv_data->attributes_file
+  -Bugfix: in hfs_read_bad_blocks && hfsplus_read_bad_blocks,
+   now generate an error if file_ID or type mismatch after the
+   first pass
+   Also check return value of ped_malloc
+  -Bugfix: in hfsplus_btree_search, check return value of ped_malloc  
+								29-09-2004
diff -Nru parted-1.6.19/libparted/fs_hfs/Makefile.am parted-1.6.19-hfs-16/libparted/fs_hfs/Makefile.am
--- parted-1.6.19/libparted/fs_hfs/Makefile.am	2004-06-13 08:35:11.000000000 +0200
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/Makefile.am	2004-12-03 15:35:49.235783000 +0100
@@ -1,6 +1,14 @@
 partedincludedir	= -I$(top_srcdir)/include
 
 noinst_LTLIBRARIES	= libhfs.la
-libhfs_la_SOURCES	= hfs.c
+libhfs_la_SOURCES	= hfs.c hfs.h \
+			  probe.c probe.h \
+			  cache.c cache.h \
+			  advfs.c advfs.h \
+			  file.c file.h \
+			  reloc.c reloc.h \
+			  advfs_plus.c advfs_plus.h \
+			  file_plus.c file_plus.h \
+			  reloc_plus.c reloc_plus.h
 
 INCLUDES = $(partedincludedir) @INTLINCS@
diff -Nru parted-1.6.19/libparted/fs_hfs/Makefile.in parted-1.6.19-hfs-16/libparted/fs_hfs/Makefile.in
--- parted-1.6.19/libparted/fs_hfs/Makefile.in	2004-11-28 10:54:08.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/Makefile.in	2004-12-03 15:43:24.887513000 +0100
@@ -133,7 +133,16 @@
 partedincludedir = -I$(top_srcdir)/include
 
 noinst_LTLIBRARIES = libhfs.la
-libhfs_la_SOURCES = hfs.c
+libhfs_la_SOURCES = hfs.c hfs.h \
+			  probe.c probe.h \
+			  cache.c cache.h \
+			  advfs.c advfs.h \
+			  file.c file.h \
+			  reloc.c reloc.h \
+			  advfs_plus.c advfs_plus.h \
+			  file_plus.c file_plus.h \
+			  reloc_plus.c reloc_plus.h
+
 
 INCLUDES = $(partedincludedir) @INTLINCS@
 subdir = libparted/fs_hfs
@@ -144,7 +153,8 @@
 
 libhfs_la_LDFLAGS =
 libhfs_la_LIBADD =
-am_libhfs_la_OBJECTS = hfs.lo
+am_libhfs_la_OBJECTS = hfs.lo probe.lo cache.lo advfs.lo file.lo \
+	reloc.lo advfs_plus.lo file_plus.lo reloc_plus.lo
 libhfs_la_OBJECTS = $(am_libhfs_la_OBJECTS)
 
 DEFS = @DEFS@
@@ -154,7 +164,11 @@
 LIBS = @LIBS@
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
-@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/hfs.Plo
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/advfs.Plo ./$(DEPDIR)/advfs_plus.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/cache.Plo ./$(DEPDIR)/file.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/file_plus.Plo ./$(DEPDIR)/hfs.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/probe.Plo ./$(DEPDIR)/reloc.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/reloc_plus.Plo
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
@@ -164,7 +178,7 @@
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 CFLAGS = @CFLAGS@
 DIST_SOURCES = $(libhfs_la_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
+DIST_COMMON = Makefile.am Makefile.in TODO
 SOURCES = $(libhfs_la_SOURCES)
 
 all: all-am
@@ -194,7 +208,15 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/advfs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/advfs_plus.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cache.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file_plus.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hfs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/probe.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reloc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reloc_plus.Plo@am__quote@
 
 distclean-depend:
 	-rm -rf ./$(DEPDIR)
diff -Nru parted-1.6.19/libparted/fs_hfs/probe.c parted-1.6.19-hfs-16/libparted/fs_hfs/probe.c
--- parted-1.6.19/libparted/fs_hfs/probe.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/probe.c	2004-12-03 15:31:45.152889000 +0100
@@ -0,0 +1,163 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+
+#include "probe.h"
+
+/* Probe an HFS volume, detecting it even if
+it is in fact a wrapper to an HFS+ volume */
+/* Used by hfsplus_probe and hfs_probe */
+PedGeometry*
+hfs_and_wrapper_probe (PedGeometry* geom)
+{
+	uint8_t		buf[PED_SECTOR_SIZE];
+	HfsMasterDirectoryBlock	*mdb;
+	PedGeometry*	geom_ret;
+	PedSector	search, max;
+
+	PED_ASSERT(geom != NULL, return NULL);
+
+	mdb = (HfsMasterDirectoryBlock *) buf;
+
+	/* is 5 an intelligent value ? */
+	if ((geom->length < 5)
+	    || (!ped_geometry_read (geom, buf, 2, 1))
+	    || (PED_BE16_TO_CPU (mdb->signature) != HFS_SIGNATURE) )
+		return NULL;
+
+	search = ((PedSector) PED_BE16_TO_CPU (mdb->start_block)
+		  + ((PedSector) PED_BE16_TO_CPU (mdb->total_blocks)
+		     * (PED_BE32_TO_CPU (mdb->block_size) / PED_SECTOR_SIZE )));
+	max = search + (PED_BE32_TO_CPU (mdb->block_size) / PED_SECTOR_SIZE);
+	if (!(geom_ret = ped_geometry_new (geom->dev, geom->start, search + 2)))
+		return NULL;
+
+	for (; search < max; search++) {
+		if (!ped_geometry_set (geom_ret, geom_ret->start, search + 2)
+		    || !ped_geometry_read (geom_ret, buf, search, 1))
+			break;
+		if (PED_BE16_TO_CPU (mdb->signature) == HFS_SIGNATURE)
+			return geom_ret;
+	}
+
+	ped_geometry_destroy (geom_ret);
+	return NULL;
+}
+
+PedGeometry*
+hfsplus_probe (PedGeometry* geom)
+{
+	PedGeometry*	geom_ret;
+	uint8_t		buf[PED_SECTOR_SIZE];
+
+	PED_ASSERT(geom != NULL, return NULL);
+
+	if ((geom_ret = hfs_and_wrapper_probe(geom))) {
+		/* HFS+ is embedded in an HFS volume ? */
+		HfsMasterDirectoryBlock	*mdb;
+		mdb = (HfsMasterDirectoryBlock *) buf;
+
+		if (!ped_geometry_read (geom, buf, 2, 1)
+		    || (PED_BE16_TO_CPU (mdb->old_new.embedded.signature)
+			!= HFSP_SIGNATURE)) {
+			ped_geometry_destroy (geom_ret);
+			return NULL;
+		} else
+			return geom_ret;
+	} else {
+		/* This is a standalone HFS+ volume ? */
+		PedSector	search, max;
+		HfsPVolumeHeader *vh;
+		vh = (HfsPVolumeHeader *) buf;
+
+		if ((geom->length < 5)
+		    || !ped_geometry_read (geom, buf, 2, 1)
+		    || (PED_BE16_TO_CPU (vh->signature) != HFSP_SIGNATURE))
+			return NULL;
+
+		/* Correct range is indeed [ blocks*sz-2;(blocs+1)*sz-2 ( */
+		/* But previous versions of my implementation used to */
+		/* assume range is [(blocks-1)*sz-1;(blocks*sz) ( */
+		/* (blocks-1)*sz-1 has to be scanned last, because */
+		/* it can belong to a regular file */
+		max = ((PedSector) PED_BE32_TO_CPU (vh->total_blocks) + 1)
+		      * ( PED_BE32_TO_CPU (vh->block_size) / PED_SECTOR_SIZE )
+		      - 2;
+		search = max - 2 * ( PED_BE32_TO_CPU (vh->block_size)
+				     / PED_SECTOR_SIZE ) + 2;
+		if (!(geom_ret = ped_geometry_new (geom->dev, geom->start,
+						   search + 2)))
+			return NULL;
+
+		for (; search < max; search++) {
+			if (!ped_geometry_set (geom_ret, geom_ret->start,
+					       search + 2)
+			    || !ped_geometry_read (geom_ret, buf, search, 1))
+				break;
+			if (PED_BE16_TO_CPU (vh->signature) == HFSP_SIGNATURE)
+				return geom_ret;
+		}
+		search = ((PedSector) PED_BE32_TO_CPU (vh->total_blocks) - 1)
+		      * ( PED_BE32_TO_CPU (vh->block_size) / PED_SECTOR_SIZE )
+		      - 1;
+		if (!ped_geometry_set (geom_ret, geom_ret->start,
+					       search + 2)
+		    || !ped_geometry_read (geom_ret, buf, search, 1)
+		    || PED_BE16_TO_CPU (vh->signature) != HFSP_SIGNATURE) {
+		    	ped_geometry_destroy (geom_ret);
+			return NULL;
+		} else
+			return geom_ret;
+	}
+}
+
+PedGeometry*
+hfs_probe (PedGeometry* geom)
+{
+	PedGeometry*	geom_base;
+	PedGeometry*	geom_plus = NULL;
+	
+	PED_ASSERT(geom != NULL, return NULL);
+	
+	if ((geom_base = hfs_and_wrapper_probe(geom))
+	    && (!(geom_plus = hfsplus_probe(geom_base))))
+		return geom_base;
+	else {
+		if (geom_base) ped_geometry_destroy (geom_base);
+		if (geom_plus) ped_geometry_destroy (geom_plus);
+		return NULL;
+	}
+}
diff -Nru parted-1.6.19/libparted/fs_hfs/probe.h parted-1.6.19-hfs-16/libparted/fs_hfs/probe.h
--- parted-1.6.19/libparted/fs_hfs/probe.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/probe.h	2004-12-03 15:31:45.152889000 +0100
@@ -0,0 +1,38 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _PROBE_H
+#define _PROBE_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+PedGeometry*
+hfs_and_wrapper_probe (PedGeometry* geom);
+
+PedGeometry*
+hfsplus_probe (PedGeometry* geom);
+
+PedGeometry*
+hfs_probe (PedGeometry* geom);
+
+#endif /* _PROBE_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/reloc.c parted-1.6.19-hfs-16/libparted/fs_hfs/reloc.c
--- parted-1.6.19/libparted/fs_hfs/reloc.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/reloc.c	2004-12-03 15:31:45.153889000 +0100
@@ -0,0 +1,630 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+#include "file.h"
+#include "advfs.h"
+#include "cache.h"
+
+#include "reloc.h"
+
+/* This function moves data of size blocks starting
+   at block *ptr_fblock to block *ptr_to_fblock */
+/* return new start or -1 on failure */
+static int
+hfs_effect_move_extent (PedFileSystem *fs, unsigned int *ptr_fblock,
+			unsigned int *ptr_to_fblock, unsigned int size)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	unsigned int		i, ok = 0;
+	unsigned int		next_to_fblock;
+	unsigned int		start, stop;
+
+	PED_ASSERT(hfs_block != NULL, return -1);
+	PED_ASSERT(*ptr_to_fblock <= *ptr_fblock, return -1);
+	/* quiet gcc */
+	next_to_fblock = start = stop = 0;
+
+/*
+	Try to fit the extent AT or _BEFORE_ the wanted place,
+	or then in the gap between dest and source.
+	If failed try to fit the extent after source, for 2 pass relocation
+	The extent is always copied in a non overlapping way
+*/
+
+	/* Backward search */
+	/* 1 pass relocation AT or BEFORE *ptr_to_fblock */
+	if (*ptr_to_fblock != *ptr_fblock) {
+		start = stop = *ptr_fblock < *ptr_to_fblock+size ?
+			       *ptr_fblock : *ptr_to_fblock+size;
+		while (start && stop-start != size) {
+			--start;
+			if (TST_BLOC_OCCUPATION(priv_data->alloc_map,start))
+				stop = start;
+		}
+		ok = (stop-start == size);
+	}
+	
+	/* Forward search */
+	/* 1 pass relocation in the gap merged with 2 pass reloc after source */
+	if (!ok && *ptr_to_fblock != *ptr_fblock) {
+		start = stop = *ptr_to_fblock+1;
+		while (stop < PED_BE16_TO_CPU(priv_data->mdb->total_blocks)
+		       && stop-start != size) {
+			if (TST_BLOC_OCCUPATION(priv_data->alloc_map,stop))
+				start = stop + 1;
+			++stop;
+		}
+		ok = (stop-start == size);
+	}
+
+	/* new non overlapping room has been found ? */
+	if (ok) {
+		/* enough room */
+		unsigned int j;
+		unsigned int start_block =
+			PED_BE16_TO_CPU (priv_data->mdb->start_block );
+		unsigned int block_sz = 
+			(PED_BE32_TO_CPU (priv_data->mdb->block_size)
+			 / PED_SECTOR_SIZE);
+
+		if (stop > *ptr_to_fblock && stop <= *ptr_fblock)
+			/* Fit in the gap */
+			next_to_fblock = stop;
+		else
+			/* Before or after the gap */
+			next_to_fblock = *ptr_to_fblock;
+
+		/* move blocks */
+		for (i = 0; i < size; /*i+=j*/) {
+			PedSector 	abs_sector;
+			unsigned int	ai;
+
+			j = size - i; j = ((j < MAX_BUFF) ? j : MAX_BUFF);
+
+			abs_sector = start_block
+				     + (PedSector) (*ptr_fblock + i) * block_sz;
+			if (!ped_geometry_read (fs->geom, hfs_block, abs_sector,
+						block_sz * j))
+				return -1;
+
+			abs_sector = start_block
+				     + (PedSector) (start + i) * block_sz;
+			if (!ped_geometry_write (fs->geom,hfs_block,abs_sector,
+						 block_sz * j))
+				return -1;
+
+			for (ai = i+j; i < ai; i++) {
+				/* free source block */
+				CLR_BLOC_OCCUPATION(priv_data->alloc_map,
+						    *ptr_fblock + i);
+
+				/* set dest block */
+				SET_BLOC_OCCUPATION(priv_data->alloc_map,
+						    start + i);
+			}
+		}
+		if (!ped_geometry_sync(fs->geom))
+			return -1;
+
+		/* save the allocation map */
+		if (!ped_geometry_write(fs->geom, priv_data->alloc_map,
+					PED_BE16_TO_CPU (
+					   priv_data->mdb->volume_bitmap_block),
+					( PED_BE16_TO_CPU (
+					   priv_data->mdb->total_blocks)
+					  + PED_SECTOR_SIZE * 8 - 1)
+					/ (PED_SECTOR_SIZE * 8)))
+			return -1;
+		if (!ped_geometry_sync(fs->geom))
+			return -1;
+		
+		
+		*ptr_fblock += size;
+		*ptr_to_fblock = next_to_fblock;
+	} else {
+		if (*ptr_fblock != *ptr_to_fblock)
+			/* not enough room, but try to continue */
+			ped_exception_throw (PED_EXCEPTION_WARNING,
+					PED_EXCEPTION_IGNORE,
+					_("An extent has not been relocated."));
+		start = *ptr_fblock;
+		*ptr_fblock = *ptr_to_fblock = start + size;
+	}
+
+	return start;
+}
+
+/* Update MDB */
+/* Return 0 if an error occured */
+/* Return 1 if everything ok */
+int
+hfs_update_mdb (PedFileSystem *fs)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node[PED_SECTOR_SIZE];
+
+    	if (!ped_geometry_read (fs->geom, node, 2, 1))
+		return 0;
+	memcpy (node, priv_data->mdb, sizeof (HfsMasterDirectoryBlock));
+	if (   !ped_geometry_write (fs->geom, node, 2, 1)
+	    || !ped_geometry_write (fs->geom, node, fs->geom->length - 2, 1)
+	    || !ped_geometry_sync  (fs->geom))
+		return 0;
+	return 1;
+}
+
+/* Generic relocator */
+/* replace previous hfs_do_move_* */
+static int
+hfs_do_move (PedFileSystem* fs, unsigned int *ptr_src,
+	     unsigned int *ptr_dest, HfsCPrivateCache* cache,
+	     HfsCPrivateExtent* ref)
+{
+	uint8_t			node[PED_SECTOR_SIZE];
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsPrivateFile*		file;
+	HfsExtDescriptor*	extent;
+	HfsCPrivateExtent*	move;
+	int			new_start;
+
+	new_start = hfs_effect_move_extent (fs, ptr_src, ptr_dest, 
+					    ref->ext_length);
+	if (new_start == -1) return -1;
+
+	if (ref->ext_start != (unsigned) new_start) {
+		/* Load, modify & save */
+		switch (ref->where) {
+		/******** MDB *********/
+		    case CR_PRIM_CAT :
+			priv_data->catalog_file
+			->first[ref->ref_index].start_block = 
+				PED_CPU_TO_BE16(new_start);
+			goto CR_PRIM;
+		    case CR_PRIM_EXT :
+			priv_data->extent_file
+			->first[ref->ref_index].start_block = 
+				PED_CPU_TO_BE16(new_start);		    
+		    CR_PRIM :
+			extent = ( HfsExtDescriptor* )
+				 ( (uint8_t*)priv_data->mdb + ref->ref_offset );
+			extent[ref->ref_index].start_block =
+				PED_CPU_TO_BE16(new_start);
+			if (!hfs_update_mdb(fs)) return -1;
+			break;
+
+		/********* BTREE *******/
+		    case CR_BTREE_EXT_CAT :
+			if (priv_data->catalog_file
+			    ->cache[ref->ref_index].start_block
+			    == PED_CPU_TO_BE16(ref->ext_start))
+				priv_data->catalog_file
+				->cache[ref->ref_index].start_block =
+				PED_CPU_TO_BE16(new_start);
+		    case CR_BTREE_EXT_0 :
+			file = priv_data->extent_file;
+			goto CR_BTREE;
+		    case CR_BTREE_CAT :
+			file = priv_data->catalog_file;
+		    CR_BTREE:
+			PED_ASSERT(ref->sect_by_block == 1
+			           && ref->ref_offset < PED_SECTOR_SIZE,
+				   return -1);
+			if (!hfs_file_read_sector(file, node, ref->ref_block))
+				return -1;
+			extent = ( HfsExtDescriptor* ) (node + ref->ref_offset);
+			extent[ref->ref_index].start_block =
+				PED_CPU_TO_BE16(new_start);
+			if (!hfs_file_write_sector(file, node, ref->ref_block)
+			    || !ped_geometry_sync (fs->geom))
+				return -1;
+			break;
+
+		/********** BUG ********/
+		    default :
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			    PED_EXCEPTION_CANCEL,
+			  _("A reference to an extent comes from a place it "\
+			    "should not. You should check the filesystem !"));
+			return -1;
+			break;
+		}
+
+		/* Update the cache */
+		move = hfsc_cache_move_extent(cache, ref->ext_start, new_start);
+		if (!move) return -1; /* "cleanly" fail */
+		PED_ASSERT(move == ref, return -1); /* generate a bug */
+	}
+
+	return new_start;
+}
+
+/* This function moves an extent starting at block fblock to block to_fblock
+   if there's enough room */
+/* Return 1 if everything was fine */
+/* Return -1 if an error occured */
+/* Return 0 if no extent was found */
+/* Generic search thanks to the filesystem cache */
+static int
+hfs_move_extent_starting_at (PedFileSystem *fs, unsigned int *ptr_fblock,
+			     unsigned int *ptr_to_fblock, 
+			     HfsCPrivateCache* cache)
+{
+	HfsCPrivateExtent*	ref;
+	int			old_start, new_start;
+	
+	/* Reference search powered by the cache... */
+	/* This is the optimisation secret :) */
+	ref = hfsc_cache_search_extent(cache, *ptr_fblock);
+	if (!ref) return 0; /* not found */
+
+	old_start = *ptr_fblock;
+	new_start = hfs_do_move(fs, ptr_fblock, ptr_to_fblock, cache, ref);
+	if (new_start == -1) return -1;
+	if (new_start > old_start) { /* detect 2 pass reloc */
+		new_start = hfs_do_move(fs,&new_start,ptr_to_fblock,cache,ref);
+		if (new_start == -1 || new_start > old_start) return -1;
+	}
+	return 1;
+}
+
+static int
+hfs_cache_from_mdb(HfsCPrivateCache* cache, PedFileSystem* fs,
+		   PedTimer* timer)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsExtDescriptor*	extent;
+	unsigned int		j;
+
+	extent = priv_data->mdb->extents_file_rec;
+    	for (j = 0; j < HFS_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE16_TO_CPU(extent[j].start_block),
+			PED_BE16_TO_CPU(extent[j].block_count),
+			0, /* unused for mdb */
+			((uint8_t*)extent) - ((uint8_t*)priv_data->mdb),
+			1, /* load/save only 1 sector */
+			CR_PRIM_EXT,
+			j )
+		   )
+			return 0;
+	}
+
+	extent = priv_data->mdb->catalog_file_rec;
+	for (j = 0; j < HFS_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE16_TO_CPU(extent[j].start_block),
+			PED_BE16_TO_CPU(extent[j].block_count),
+			0,
+			((uint8_t*)extent) - ((uint8_t*)priv_data->mdb),
+			1,
+			CR_PRIM_CAT,
+			j )
+		   )
+			return 0;
+	}
+
+	return 1;
+}
+
+static int
+hfs_cache_from_catalog(HfsCPrivateCache* cache, PedFileSystem* fs,
+		   PedTimer* timer)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node[PED_SECTOR_SIZE];
+	HfsHeaderRecord*	header;
+	HfsNodeDescriptor*	desc = (HfsNodeDescriptor*) node;
+	HfsCatalogKey*		catalog_key;
+	HfsCatalog*		catalog_data;
+	HfsExtDescriptor*	extent;
+	unsigned int		leaf_node, record_number;
+	unsigned int		i, j;
+
+	if (!priv_data->catalog_file->sect_nb) {
+		ped_exception_throw (PED_EXCEPTION_INFORMATION,
+				     PED_EXCEPTION_OK,
+				   _("This HFS volume has no catalog file. "\
+				     "This is very unusual !"));
+		return 1;
+	}
+
+	if (!hfs_file_read_sector (priv_data->catalog_file, node, 0))
+		return 0;
+	header = (HfsHeaderRecord*)(node +  PED_BE16_TO_CPU(*((uint16_t*)
+						(node+(PED_SECTOR_SIZE-2)))));
+
+	for (leaf_node = PED_BE32_TO_CPU (header->first_leaf_node);
+	     leaf_node;
+	     leaf_node = PED_BE32_TO_CPU (desc->next)) {
+		if (!hfs_file_read_sector (priv_data->catalog_file,
+					   node, leaf_node))
+			return 0;
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = 1; i <= record_number; ++i) {
+		       /* undocumented alignement */
+			unsigned int skip;
+			catalog_key = (HfsCatalogKey*) (node + PED_BE16_TO_CPU(
+				*((uint16_t*)(node+(PED_SECTOR_SIZE - 2*i)))));
+			skip = (1 + catalog_key->key_length + 1) & ~1;
+			catalog_data = (HfsCatalog*)( ((uint8_t*)catalog_key)
+							+ skip );
+			/* check for obvious error in FS */
+			if (((uint8_t*)catalog_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)catalog_data - node
+				>= PED_SECTOR_SIZE 
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				return 0;
+			}
+
+			if (catalog_data->type != HFS_CAT_FILE) continue;
+
+			extent = catalog_data->sel.file.extents_data;
+			for (j = 0; j < HFS_EXT_NB; ++j) {
+				if (!extent[j].block_count) break;
+				if (!hfsc_cache_add_extent(
+					cache,
+					PED_BE16_TO_CPU(extent[j].start_block),
+					PED_BE16_TO_CPU(extent[j].block_count),
+					leaf_node,
+					(uint8_t*)extent - node,
+					1, /* hfs => btree block = 512 b */
+					CR_BTREE_CAT,
+					j )
+				   )
+					return 0;
+			}
+
+			extent = catalog_data->sel.file.extents_res;
+			for (j = 0; j < HFS_EXT_NB; ++j) {
+				if (!extent[j].block_count) break;
+				if (!hfsc_cache_add_extent(
+					cache,
+					PED_BE16_TO_CPU(extent[j].start_block),
+					PED_BE16_TO_CPU(extent[j].block_count),
+					leaf_node,
+					(uint8_t*)extent - node,
+					1, /* hfs => btree block = 512 b */
+					CR_BTREE_CAT,
+					j )
+				   )
+					return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+static int
+hfs_cache_from_extent(HfsCPrivateCache* cache, PedFileSystem* fs,
+		   PedTimer* timer)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node[PED_SECTOR_SIZE];
+	HfsHeaderRecord*	header;
+	HfsNodeDescriptor*	desc = (HfsNodeDescriptor*) node;
+	HfsExtentKey*		extent_key;
+	HfsExtDescriptor*	extent;
+	unsigned int		leaf_node, record_number;
+	unsigned int		i, j;
+
+	if (!priv_data->extent_file->sect_nb) {
+		ped_exception_throw (PED_EXCEPTION_INFORMATION,
+				     PED_EXCEPTION_OK,
+				   _("This HFS volume has no extents overflow"\
+				     " file. This is quite unusual !"));
+		return 1;
+	}
+
+	if (!hfs_file_read_sector (priv_data->extent_file, node, 0))
+		return 0;
+	header = ((HfsHeaderRecord*) (node + PED_BE16_TO_CPU(*((uint16_t *)
+						(node+(PED_SECTOR_SIZE-2))))));
+
+	for (leaf_node = PED_BE32_TO_CPU (header->first_leaf_node);
+	     leaf_node;
+	     leaf_node = PED_BE32_TO_CPU (desc->next)) {
+		if (!hfs_file_read_sector (priv_data->extent_file, node,
+					   leaf_node))
+			return 0;
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = 1; i <= record_number; i++) {
+			uint8_t	where;
+			extent_key = (HfsExtentKey*)
+					(node + PED_BE16_TO_CPU(*((uint16_t *)
+					      (node+(PED_SECTOR_SIZE - 2*i)))));
+			/* size is cst */
+			extent = (HfsExtDescriptor*)(((uint8_t*)extent_key)
+						       + sizeof (HfsExtentKey));
+			/* check for obvious error in FS */
+			if (((uint8_t*)extent_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)extent - node 
+			        >= PED_SECTOR_SIZE
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				return 0;
+			}
+
+			switch (extent_key->file_ID) {
+			    case PED_CPU_TO_BE32 (HFS_XTENT_ID) :
+				if (ped_exception_throw (PED_EXCEPTION_WARNING,
+						PED_EXCEPTION_IGNORE_CANCEL,
+				    _("The extents overflow file should not "\
+				      "contains extents of itself... You "\
+				      "should better check the filesystem."))
+				    != PED_EXCEPTION_IGNORE)
+					return 0;
+				where = CR_BTREE_EXT_EXT;
+				break;
+			    case PED_CPU_TO_BE32 (HFS_CATALOG_ID) :
+				where = CR_BTREE_EXT_CAT;
+				break;
+			    default :
+				where = CR_BTREE_EXT_0;
+				break;
+			}
+
+			for (j = 0; j < HFS_EXT_NB; ++j) {
+				if (!extent[j].block_count) break;
+				if (!hfsc_cache_add_extent(
+					cache,
+					PED_BE16_TO_CPU(extent[j].start_block),
+					PED_BE16_TO_CPU(extent[j].block_count),
+					leaf_node,
+					(uint8_t*)extent - node,
+					1, /* hfs => btree block = 512 b */
+					where,
+					j )
+				   )
+					return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+/* This function cache every extents start and length stored in any
+   fs structure into the adt defined in cache.[ch]
+   Returns NULL on failure */
+static HfsCPrivateCache*
+hfs_cache_extents(PedFileSystem *fs, PedTimer* timer)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsCPrivateCache*	ret;
+	unsigned int		file_number, block_number;
+
+	file_number = PED_BE32_TO_CPU(priv_data->mdb->file_count);
+	block_number = PED_BE16_TO_CPU(priv_data->mdb->total_blocks);
+	ret = hfsc_new_cache(block_number, file_number);
+	if (!ret) return NULL;
+
+	if (!hfs_cache_from_mdb(ret, fs, timer) ||
+	    !hfs_cache_from_catalog(ret, fs, timer) ||
+	    !hfs_cache_from_extent(ret, fs, timer)) {
+		ped_exception_throw(PED_EXCEPTION_ERROR,
+				    PED_EXCEPTION_CANCEL,
+				_("Could not cache the filesystem in memory."));
+		hfsc_delete_cache(ret);
+		return NULL;
+	}
+
+	return ret;
+}
+
+/* This function moves file's data to compact used and free space,
+   starting at fblock block */
+/* return 0 on error */
+int
+hfs_pack_free_space_from_block (PedFileSystem *fs, unsigned int fblock,
+			        PedTimer* timer, unsigned int to_free)
+{
+	HfsPrivateFSData* 	priv_data = (HfsPrivateFSData*)
+						fs->type_specific;
+	HfsMasterDirectoryBlock* mdb = priv_data->mdb;
+	HfsCPrivateCache*	cache;
+	unsigned int 		to_fblock = fblock;
+	unsigned int		start = fblock;
+	unsigned int		div = PED_BE16_TO_CPU (mdb->total_blocks)
+				      + 1 - start - to_free;
+	int			ret;
+	
+	PED_ASSERT (!hfs_block, return 0);
+
+	hfs_block = (uint8_t*)
+		ped_malloc( PED_BE32_TO_CPU (priv_data->mdb->block_size)
+			    * (MAX_BUFF) );
+
+	if (!hfs_block) return 0;
+	
+	cache = hfs_cache_extents(fs, timer);
+	if (!cache) { ped_free(hfs_block); hfs_block = NULL; return 0; }
+	
+	if (!hfs_read_bad_blocks (fs)) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Bad blocks list could not be loaded."));
+		hfsc_delete_cache(cache);
+		ped_free(hfs_block); hfs_block = NULL;
+		return 0;
+	}
+
+	while (fblock < PED_BE16_TO_CPU (mdb->total_blocks)) {
+		if (TST_BLOC_OCCUPATION(priv_data->alloc_map,fblock)
+		    && (!hfs_is_bad_block (fs, fblock))) {
+			if (!(ret = hfs_move_extent_starting_at (fs, &fblock,
+						&to_fblock, cache)))
+				to_fblock = ++fblock;
+			else if (ret == -1) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("An error occured during extent "\
+				      "relocation."));
+				hfsc_delete_cache(cache);
+				ped_free(hfs_block); hfs_block = NULL;
+				return 0;
+			}
+		} else {
+			fblock++;
+		}
+		
+		ped_timer_update(timer, (float)(to_fblock - start)/div);
+	}
+	
+	hfsc_delete_cache(cache);
+	ped_free(hfs_block); hfs_block = NULL;
+	return 1;
+}
+
+#endif /* !DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/reloc.h parted-1.6.19-hfs-16/libparted/fs_hfs/reloc.h
--- parted-1.6.19/libparted/fs_hfs/reloc.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/reloc.h	2004-12-03 15:31:45.153889000 +0100
@@ -0,0 +1,36 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _RELOC_H
+#define _RELOC_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+int
+hfs_update_mdb (PedFileSystem *fs);
+
+int
+hfs_pack_free_space_from_block (PedFileSystem *fs, unsigned int fblock,
+			        PedTimer* timer, unsigned int to_free);
+
+#endif /* _RELOC_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/reloc_plus.c parted-1.6.19-hfs-16/libparted/fs_hfs/reloc_plus.c
--- parted-1.6.19/libparted/fs_hfs/reloc_plus.c	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/reloc_plus.c	2004-12-03 15:31:45.154889000 +0100
@@ -0,0 +1,855 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef DISCOVER_ONLY
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+#include <stdint.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "hfs.h"
+#include "file_plus.h"
+#include "advfs_plus.h"
+#include "cache.h"
+
+#include "reloc_plus.h"
+
+/* This function moves data of size blocks starting at block *ptr_fblock
+   to block *ptr_to_fblock */
+/* return new start or -1 on failure */
+/* -1 is ok because there can only be 2^32-1 blocks, so the max possible
+   last one is 2^32-2 (and anyway it contains Alternate VH), so
+   -1 (== 2^32-1[2^32]) never represent a valid block */
+static int
+hfsplus_effect_move_extent (PedFileSystem *fs, unsigned int *ptr_fblock,
+			    unsigned int *ptr_to_fblock, unsigned int size)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	unsigned int		i, ok = 0;
+	unsigned int		next_to_fblock;
+	unsigned int		start, stop;
+
+	PED_ASSERT(hfsp_block != NULL, return -1);
+	PED_ASSERT(*ptr_to_fblock <= *ptr_fblock, return -1);
+	/* quiet GCC */
+	next_to_fblock = start = stop = 0;
+
+/*
+	Try to fit the extent AT or _BEFORE_ the wanted place,
+	or then in the gap between dest and source.
+	If failed try to fit the extent after source, for 2 pass relocation
+	The extent is always copied in a non overlapping way
+*/
+
+	/* Backward search */
+	/* 1 pass relocation AT or BEFORE *ptr_to_fblock */
+	if (*ptr_to_fblock != *ptr_fblock) {
+		start = stop = *ptr_fblock < *ptr_to_fblock+size ?
+			       *ptr_fblock : *ptr_to_fblock+size;
+		while (start && stop-start != size) {
+			--start;
+			if (TST_BLOC_OCCUPATION(priv_data->alloc_map,start))
+				stop = start;
+		}
+		ok = (stop-start == size);
+	}
+	
+	/* Forward search */
+	/* 1 pass relocation in the gap merged with 2 pass reloc after source */
+	if (!ok && *ptr_to_fblock != *ptr_fblock) {
+		start = stop = *ptr_to_fblock+1;
+		while (stop < PED_BE32_TO_CPU(priv_data->vh->total_blocks)
+		       && stop-start != size) {
+			if (TST_BLOC_OCCUPATION(priv_data->alloc_map,stop))
+				start = stop + 1;
+			++stop;
+		}
+		ok = (stop-start == size);
+	}
+
+	/* new non overlapping room has been found ? */
+	if (ok) {
+		/* enough room */
+		unsigned int j;
+		unsigned int block_sz = (PED_BE32_TO_CPU (
+					priv_data->vh->block_size)
+					/ PED_SECTOR_SIZE);
+
+		if (stop > *ptr_to_fblock && stop <= *ptr_fblock)
+			/* Fit in the gap */
+			next_to_fblock = stop;
+		else
+			/* Before or after the gap */
+			next_to_fblock = *ptr_to_fblock;
+
+		/* move blocks */
+		for (i = 0; i < size; /*i++*/) {
+			PedSector 	abs_sector;
+			unsigned int	ai;
+
+			j = size - i; j = ((j < MAX_BUFF) ? j : MAX_BUFF);
+			
+			abs_sector = (PedSector) (*ptr_fblock + i) * block_sz;
+			if (!ped_geometry_read (priv_data->plus_geom,
+						hfsp_block, abs_sector,
+						block_sz * j))
+				return -1;
+
+			abs_sector = (PedSector) (start + i) * block_sz;
+			if (!ped_geometry_write (priv_data->plus_geom,
+						 hfsp_block, abs_sector,
+						 block_sz * j))
+				return -1;
+
+			for (ai = i+j; i < ai; i++) {
+				/* free source block */
+				CLR_BLOC_OCCUPATION(priv_data->alloc_map,
+						    *ptr_fblock + i);
+
+				/* set dest block */
+				SET_BLOC_OCCUPATION(priv_data->alloc_map,
+						    start + i);
+			}
+		}
+		if (!ped_geometry_sync (priv_data->plus_geom))
+			return -1;
+
+/* TODO : a better handling of allocation map saving process */
+#if 0
+		/* save the allocation map */
+		if (!ped_geometry_write(fs->geom, priv_data->alloc_map, PED_BE16_TO_CPU (priv_data->mdb->volume_bitmap_block),
+			(PED_BE16_TO_CPU (priv_data->mdb->total_blocks) + PED_SECTOR_SIZE * 8 - 1) / (PED_SECTOR_SIZE * 8)))
+			return -1;
+#endif
+
+		*ptr_fblock += size;
+		*ptr_to_fblock = next_to_fblock;
+	} else {
+		if (*ptr_fblock != *ptr_to_fblock)
+			/* not enough room */
+			ped_exception_throw (PED_EXCEPTION_WARNING,
+			      PED_EXCEPTION_IGNORE,
+			      _("An extent has not been relocated."));
+		start = *ptr_fblock;
+		*ptr_fblock = *ptr_to_fblock = start + size;
+	}
+
+	return start;
+}
+
+/* Returns 0 on error */
+/*         1 on succes */
+int
+hfsplus_update_vh (PedFileSystem *fs)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node[PED_SECTOR_SIZE];
+
+    	if (!ped_geometry_read (priv_data->plus_geom, node, 2, 1))
+		return 0;
+	memcpy (node, priv_data->vh, sizeof (HfsPVolumeHeader));
+	if (!ped_geometry_write (priv_data->plus_geom, node, 2, 1))
+		return 0;
+	if (!ped_geometry_write (priv_data->plus_geom, node,
+				 priv_data->plus_geom->length - 2, 1)
+	    || !ped_geometry_sync (priv_data->plus_geom))
+		return 0;
+	return 1;
+}
+
+/* TODO : do NOT allocate memory in this function */
+static int
+hfsplus_do_move (PedFileSystem* fs, unsigned int *ptr_src,
+		 unsigned int *ptr_dest, HfsCPrivateCache* cache,
+		 HfsCPrivateExtent* ref)
+{
+	HfsPPrivateFSData*	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPPrivateFile*	file;
+	HfsPExtDescriptor*	extent;
+	HfsCPrivateExtent*	move;
+	int			new_start;
+
+	new_start = hfsplus_effect_move_extent (fs, ptr_src, ptr_dest,
+						ref->ext_length);
+
+	if (new_start == -1) return -1;
+	
+	if (ref->ext_start != (unsigned) new_start) {
+		switch (ref->where) {
+		/************ VH ************/
+		    case CR_PRIM_CAT :
+			priv_data->catalog_file
+			->first[ref->ref_index].start_block = 
+				PED_CPU_TO_BE32(new_start);
+			goto CR_PRIM;
+		    case CR_PRIM_EXT :
+			priv_data->extents_file
+			->first[ref->ref_index].start_block =
+				PED_CPU_TO_BE32(new_start);
+			goto CR_PRIM;
+		    case CR_PRIM_ATTR :
+			priv_data->attributes_file
+			->first[ref->ref_index].start_block =
+				PED_CPU_TO_BE32(new_start);
+			goto CR_PRIM;
+		    case CR_PRIM_ALLOC :
+			/* No allocation file opened */
+		    case CR_PRIM_START :
+			/* No startup file opened */
+		    CR_PRIM :
+			extent = ( HfsPExtDescriptor* )
+				 ( (uint8_t*)priv_data->vh + ref->ref_offset );
+			extent[ref->ref_index].start_block =
+				PED_CPU_TO_BE32(new_start);
+			if (!hfsplus_update_vh(fs))
+				return -1;
+			break;
+
+		/************** BTREE *************/
+		    case CR_BTREE_CAT :
+			file = priv_data->catalog_file;
+			goto CR_BTREE;
+
+		    case CR_BTREE_ATTR :
+			file = priv_data->attributes_file;
+			goto CR_BTREE;
+
+		    case CR_BTREE_EXT_ATTR :
+			if (priv_data->attributes_file
+			    ->cache[ref->ref_index].start_block
+			    == PED_CPU_TO_BE32(ref->ext_start))
+				priv_data->attributes_file
+				->cache[ref->ref_index].start_block =
+				PED_CPU_TO_BE32(new_start);
+			goto CR_BTREE_EXT;
+		    case CR_BTREE_EXT_CAT :
+			if (priv_data->catalog_file
+			    ->cache[ref->ref_index].start_block
+			    == PED_CPU_TO_BE32(ref->ext_start))
+				priv_data->catalog_file
+				->cache[ref->ref_index].start_block =
+				PED_CPU_TO_BE32(new_start);
+		    case CR_BTREE_EXT_ALLOC :
+			/* No allocation file opened */
+		    case CR_BTREE_EXT_START :
+		    	/* No startup file opened */
+		    CR_BTREE_EXT :
+		    case CR_BTREE_EXT_0 :
+			file = priv_data->extents_file;
+
+		    CR_BTREE :
+			PED_ASSERT(PED_SECTOR_SIZE * ref->sect_by_block
+				   > ref->ref_offset, return -1 );
+			if (!hfsplus_file_read(file, hfsp_block, 
+				(PedSector)ref->ref_block * ref->sect_by_block,
+				ref->sect_by_block))
+				return -1;
+			extent = ( HfsPExtDescriptor* )
+				( hfsp_block + ref->ref_offset );
+			extent[ref->ref_index].start_block =
+				PED_CPU_TO_BE32(new_start);
+			if (!hfsplus_file_write(file, hfsp_block,
+				(PedSector)ref->ref_block * ref->sect_by_block,
+				ref->sect_by_block)
+			    || !ped_geometry_sync (priv_data->plus_geom))
+				return -1;
+			break;
+
+		    /********** BUG *********/
+		    default :
+			ped_exception_throw (PED_EXCEPTION_ERROR,
+			    PED_EXCEPTION_CANCEL,
+			  _("A reference to an extent comes from a place it "\
+			    "should not. You should check the filesystem !"));
+			return -1;
+			break;
+		}
+
+		move = hfsc_cache_move_extent(cache, ref->ext_start, new_start);
+		if (!move) return -1;
+		PED_ASSERT(move == ref, return -1);
+	}
+
+	return new_start;
+}
+
+/* This function moves an extent starting at block fblock
+   to block to_fblock if there's enough room */
+/* Return 1 if everything was fine */
+/* Return -1 if an error occured */
+/* Return 0 if no extent was found */
+static int
+hfsplus_move_extent_starting_at (PedFileSystem *fs, unsigned int *ptr_fblock,
+				 unsigned int *ptr_to_fblock,
+				 HfsCPrivateCache* cache)
+{
+	HfsCPrivateExtent*	ref;
+	unsigned int		old_start, new_start;
+
+	ref = hfsc_cache_search_extent(cache, *ptr_fblock);
+	if (!ref) return 0;
+
+	old_start = *ptr_fblock;
+	new_start = hfsplus_do_move(fs, ptr_fblock, ptr_to_fblock, cache, ref);
+	if (new_start == (unsigned)-1) return -1;
+	if (new_start > old_start) {
+		new_start = hfsplus_do_move(fs, &new_start, ptr_to_fblock,
+					    cache, ref);
+		if (new_start == (unsigned)-1 || new_start > old_start)
+			return -1;
+	}
+
+	return 1;
+}
+
+static int
+hfsplus_cache_from_vh(HfsCPrivateCache* cache, PedFileSystem* fs,
+		      PedTimer* timer)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPExtDescriptor*	extent;
+	unsigned int		j;
+
+	extent = priv_data->vh->allocation_file.extents;
+	for (j = 0; j < HFSP_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE32_TO_CPU(extent[j].start_block),
+			PED_BE32_TO_CPU(extent[j].block_count),
+			0, /* unused for vh */
+			((uint8_t*)extent) - ((uint8_t*)priv_data->vh),
+			1, /* load / save 1 sector */
+			CR_PRIM_ALLOC,
+			j )
+		   )
+			return 0;
+	}
+
+	extent = priv_data->vh->extents_file.extents;
+	for (j = 0; j < HFSP_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE32_TO_CPU(extent[j].start_block),
+			PED_BE32_TO_CPU(extent[j].block_count),
+			0, /* unused for vh */
+			((uint8_t*)extent) - ((uint8_t*)priv_data->vh),
+			1, /* load / save 1 sector */
+			CR_PRIM_EXT,
+			j )
+		   )
+			return 0;
+	}
+
+	extent = priv_data->vh->catalog_file.extents;
+	for (j = 0; j < HFSP_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE32_TO_CPU(extent[j].start_block),
+			PED_BE32_TO_CPU(extent[j].block_count),
+			0, /* unused for vh */
+			((uint8_t*)extent) - ((uint8_t*)priv_data->vh),
+			1, /* load / save 1 sector */
+			CR_PRIM_CAT,
+			j )
+		   )
+			return 0;
+	}
+
+	extent = priv_data->vh->attributes_file.extents;
+	for (j = 0; j < HFSP_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE32_TO_CPU(extent[j].start_block),
+			PED_BE32_TO_CPU(extent[j].block_count),
+			0, /* unused for vh */
+			((uint8_t*)extent) - ((uint8_t*)priv_data->vh),
+			1, /* load / save 1 sector */
+			CR_PRIM_ATTR,
+			j )
+		   )
+			return 0;
+	}
+
+	extent = priv_data->vh->startup_file.extents;
+	for (j = 0; j < HFSP_EXT_NB; ++j) {
+		if (!extent[j].block_count) break;
+		if (!hfsc_cache_add_extent(
+			cache,
+			PED_BE32_TO_CPU(extent[j].start_block),
+			PED_BE32_TO_CPU(extent[j].block_count),
+			0, /* unused for vh */
+			((uint8_t*)extent) - ((uint8_t*)priv_data->vh),
+			1, /* load / save 1 sector */
+			CR_PRIM_START,
+			j )
+		   )
+			return 0;
+	}
+
+	return 1;
+}
+
+static int
+hfsplus_cache_from_catalog(HfsCPrivateCache* cache, PedFileSystem* fs,
+			   PedTimer* timer)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node_1[PED_SECTOR_SIZE];
+	uint8_t*		node;
+	HfsPHeaderRecord*	header;
+	HfsPNodeDescriptor*	desc = (HfsPNodeDescriptor*) node_1;
+	HfsPCatalogKey*		catalog_key;
+	HfsPCatalog*		catalog_data;
+	HfsPExtDescriptor*	extent;
+	unsigned int		leaf_node, record_number;
+	unsigned int		i, j, size, bsize;
+
+	if (!priv_data->catalog_file->sect_nb) {
+		ped_exception_throw (PED_EXCEPTION_INFORMATION,
+				     PED_EXCEPTION_OK,
+				   _("This HFS+ volume has no catalog file. "\
+				     "This is very unusual !"));
+		return 1;
+	}
+
+	/* Search the extent starting at *ptr_block in the catalog file */
+	if (!hfsplus_file_read_sector (priv_data->catalog_file, node_1, 0))
+		return 0;
+	header = (HfsPHeaderRecord*) (node_1 + HFS_FIRST_REC);
+	leaf_node = PED_BE32_TO_CPU (header->first_leaf_node);
+	bsize = PED_BE16_TO_CPU (header->node_size);
+	size = bsize / PED_SECTOR_SIZE;
+	PED_ASSERT(size < 256, return 0);
+
+	node = (uint8_t*) ped_malloc(bsize);
+	if (!node) return 0;
+	desc = (HfsPNodeDescriptor*) node;
+
+	for (; leaf_node; leaf_node = PED_BE32_TO_CPU (desc->next)) {
+		if (!hfsplus_file_read (priv_data->catalog_file, node,
+					(PedSector) leaf_node * size, size)) {
+			ped_free (node);
+			return 0;
+		}
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = 1; i <= record_number; i++) {
+			unsigned int	skip;
+			catalog_key = (HfsPCatalogKey*)
+			    ( node + PED_BE16_TO_CPU (*((uint16_t *)
+					(node+(bsize - 2*i)))) );
+			skip = ( 2 + PED_BE16_TO_CPU (catalog_key->key_length)
+				 + 1) & ~1;
+			catalog_data = (HfsPCatalog*)
+					    (((uint8_t*)catalog_key) + skip);
+			/* check for obvious error in FS */
+			if (((uint8_t*)catalog_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)catalog_data - node
+			        >= (signed) bsize
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				ped_free (node);
+				return 0;
+			}
+
+			if (PED_BE16_TO_CPU(catalog_data->type)!=HFS_CAT_FILE)
+				continue;
+
+			extent = catalog_data->sel.file.data_fork.extents;
+			for (j = 0; j < HFSP_EXT_NB; ++j) {
+				if (!extent[j].block_count) break;
+				if (!hfsc_cache_add_extent(
+					cache,
+					PED_BE32_TO_CPU(extent[j].start_block),
+					PED_BE32_TO_CPU(extent[j].block_count),
+					leaf_node,
+					(uint8_t*)extent - node,
+					size,
+					CR_BTREE_CAT,
+					j )
+				   ) {
+					ped_free (node);
+				 	return 0;
+				}
+			}
+
+			extent = catalog_data->sel.file.res_fork.extents;
+			for (j = 0; j < HFSP_EXT_NB; ++j) {
+				if (!extent[j].block_count) break;
+				if (!hfsc_cache_add_extent(
+					cache,
+					PED_BE32_TO_CPU(extent[j].start_block),
+					PED_BE32_TO_CPU(extent[j].block_count),
+					leaf_node,
+					(uint8_t*)extent - node,
+					size,
+					CR_BTREE_CAT,
+					j )
+				   ) {
+					ped_free (node);
+				 	return 0;
+				}
+			}
+		}
+	}
+
+	ped_free (node);
+	return 1;
+}
+
+static int
+hfsplus_cache_from_extent(HfsCPrivateCache* cache, PedFileSystem* fs,
+			  PedTimer* timer)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node_1[PED_SECTOR_SIZE];
+	uint8_t*		node;
+	HfsPHeaderRecord*	header;
+	HfsPNodeDescriptor*	desc = (HfsPNodeDescriptor*) node;
+	HfsPExtentKey*		extent_key;
+	HfsPExtDescriptor*	extent;
+	unsigned int		leaf_node, record_number;
+	unsigned int		i, j, size, bsize;
+
+	if (!priv_data->extents_file->sect_nb) {
+		ped_exception_throw (PED_EXCEPTION_INFORMATION,
+				     PED_EXCEPTION_OK,
+				   _("This HFS+ volume has no extents overflow"\
+				     " file. This is quite unusual !"));
+		return 1;
+	}
+
+	if (!hfsplus_file_read_sector (priv_data->extents_file, node_1, 0))
+		return 0;
+	header = ((HfsPHeaderRecord*) (node_1 + HFS_FIRST_REC));
+	leaf_node = PED_BE32_TO_CPU (header->first_leaf_node);
+	bsize = PED_BE16_TO_CPU (header->node_size);
+	size = bsize / PED_SECTOR_SIZE;
+	PED_ASSERT(size < 256, return 0);
+
+	node = (uint8_t*) ped_malloc (bsize);
+	if (!node) return -1;
+	desc = (HfsPNodeDescriptor*) node;
+
+	for (; leaf_node; leaf_node = PED_BE32_TO_CPU (desc->next)) {
+		if (!hfsplus_file_read (priv_data->extents_file, node,
+					(PedSector) leaf_node * size, size)) {
+			ped_free (node);
+			return 0;
+		}
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = 1; i <= record_number; i++) {
+			uint8_t where;
+			extent_key = (HfsPExtentKey*)
+			    (node + PED_BE16_TO_CPU(*((uint16_t *)
+					    (node+(bsize - 2*i)))));
+			extent = (HfsPExtDescriptor*)
+			    (((uint8_t*)extent_key) + sizeof (HfsPExtentKey));
+			/* check for obvious error in FS */
+			if (((uint8_t*)extent_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)extent - node
+			        >= (signed)bsize
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				ped_free (node);
+				return -1;
+			}
+			
+			switch (extent_key->file_ID) {
+			    case PED_CPU_TO_BE32 (HFS_XTENT_ID) :
+				if (ped_exception_throw (PED_EXCEPTION_WARNING,
+						PED_EXCEPTION_IGNORE_CANCEL,
+				    _("The extents overflow file should not "\
+				      "contains extents of itself... You "\
+				      "should better check the filesystem."))
+				    != PED_EXCEPTION_IGNORE)
+					return 0;
+				where = CR_BTREE_EXT_EXT;
+				break;
+			    case PED_CPU_TO_BE32 (HFS_CATALOG_ID) :
+				where = CR_BTREE_EXT_CAT;
+				break;
+			    case PED_CPU_TO_BE32 (HFSP_ALLOC_ID) :
+				where = CR_BTREE_EXT_ALLOC;
+				break;
+			    case PED_CPU_TO_BE32 (HFSP_STARTUP_ID) :
+				where = CR_BTREE_EXT_START;
+				break;
+			    case PED_CPU_TO_BE32 (HFSP_ATTRIB_ID) :
+			    	where = CR_BTREE_EXT_ATTR;
+				break;
+			    default :
+			    	where = CR_BTREE_EXT_0;
+				break;
+			}
+			
+			for (j = 0; j < HFSP_EXT_NB; ++j) {
+				if (!extent[j].block_count) break;
+				if (!hfsc_cache_add_extent(
+					cache,
+					PED_BE32_TO_CPU(extent[j].start_block),
+					PED_BE32_TO_CPU(extent[j].block_count),
+					leaf_node,
+					(uint8_t*)extent - node,
+					size,
+					where,
+					j )
+				   ) {
+					ped_free (node);
+					return 0;
+				}
+			}
+		}
+	}
+	
+	ped_free (node);
+	return 1;
+}
+
+static int
+hfsplus_cache_from_attributes(HfsCPrivateCache* cache, PedFileSystem* fs,
+			      PedTimer* timer)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	uint8_t			node_1[PED_SECTOR_SIZE];
+	uint8_t*		node;
+	HfsPHeaderRecord*	header;
+	HfsPNodeDescriptor*	desc = (HfsPNodeDescriptor*) node_1;
+	HfsPPrivateGenericKey*	generic_key;
+	HfsPForkDataAttr*	fork_ext_data;
+	HfsPExtDescriptor*	extent;
+	unsigned int		leaf_node, record_number;
+	unsigned int		i, j, size, bsize;
+
+	/* attributes file is facultative */
+	if (!priv_data->attributes_file->sect_nb)
+		return 1;
+
+	/* Search the extent starting at *ptr_block in the catalog file */
+	if (!hfsplus_file_read_sector (priv_data->attributes_file, node_1, 0))
+		return 0;
+	header = ((HfsPHeaderRecord*) (node_1 + HFS_FIRST_REC));
+	leaf_node = PED_BE32_TO_CPU (header->first_leaf_node);
+	bsize = PED_BE16_TO_CPU (header->node_size);
+	size = bsize / PED_SECTOR_SIZE;
+	PED_ASSERT(size < 256, return 0);
+
+	node = (uint8_t*) ped_malloc(bsize);
+	if (!node) return 0;
+	desc = (HfsPNodeDescriptor*) node;
+
+	for (; leaf_node; leaf_node = PED_BE32_TO_CPU (desc->next)) {
+		if (!hfsplus_file_read (priv_data->attributes_file, node,
+					(PedSector) leaf_node * size, size)) {
+			ped_free (node);
+			return 0;
+		}
+		record_number = PED_BE16_TO_CPU (desc->rec_nb);
+		for (i = 1; i <= record_number; i++) {
+			unsigned int	skip;
+			generic_key = (HfsPPrivateGenericKey*)
+				(node + PED_BE16_TO_CPU(*((uint16_t *)
+					    (node+(bsize - 2*i)))));
+			skip = ( 2 + PED_BE16_TO_CPU (generic_key->key_length)
+			         + 1 ) & ~1;
+			fork_ext_data = (HfsPForkDataAttr*)
+					    (((uint8_t*)generic_key) + skip);
+			/* check for obvious error in FS */
+			if (((uint8_t*)generic_key - node < HFS_FIRST_REC)
+			    || ((uint8_t*)fork_ext_data - node
+			        >= (signed) bsize
+				   - 2 * (signed)(record_number+1))) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("The filesystem contains errors."));
+				ped_free (node);
+				return 0;
+			}
+
+			if (fork_ext_data->record_type
+			    == PED_CPU_TO_BE32 ( HFSP_ATTR_FORK ) ) {
+				extent = fork_ext_data->fork_res.fork.extents;
+				for (j = 0; j < HFSP_EXT_NB; ++j) {
+					if (!extent[j].block_count) break;
+					if (!hfsc_cache_add_extent(
+						cache,
+						PED_BE32_TO_CPU (
+							extent[j].start_block ),
+						PED_BE32_TO_CPU (
+							extent[j].block_count ),
+						leaf_node,
+						(uint8_t*)extent-node,
+						size,
+						CR_BTREE_ATTR,
+						j )
+					   ) {
+						ped_free(node);
+						return 0;
+					}
+				}
+			} else if (fork_ext_data->record_type
+			    == PED_CPU_TO_BE32 ( HFSP_ATTR_EXTENTS ) ) {
+				extent = fork_ext_data->fork_res.extents;
+				for (j = 0; j < HFSP_EXT_NB; ++j) {
+					if (!extent[j].block_count) break;
+					if (!hfsc_cache_add_extent(
+						cache,
+						PED_BE32_TO_CPU (
+							extent[j].start_block ),
+						PED_BE32_TO_CPU (
+							extent[j].block_count ),
+						leaf_node,
+						(uint8_t*)extent-node,
+						size,
+						CR_BTREE_ATTR,
+						j )
+					   ) {
+						ped_free(node);
+						return 0;
+					}
+				}
+			} else continue;
+		}
+	}
+
+	ped_free (node);
+	return 1;
+}
+
+static HfsCPrivateCache*
+hfsplus_cache_extents(PedFileSystem* fs, PedTimer* timer)
+{
+	HfsPPrivateFSData*	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsCPrivateCache*	ret;
+	unsigned int		file_number, block_number;
+
+	file_number = PED_BE32_TO_CPU(priv_data->vh->file_count);
+	block_number = PED_BE32_TO_CPU(priv_data->vh->total_blocks);
+	ret = hfsc_new_cache(block_number, file_number);
+	if (!ret) return NULL;
+
+	if (!hfsplus_cache_from_vh(ret, fs, timer) ||
+	    !hfsplus_cache_from_catalog(ret, fs, timer) ||
+	    !hfsplus_cache_from_extent(ret, fs, timer) ||
+	    !hfsplus_cache_from_attributes(ret, fs, timer)) {
+		ped_exception_throw(PED_EXCEPTION_ERROR,
+				    PED_EXCEPTION_CANCEL,
+				_("Could not cache the filesystem in memory."));
+		hfsc_delete_cache(ret);
+		return NULL;
+	}
+
+	return ret;
+}
+
+/* This function moves file's data to compact used and free space,
+   starting at fblock block */
+/* return 0 on error */
+int
+hfsplus_pack_free_space_from_block (PedFileSystem *fs, unsigned int fblock,
+				    PedTimer* timer, unsigned int to_free)
+{
+	HfsPPrivateFSData* 	priv_data = (HfsPPrivateFSData*)
+						fs->type_specific;
+	HfsPVolumeHeader*	vh = priv_data->vh;
+	HfsCPrivateCache*	cache;
+	unsigned int 		to_fblock = fblock;
+	int			ret;
+	unsigned int		start = fblock;
+	unsigned int		div = PED_BE32_TO_CPU (vh->total_blocks)
+				      + 1 - start - to_free;
+
+	PED_ASSERT (!hfsp_block, return 0);
+
+	cache = hfsplus_cache_extents(fs, timer);
+	if (!cache) return 0;
+
+	ret = PED_BE32_TO_CPU (priv_data->vh->block_size) * MAX_BUFF;
+	if (ret < (signed) hfsc_cache_needed_buffer(cache))
+		ret = (signed) hfsc_cache_needed_buffer(cache);
+
+	hfsp_block = (uint8_t*) ped_malloc( ret );
+	if (!hfsp_block) { hfsc_delete_cache(cache); return 0; }
+
+	if (!hfsplus_read_bad_blocks (fs)) {
+		ped_exception_throw (PED_EXCEPTION_ERROR,
+		      PED_EXCEPTION_CANCEL,
+		      _("Bad blocks list could not be loaded."));
+		ped_free(hfsp_block); hfsp_block = NULL;
+		hfsc_delete_cache(cache);
+		return 0;
+	}
+
+	while ( fblock < ( priv_data->plus_geom->length - 2 )
+			 / ( PED_BE32_TO_CPU (vh->block_size)
+			     / PED_SECTOR_SIZE ) ) {
+		if (TST_BLOC_OCCUPATION(priv_data->alloc_map, fblock)
+		    && (!hfsplus_is_bad_block (fs, fblock))) {
+			if (!(ret = hfsplus_move_extent_starting_at (fs,
+						&fblock, &to_fblock, cache)))
+				to_fblock = ++fblock;
+			else if (ret == -1) {
+				ped_exception_throw (PED_EXCEPTION_ERROR,
+				      PED_EXCEPTION_CANCEL,
+				      _("An error occured during extent "\
+				      "relocation."));
+				ped_free(hfsp_block); hfsp_block = NULL;
+				hfsc_delete_cache(cache);
+				return 0;
+			}
+		} else {
+			fblock++;
+		}
+		
+		ped_timer_update(timer, (float)(to_fblock - start) / div);
+	}
+	
+	ped_free(hfsp_block); hfsp_block = NULL;
+	hfsc_delete_cache(cache);
+	return 1;
+}
+
+#endif /* !DISCOVER_ONLY */
diff -Nru parted-1.6.19/libparted/fs_hfs/reloc_plus.h parted-1.6.19-hfs-16/libparted/fs_hfs/reloc_plus.h
--- parted-1.6.19/libparted/fs_hfs/reloc_plus.h	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/reloc_plus.h	2004-12-03 15:31:45.155888000 +0100
@@ -0,0 +1,37 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 2004 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _RELOC_PLUS_H
+#define _RELOC_PLUS_H
+
+#include <parted/parted.h>
+#include <parted/endian.h>
+#include <parted/debug.h>
+
+#include "hfs.h"
+
+int
+hfsplus_update_vh (PedFileSystem *fs);
+
+int
+hfsplus_pack_free_space_from_block (PedFileSystem *fs, unsigned int fblock,
+				    PedTimer* timer, unsigned int to_free);
+
+
+#endif /* _RELOC_PLUS_H */
diff -Nru parted-1.6.19/libparted/fs_hfs/TODO parted-1.6.19-hfs-16/libparted/fs_hfs/TODO
--- parted-1.6.19/libparted/fs_hfs/TODO	1970-01-01 01:00:00.000000000 +0100
+++ parted-1.6.19-hfs-16/libparted/fs_hfs/TODO	2004-12-03 15:32:08.808293000 +0100
@@ -0,0 +1,28 @@
+--- TODO ---
+
+   * Think about a mean to do more allocation bitmap saves 
+     when shrinking hfs+ -- not too hard, put allocation bitmap
+     save after relocation or half relocation is completly done -- (high)
+   * selective bitmap save					-- (high)
+   * make resize do nothing in case of new_geom == old_geom :)  -- (high)
+   * Continue to write regressions tests and try on 2.6 kernel  -- (high)
+   * write doc, website, ...					-- (high)
+   
+   * MAX_BUFF in bytes ? Adaptative allocation ?		-- (medium)
+   * In hfs(plus)_btree_search , use a static variable to detect
+     illegal recursion and abort in that case. (find the right
+     number of recursion before reporting bug) -- easy		-- (medium)
+   * Finish the HFS Extractor					-- (medium)
+     
+   * Integrate HFSX						-- (low)
+   * Write code to allow enlarging and moving HFS[+x]		-- (low)
+   * Cache hfs(plus)_get_empty_end result ?			-- (low)
+   * Continue to change the relocation algorithm
+     for a better one :)					-- (low)
+
+--- NOT todo ---
+
+   * debug HFS(+) Linux implementation (block allocation for HFS+,
+     hard and sym links for HFS+, filename length for HFS, ...)	-- (dont)
+	/// Linux 2.6 contains HFS(+) implementations with less bugs
+	/// Linux 2.4 should not be used anymore to access HFS(+)
diff -Nru parted-1.6.19/parted/ui.c parted-1.6.19-hfs-16/parted/ui.c
--- parted-1.6.19/parted/ui.c	2004-11-22 22:53:47.000000000 +0100
+++ parted-1.6.19-hfs-16/parted/ui.c	2004-12-03 15:38:13.012925000 +0100
@@ -62,7 +62,7 @@
 
 #endif /* HAVE_LIBREADLINE */
 
-char* prog_name = "GNU Parted " VERSION "\n";
+char* prog_name = "GNU Parted " VERSION " with HFS shrink patch 16\n";
 
 static char* banner_msg = N_(
 "Copyright (C) 1998 - 2004 Free Software Foundation, Inc.\n"
